from PySide6.QtWidgets import *
from PySide6.QtGui import *
from PySide6.QtCore import *
from promptbook_widgets import CustomLineEdit, ImageView
from promptbook_utils import PromptBookUtils
from promptbook_state import PromptBookState
from promptbook_handlers import PromptBookEventHandlers
import os, json, csv, shutil, sys, re
import zipfile, datetime, base64
KAKAO_PAY_IMAGE_BASE64 = """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AAAAQ250Q2Jvb2wAAAAAAExibHNib29sAAAAAABOZ3R2Ym9vbAAAAAAARW1sRGJvb2wAAAAAAEludHJib29sAAAAAABCY2tnT2JqYwAAAAEAAAAAAABSR0JDAAAAAwAAAABSZCAgZG91YkBv4AAAAAAAAAAAAEdybiBkb3ViQG/gAAAAAAAAAAAAQmwgIGRvdWJAb+AAAAAAAAAAAABCcmRUVW50RiNSbHQAAAAAAAAAAAAAAABCbGQgVW50RiNSbHQAAAAAAAAAAAAAAABSc2x0VW50RiNQeGxAUgAAAAAAAAAAAAp2ZWN0b3JEYXRhYm9vbAEAAAAAUGdQc2VudW0AAAAAUGdQcwAAAABQZ1BDAAAAAExlZnRVbnRGI1JsdAAAAAAAAAAAAAAAAFRvcCBVbnRGI1JsdAAAAAAAAAAAAAAAAFNjbCBVbnRGI1ByY0BZAAAAAAAAAAAAEGNyb3BXaGVuUHJpbnRpbmdib29sAAAAAA5jcm9wUmVjdEJvdHRvbWxvbmcAAAAAAAAADGNyb3BSZWN0TGVmdGxvbmcAAAAAAAAADWNyb3BSZWN0UmlnaHRsb25nAAAAAAAAAAtjcm9wUmVjdFRvcGxvbmcAAAAAADhCSU0D7QAAAAAAEABIAAAAAQACAEgAAAABAAI4QklNBCYAAAAAAA4AAAAAAAAAAAAAP4AAADhCSU0EDQAAAAAABAAAAB44QklNBBkAAAAAAAQAAAAeOEJJTQPzAAAAAAAJAAAAAAAAAAABADhCSU0nEAAAAAAACgABAAAAAAAAAAI4QklNA/UAAAAAAEgAL2ZmAAEAbGZmAAYAAAAAAAEAL2ZmAAEAoZmaAAYAAAAAAAEAMgAAAAEAWgAAAAYAAAAAAAEANQAAAAEALQAAAAYAAAAAAAE4QklNA/gAAAAAAHAAAP////////////////////////////8D6AAAAAD/////////////////////////////A+gAAAAA/////////////////////////////wPoAAAAAP////////////////////////////8D6AAAOEJJTQQIAAAAAAAQAAAAAQAAAkAAAAJAAAAAADhCSU0ERAAAAAAAEAAAAAIAAAJAAAACQAAAAAA4QklNBB4AAAAAAAQAAAAAOEJJTQQaAAAAAANFAAAABgAAAAAA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H+bW11L6pdLzbOlGofYaejZAysfHxmMZWXB7btrqwz2tc9n+D/fW2kkpR1SSSSQpJJJJT//Q9RSSSRQpJJJJSkkkklKSSSSUpJJJJSkkkklKSSSSUpJJJJSkkkklKSSSSU//2QA4QklNBCEAAAAAAFcAAAABAQAAAA8AQQBkAG8AYgBlACAAUABoAG8AdABvAHMAaABvAHAAAAAUAEEAZABvAGIAZQAgAFAAaABvAHQAbwBzAGgAbwBwACAAMgAwADIANAAAAAEAOEJJTQQGAAAAAAAHAAgBAQABAQD/4QzdaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA5LjEtYzAwMiAxMTYuZWJjODMwNiwgMjAyNS8wMi8xOS0yMTozNzo1OCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOkRvY3VtZW50SUQ9IjE2MzBENzZDMkExRTA1RTEwQkQ4NUZCMEY2MkJBMDRBIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOmM2OGJhZTlhLWIyMzYtYzM0Ny05NjFiLTI5NDMyM2VmZjAyMCIgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSIxNjMwRDc2QzJBMUUwNUUxMEJEODVGQjBGNjJCQTA0QSIgZGM6Zm9ybWF0PSJpbWFnZS9qcGVnIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiBwaG90b3Nob3A6SUNDUHJvZmlsZT0ic1JHQiIgeG1wOkNyZWF0ZURhdGU9IjIwMjUtMDUtMjVUMDM6NDk6MDgrMDk6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMjUtMDUtMjZUMDA6MzQ6NTArMDk6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDI1LTA1LTI2VDAwOjM0OjUwKzA5OjAwIj4gPHhtcE1NOkhpc3Rvcnk+IDxyZGY6U2VxPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6YzY4YmFlOWEtYjIzNi1jMzQ3LTk2MWItMjk0MzIzZWZmMDIwIiBzdEV2dDp3aGVuPSIyMDI1LTA1LTI2VDAwOjM0OjUwKzA5OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgMjUuMTIgKFdpbmRvd3MpIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDwvcmRmOlNlcT4gPC94bXBNTTpIaXN0b3J5PiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8P3hwYWNrZXQgZW5kPSJ3Ij8+/+ICKElDQ19QUk9GSUxFAAEBAAACGAAAAAAEMAAAbW50clJHQiBYWVogAAAAAAAAAAAAAAAAYWNzcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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"""

# EXIF 정보 읽기를 위한 모듈
try:
    from PIL import Image
    from PIL.ExifTags import TAGS
    PIL_AVAILABLE = True
except ImportError:
    PIL_AVAILABLE = False
    print("[WARNING] PIL(Pillow) 모듈이 설치되지 않았습니다. EXIF 정보 기능이 제한됩니다.")

def get_app_directory():
    """실행 파일의 디렉토리를 반환합니다."""
    if getattr(sys, 'frozen', False):
        # PyInstaller로 빌드된 exe 파일인 경우
        return os.path.dirname(sys.executable)
    else:
        # 개발 환경에서 실행하는 경우
        return os.path.dirname(os.path.abspath(__file__))

def get_images_directory():
    """이미지 저장 디렉토리의 절대 경로를 반환합니다."""
    app_dir = get_app_directory()
    images_dir = os.path.join(app_dir, "images")
    os.makedirs(images_dir, exist_ok=True)
    return images_dir

def get_backup_directory():
    """백업 저장 디렉토리의 절대 경로를 반환합니다."""
    app_dir = get_app_directory()
    backup_dir = os.path.join(app_dir, "backup")
    os.makedirs(backup_dir, exist_ok=True)
    return backup_dir

# AI 테스터 모듈 import (숨김)
# try:
#     from ai_tester import AITesterDialog
# except ImportError:
#     AITesterDialog = None
# AITesterDialog = None

# 휴지통 기능을 위한 모듈 추가
try:
    from send2trash import send2trash
except ImportError:
    print("send2trash 모듈이 설치되지 않았습니다. pip install send2trash로 설치해 주세요.")
    send2trash = None

class ReadOnlyTextEdit(QTextEdit):
    """복사 기능이 완전히 활성화된 ReadOnly 텍스트 에디트"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        # ReadOnly를 False로 설정하되 편집을 막는 방식 사용
        self.setReadOnly(False)
        
        # 모든 텍스트 상호작용 허용
        self.setTextInteractionFlags(Qt.TextEditorInteraction)
        
        # 편집 방지를 위한 연결
        self.textChanged.connect(self.prevent_editing)
        self._original_text = ""
        self._updating = False
        
        # 커스텀 컨텍스트 메뉴 설정
        self.setContextMenuPolicy(Qt.CustomContextMenu)
        self.customContextMenuRequested.connect(self.show_custom_context_menu)
    
    def prevent_editing(self):
        """텍스트 변경을 방지"""
        if not self._updating and self.toPlainText() != self._original_text:
            self._updating = True
            self.setPlainText(self._original_text)
            self._updating = False
    
    def setPlainText(self, text):
        """텍스트 설정 시 원본 텍스트 저장"""
        self._updating = True
        super().setPlainText(text)
        self._original_text = text
        self._updating = False
    
    def show_custom_context_menu(self, position):
        """커스텀 컨텍스트 메뉴 표시 (복사 관련만)"""
        menu = QMenu(self)
        
        # 복사 액션
        copy_action = menu.addAction("📄 복사")
        copy_action.setShortcut(QKeySequence.Copy)
        copy_action.triggered.connect(self.copy_text)
        
        # 전체 선택 액션
        select_all_action = menu.addAction("🔘 전체 선택")
        select_all_action.setShortcut(QKeySequence.SelectAll)
        select_all_action.triggered.connect(self.selectAll)
        
        # 선택된 텍스트가 있는지 확인
        cursor = self.textCursor()
        has_selection = cursor.hasSelection()
        
        # 텍스트가 있는지 확인
        has_text = bool(self.toPlainText().strip())
        
        # 액션 활성화/비활성화
        copy_action.setEnabled(has_text)
        select_all_action.setEnabled(has_text)
        
        # 선택된 텍스트가 있으면 복사 텍스트 변경
        if has_selection:
            copy_action.setText("📄 선택된 텍스트 복사")
        else:
            copy_action.setText("📄 전체 텍스트 복사")
        
        # 메뉴 표시
        menu.exec(self.mapToGlobal(position))
    
    def copy_text(self):
        """텍스트 복사"""
        cursor = self.textCursor()
        if cursor.hasSelection():
            # 선택된 텍스트 복사
            selected_text = cursor.selectedText()
            QApplication.clipboard().setText(selected_text)
            print(f"[DEBUG] 선택된 텍스트 복사: {len(selected_text)}자")
        else:
            # 전체 텍스트 복사
            text = self.toPlainText()
            QApplication.clipboard().setText(text)
            print(f"[DEBUG] 전체 텍스트 복사: {len(text)}자")

    def keyPressEvent(self, event):
        """키 이벤트 처리"""
        # Ctrl+C, Ctrl+A, Ctrl+X는 기본 동작 허용
        if event.modifiers() == Qt.ControlModifier:
            if event.key() in [Qt.Key_C, Qt.Key_A, Qt.Key_X]:
                print(f"[DEBUG] 허용된 단축키: Ctrl+{chr(event.key())}")
                super().keyPressEvent(event)
                return
        
        # 방향키, 선택 관련 키는 허용
        navigation_keys = [
            Qt.Key_Left, Qt.Key_Right, Qt.Key_Up, Qt.Key_Down,
            Qt.Key_Home, Qt.Key_End, Qt.Key_PageUp, Qt.Key_PageDown
        ]
        
        if event.key() in navigation_keys or event.modifiers() & Qt.ShiftModifier:
            super().keyPressEvent(event)
            return
        
        # 기타 편집 키는 무시
        print(f"[DEBUG] 차단된 키: {event.key()}")
        event.ignore()

class ImageView(QGraphicsView):
    def __init__(self, parent=None):
        super().__init__(parent)
        # 고품질 렌더링을 위한 설정
        self.setRenderHints(
            QPainter.Antialiasing |            # 안티앨리어싱
            QPainter.SmoothPixmapTransform |   # 부드러운 이미지 변환
            QPainter.TextAntialiasing |        # 텍스트 안티앨리어싱
            QPainter.LosslessImageRendering    # 무손실 이미지 렌더링
        )
        
        # 뷰포트 업데이트 모드 설정 (고품질 렌더링을 위해)
        self.setViewportUpdateMode(QGraphicsView.FullViewportUpdate)
        
        # 스크롤바 숨기기
        self.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        
        # 프레임 제거
        self.setFrameShape(QFrame.NoFrame)
        
        # 드래그 모드 설정
        self.setDragMode(QGraphicsView.NoDrag)
        
        # 변환 최적화 (고품질 렌더링 우선)
        self.setOptimizationFlags(
            QGraphicsView.DontSavePainterState
        )
        
        # 캐시 모드 설정
        self.setCacheMode(QGraphicsView.CacheBackground)
        
        # 드래그 앤 드롭 활성화
        self.setAcceptDrops(True)
        
        # 드래그 앤 드롭 안내 라벨
        self.drop_hint = QLabel(self.viewport())
        self.drop_hint.setText("이미지 파일을 여기에\n드래그 앤 드롭하세요\n\n지원 형식: PNG, JPG, JPEG, BMP, GIF")
        self.drop_hint.setAlignment(Qt.AlignCenter)
        # 기본 스타일 설정 (나중에 테마에 따라 업데이트됨)
        self.update_drop_hint_style()
        self.update_drop_hint_position()
        
        # EXIF 오버레이 위젯
        self.exif_overlay = QWidget(self.viewport())
        self.exif_overlay.setVisible(False)
        self.setup_exif_overlay()
        
    def resizeEvent(self, event):
        super().resizeEvent(event)
        # 부모 위젯 체인을 따라 PromptBook 인스턴스를 찾습니다
        parent = self.parent()
        while parent is not None:
            if isinstance(parent, PromptBook):
                parent.update_image_fit()
                break
            parent = parent.parent()
        # 라벨 위치 및 가시성 업데이트
        self.update_drop_hint_position()
        self.update_drop_hint_visibility()
        # EXIF 오버레이 위치 업데이트
        self.update_exif_overlay_position()
        
    def update_drop_hint_position(self):
        if not hasattr(self, 'drop_hint'):
            return
            
        # 뷰포트 크기 가져오기
        viewport_rect = self.viewport().rect()
        
        # 라벨 크기 계산
        hint_width = min(350, viewport_rect.width() - 40)  # 여백 20px
        hint_height = 120  # 텍스트가 늘어났으므로 높이 증가
        
        # 중앙 위치 계산
        x = (viewport_rect.width() - hint_width) // 2
        y = (viewport_rect.height() - hint_height) // 2
        
        # 라벨 위치와 크기 설정
        self.drop_hint.setGeometry(x, y, hint_width, hint_height)
    
    def set_drop_hint_visible(self, visible):
        """드롭 힌트 표시/숨김 제어"""
        if hasattr(self, 'drop_hint'):
            self.drop_hint.setVisible(visible)
    
    def update_drop_hint_visibility(self):
        """드롭 힌트 표시 여부를 상태에 따라 업데이트"""
        if not hasattr(self, 'drop_hint'):
            return
            
        # 부모 PromptBook 인스턴스 찾기
        parent = self.parent()
        while parent is not None:
            if isinstance(parent, PromptBook):
                # 페이지가 선택되어 있고 이미지가 없을 때만 표시
                has_page_selected = (parent.current_index >= 0 and 
                                   0 <= parent.current_index < len(parent.state.characters))
                has_image = (has_page_selected and 
                           parent.state.characters[parent.current_index].get("image_path") and
                           os.path.exists(parent.state.characters[parent.current_index]["image_path"]))
                
                # 페이지가 선택되어 있고 이미지가 없을 때만 드롭 힌트 표시
                should_show = has_page_selected and not has_image
                self.drop_hint.setVisible(should_show)
                return
            parent = parent.parent()
        
        # PromptBook을 찾지 못한 경우 숨김
        self.drop_hint.setVisible(False)
    
    def update_drop_hint_style(self, theme=None):
        """드롭 힌트 스타일을 테마에 맞춰 업데이트"""
        if not hasattr(self, 'drop_hint'):
            return
            
        # 기본 테마 (어두운 모드)
        if theme is None:
            text_color = "#cccccc"
            bg_color = "rgba(60, 60, 60, 80)"
            border_color = "#555555"
        else:
            text_color = theme.get('text_secondary', '#cccccc')
            # surface 색상을 기반으로 반투명 배경 생성
            surface = theme.get('surface', '#3c3c3c')
            # 16진수 색상을 RGB로 변환하여 투명도 적용
            surface_rgb = surface.lstrip('#')
            r = int(surface_rgb[0:2], 16)
            g = int(surface_rgb[2:4], 16)
            b = int(surface_rgb[4:6], 16)
            bg_color = f"rgba({r}, {g}, {b}, 80)"
            border_color = theme.get('border', '#555555')
        
        style = f"""
            QLabel {{
                color: {text_color};
                background-color: {bg_color};
                font-size: 14px;
                padding: 30px;
                border: 2px dashed {border_color};
                border-radius: 10px;
            }}
        """
        self.drop_hint.setStyleSheet(style)
    
    def update_drop_hint_drag_style(self):
        """드래그 중일 때 스타일 (현재 테마의 primary 색상 사용)"""
        if not hasattr(self, 'drop_hint'):
            return
            
        # 부모 PromptBook에서 현재 테마 가져오기
        theme = self.get_current_theme()
        if theme:
            primary_color = theme.get('primary', '#0078d4')
            # primary 색상을 RGB로 변환하여 반투명 배경 생성
            primary_rgb = primary_color.lstrip('#')
            r = int(primary_rgb[0:2], 16)
            g = int(primary_rgb[2:4], 16)
            b = int(primary_rgb[4:6], 16)
            bg_color = f"rgba({r}, {g}, {b}, 50)"
        else:
            # 기본값
            primary_color = "#0078d4"
            bg_color = "rgba(0, 120, 212, 50)"
        
        style = f"""
            QLabel {{
                color: {primary_color};
                background-color: {bg_color};
                font-size: 14px;
                padding: 30px;
                border: 2px dashed {primary_color};
                border-radius: 10px;
            }}
        """
        self.drop_hint.setStyleSheet(style)
    
    def restore_drop_hint_style(self):
        """드롭 힌트를 원래 스타일로 복원"""
        theme = self.get_current_theme()
        self.update_drop_hint_style(theme)
    
    def get_current_theme(self):
        """부모 PromptBook에서 현재 테마 정보 가져오기"""
        parent = self.parent()
        while parent is not None:
            if isinstance(parent, PromptBook):
                current_theme_name = getattr(parent, 'current_theme', '어두운 모드')
                return parent.THEMES.get(current_theme_name)
            parent = parent.parent()
        return None
    
    def dragEnterEvent(self, event):
        """드래그 엔터 이벤트 처리"""
        if event.mimeData().hasUrls():
            # URL이 있는지 확인하고 이미지 파일인지 검사
            urls = event.mimeData().urls()
            if urls and len(urls) == 1:  # 하나의 파일만 허용
                file_path = urls[0].toLocalFile()
                if self.is_image_file(file_path):
                    event.acceptProposedAction()
                    # 드래그 중일 때 시각적 피드백 (현재 테마의 primary 색상 사용)
                    self.update_drop_hint_drag_style()
                    return
        event.ignore()
    
    def dragLeaveEvent(self, event):
        """드래그 리브 이벤트 처리"""
        # 원래 스타일로 복원
        self.restore_drop_hint_style()
        event.accept()
    
    def dragMoveEvent(self, event):
        """드래그 무브 이벤트 처리"""
        if event.mimeData().hasUrls():
            urls = event.mimeData().urls()
            if urls and len(urls) == 1:
                file_path = urls[0].toLocalFile()
                if self.is_image_file(file_path):
                    event.acceptProposedAction()
                    return
        event.ignore()
    
    def dropEvent(self, event):
        """드롭 이벤트 처리"""
        if event.mimeData().hasUrls():
            urls = event.mimeData().urls()
            if urls and len(urls) == 1:
                file_path = urls[0].toLocalFile()
                if self.is_image_file(file_path):
                    # 부모 PromptBook 인스턴스 찾기
                    parent = self.parent()
                    while parent is not None:
                        if isinstance(parent, PromptBook):
                            # 이미지 로드 기능 호출
                            parent.load_image_from_path(file_path)
                            break
                        parent = parent.parent()
                    
                    # 원래 스타일로 복원
                    self.restore_drop_hint_style()
                    event.acceptProposedAction()
                    return
        event.ignore()
    
    def is_image_file(self, file_path):
        """이미지 파일인지 확인"""
        if not file_path or not os.path.exists(file_path):
            return False
        
        # 지원하는 이미지 확장자
        image_extensions = {'.png', '.jpg', '.jpeg', '.bmp', '.gif', '.tiff', '.tif', '.webp'}
        file_ext = os.path.splitext(file_path)[1].lower()
        return file_ext in image_extensions

    def setup_exif_overlay(self):
        """EXIF 오버레이 위젯 설정"""
        # 오버레이 레이아웃
        overlay_layout = QVBoxLayout(self.exif_overlay)
        overlay_layout.setContentsMargins(20, 20, 20, 20)
        overlay_layout.setSpacing(10)
        
        # 스크롤 영역
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        
        # 내용 위젯
        content_widget = QWidget()
        content_layout = QVBoxLayout(content_widget)
        content_layout.setContentsMargins(10, 10, 10, 10)
        content_layout.setSpacing(8)
        
        # 제목
        title_label = QLabel("이미지 프롬프트 정보")
        title_label.setAlignment(Qt.AlignCenter)
        title_label.setStyleSheet("font-weight: bold; font-size: 14px; margin-bottom: 10px;")
        content_layout.addWidget(title_label)
        
        # 프롬프트 텍스트 영역 - 커스텀 클래스 사용
        self.prompt_text_area = ReadOnlyTextEdit()
        self.prompt_text_area.setMinimumHeight(150)  # 최소 높이만 설정
        self.prompt_text_area.setPlaceholderText("AI 프롬프트 정보가 여기에 표시됩니다...")
        
        # 포커스 정책 설정 (키보드 포커스 허용)
        self.prompt_text_area.setFocusPolicy(Qt.StrongFocus)
        
        content_layout.addWidget(self.prompt_text_area)
        
        # 버튼 레이아웃
        button_layout = QHBoxLayout()
        
        # 붙여넣기 버튼
        self.paste_prompt_btn = QPushButton("📋 입력란에 붙여넣기")
        self.paste_prompt_btn.clicked.connect(self.paste_prompt_to_input)
        self.paste_prompt_btn.setToolTip("프롬프트를 입력란에 추가합니다")
        button_layout.addWidget(self.paste_prompt_btn)
        
        # 닫기 버튼
        close_btn = QPushButton("❌ 닫기")
        close_btn.clicked.connect(self.hide_exif_overlay)
        button_layout.addWidget(close_btn)
        
        content_layout.addLayout(button_layout)
        
        # 스크롤 영역에 내용 설정
        scroll_area.setWidget(content_widget)
        overlay_layout.addWidget(scroll_area)
        
        # 오버레이 스타일 설정
        self.update_exif_overlay_style()

    def update_exif_overlay_style(self):
        """EXIF 오버레이 스타일 업데이트"""
        # 현재 테마 가져오기
        theme = self.get_current_theme()
        if not theme:
            # 기본 테마
            bg_color = "rgba(43, 43, 43, 230)"
            text_color = "#ffffff"
            border_color = "#555555"
            button_color = "#404040"
            button_hover = "#525252"
            textedit_bg = "rgba(0, 0, 0, 100)"
            scrollbar_bg = "rgba(0, 0, 0, 50)"
        else:
            # 테마 색상 사용
            bg_rgb = theme.get('surface', '#3c3c3c').lstrip('#')
            r = int(bg_rgb[0:2], 16)
            g = int(bg_rgb[2:4], 16)
            b = int(bg_rgb[4:6], 16)
            bg_color = f"rgba({r}, {g}, {b}, 230)"
            text_color = theme.get('text', '#ffffff')
            border_color = theme.get('border', '#555555')
            button_color = theme.get('button', '#404040')
            button_hover = theme.get('button_hover', '#525252')
            
            # QTextEdit 배경색을 테마에 맞게 설정
            textedit_rgb = theme.get('background', '#2b2b2b').lstrip('#')
            te_r = int(textedit_rgb[0:2], 16)
            te_g = int(textedit_rgb[2:4], 16)
            te_b = int(textedit_rgb[4:6], 16)
            textedit_bg = f"rgba({te_r}, {te_g}, {te_b}, 200)"
            
            # 스크롤바 배경색도 테마에 맞게 설정
            scrollbar_bg = f"rgba({te_r}, {te_g}, {te_b}, 100)"
        
        style = f"""
            QWidget {{
                background-color: {bg_color};
                color: {text_color};
                border: 2px solid {border_color};
                border-radius: 10px;
            }}
            QTextEdit {{
                background-color: {textedit_bg};
                border: 1px solid {border_color};
                border-radius: 5px;
                padding: 8px;
                font-family: 'Consolas', 'Monaco', monospace;
                font-size: 12px;
                color: {text_color};
            }}
            QPushButton {{
                background-color: {button_color};
                border: 1px solid {border_color};
                color: {text_color};
                padding: 8px 16px;
                border-radius: 5px;
                font-weight: bold;
                min-height: 20px;
            }}
            QPushButton:hover {{
                background-color: {button_hover};
            }}
            QScrollArea {{
                border: none;
                background-color: transparent;
            }}
            QScrollBar:vertical {{
                background-color: {scrollbar_bg};
                width: 12px;
                border-radius: 6px;
            }}
            QScrollBar::handle:vertical {{
                background-color: {border_color};
                border-radius: 6px;
                min-height: 20px;
            }}
        """
        self.exif_overlay.setStyleSheet(style)

    def update_exif_overlay_position(self):
        """EXIF 오버레이 위치 업데이트 (잘리지 않도록 개선)"""
        if not hasattr(self, 'exif_overlay'):
            return
            
        viewport_rect = self.viewport().rect()
        print(f"[DEBUG] 뷰포트 크기: {viewport_rect.width()} x {viewport_rect.height()}")
        
        # 최소 크기 보장 및 뷰포트에 맞는 크기 계산
        min_width = 400
        min_height = 300
        max_width = max(min_width, int(viewport_rect.width() * 0.9))  # 90%로 증가
        max_height = max(min_height, int(viewport_rect.height() * 0.9))  # 90%로 증가
        
        # 실제 오버레이 크기 결정
        overlay_width = min(700, max_width)  # 최대 700px
        overlay_height = min(500, max_height)  # 최대 500px
        
        # 뷰포트보다 큰 경우 뷰포트에 맞춤
        if overlay_width > viewport_rect.width():
            overlay_width = viewport_rect.width() - 20  # 여백 20px
        if overlay_height > viewport_rect.height():
            overlay_height = viewport_rect.height() - 20  # 여백 20px
        
        # 중앙 위치 계산 (음수 방지)
        x = max(10, (viewport_rect.width() - overlay_width) // 2)
        y = max(10, (viewport_rect.height() - overlay_height) // 2)
        
        print(f"[DEBUG] 오버레이 크기: {overlay_width} x {overlay_height}, 위치: ({x}, {y})")
        self.exif_overlay.setGeometry(x, y, overlay_width, overlay_height)

    def show_exif_overlay(self, image_path):
        """EXIF 오버레이 표시"""
        print(f"[DEBUG] EXIF 오버레이 표시 요청: {image_path}")
        
        if not PIL_AVAILABLE:
            print("[DEBUG] PIL 사용 불가능, 기본 메시지 표시")
            self.prompt_text_area.setPlainText("PIL(Pillow) 라이브러리가 설치되지 않아 EXIF 정보를 읽을 수 없습니다.\n\npip install Pillow 명령으로 설치해주세요.")
            self.paste_prompt_btn.setEnabled(False)
            self.update_exif_overlay_position()
            self.exif_overlay.setVisible(True)
            self.exif_overlay.raise_()
            return
            
        try:
            # 이미지에서 EXIF 정보 추출
            prompt_info = self.extract_ai_prompt_from_image(image_path)
            
            if prompt_info:
                print(f"[DEBUG] AI 프롬프트 정보 발견: {len(prompt_info)}자")
                self.prompt_text_area.setPlainText(prompt_info)
                self.paste_prompt_btn.setEnabled(True)
            else:
                print("[DEBUG] AI 프롬프트 정보 없음, 기본 메시지 표시")
                # 이미지 기본 정보라도 표시
                basic_info = self.get_basic_image_info(image_path)
                self.prompt_text_area.setPlainText(f"이 이미지에서 AI 프롬프트 정보를 찾을 수 없습니다.\n\n{basic_info}")
                self.paste_prompt_btn.setEnabled(False)
            
            print("[DEBUG] EXIF 오버레이 표시 중...")
            self.update_exif_overlay_position()
            self.exif_overlay.setVisible(True)
            self.exif_overlay.raise_()
            print("[DEBUG] EXIF 오버레이 표시 완료")
            
        except Exception as e:
            print(f"[ERROR] EXIF 정보 읽기 실패: {e}")
            import traceback
            traceback.print_exc()
            # 오류가 발생해도 오버레이는 표시
            self.prompt_text_area.setPlainText(f"EXIF 정보 읽기 중 오류가 발생했습니다:\n{str(e)}")
            self.paste_prompt_btn.setEnabled(False)
            self.update_exif_overlay_position()
            self.exif_overlay.setVisible(True)
            self.exif_overlay.raise_()

    def hide_exif_overlay(self):
        """EXIF 오버레이 숨기기"""
        self.exif_overlay.setVisible(False)
        
        # 부모 PromptBook에서 체크박스 해제
        parent = self.parent()
        while parent is not None:
            if isinstance(parent, PromptBook):
                parent.exif_checkbox.setChecked(False)
                break
            parent = parent.parent()

    def get_basic_image_info(self, image_path):
        """이미지 기본 정보 가져오기"""
        try:
            if not PIL_AVAILABLE:
                return "PIL 라이브러리가 필요합니다."
            
            import os
            from PIL import Image
            
            with Image.open(image_path) as img:
                # 파일 크기
                file_size = os.path.getsize(image_path)
                size_mb = file_size / (1024 * 1024)
                
                info_text = f"""📸 이미지 기본 정보:
• 파일명: {os.path.basename(image_path)}
• 포맷: {img.format}
• 크기: {img.width} × {img.height} 픽셀
• 모드: {img.mode}
• 파일 크기: {size_mb:.2f} MB

💡 이 이미지는 AI 생성 이미지가 아니거나, 
   메타데이터에 프롬프트 정보가 포함되지 않았습니다.

🔍 지원하는 AI 도구:
• Stable Diffusion (PNG 메타데이터)
• DALL-E (EXIF description)
• Midjourney (다양한 메타데이터)
• 기타 AI 이미지 생성 도구"""
                
                return info_text
                
        except Exception as e:
            return f"이미지 정보 읽기 실패: {str(e)}"

    def extract_ai_prompt_from_image(self, image_path):
        """이미지에서 AI 프롬프트 정보 추출"""
        if not PIL_AVAILABLE:
            print("[DEBUG] PIL 라이브러리가 사용 불가능합니다.")
            return None
            
        try:
            print(f"[DEBUG] EXIF 정보 추출 시도: {image_path}")
            with Image.open(image_path) as img:
                print(f"[DEBUG] 이미지 포맷: {img.format}")
                print(f"[DEBUG] 이미지 모드: {img.mode}")
                
                # EXIF 데이터 가져오기
                exif_data = img.getexif()
                print(f"[DEBUG] EXIF 데이터 개수: {len(exif_data)}")
                
                # 모든 EXIF 데이터 출력 (디버깅용)
                if exif_data:
                    print("[DEBUG] EXIF 데이터:")
                    for tag_id, value in exif_data.items():
                        tag_name = TAGS.get(tag_id, tag_id)
                        print(f"  {tag_name} ({tag_id}): {str(value)[:100]}...")
                
                # PNG 텍스트 정보 확인
                if hasattr(img, 'text') and img.text:
                    print(f"[DEBUG] PNG 텍스트 정보 개수: {len(img.text)}")
                    for key, value in img.text.items():
                        print(f"  {key}: {str(value)[:100]}...")
                
                # 기타 info 확인
                if hasattr(img, 'info') and img.info:
                    print(f"[DEBUG] 기타 info 개수: {len(img.info)}")
                    for key, value in img.info.items():
                        print(f"  {key}: {str(value)[:100]}...")
                
                # 일반적인 AI 생성 이미지 메타데이터 필드들
                ai_fields = [
                    'prompt', 'Prompt', 'PROMPT',
                    'positive_prompt', 'Positive Prompt',
                    'parameters', 'Parameters', 'PARAMETERS',
                    'generation_data', 'Generation Data',
                    'stable_diffusion', 'Stable Diffusion',
                    'midjourney', 'Midjourney',
                    'dalle', 'DALL-E', 'dall-e',
                    'description', 'Description', 'DESCRIPTION',
                    'UserComment', 'ImageDescription', 'Comment',
                    'Software', 'Artist', 'Copyright'
                ]
                
                # EXIF 데이터에서 AI 프롬프트 찾기
                for tag_id, value in exif_data.items():
                    tag_name = TAGS.get(tag_id, tag_id)
                    if isinstance(value, str) and len(value) > 10:  # 길이 조건 완화
                        print(f"[DEBUG] EXIF 검사: {tag_name} = {value[:50]}...")
                        for field in ai_fields:
                            if (field.lower() in tag_name.lower() or 
                                field.lower() in value.lower()[:100]):
                                print(f"[DEBUG] EXIF에서 AI 프롬프트 발견: {tag_name}")
                                # NovelAI V4 프롬프트 파싱 시도
                                parsed_prompt = self.parse_novelai_prompt(value)
                                return parsed_prompt if parsed_prompt else value
                
                # PNG 정보 확인 (PNG 메타데이터)
                if hasattr(img, 'text'):
                    for key, value in img.text.items():
                        if isinstance(value, str) and len(value) > 10:
                            print(f"[DEBUG] PNG 텍스트 검사: {key} = {value[:50]}...")
                            for field in ai_fields:
                                if field.lower() in key.lower():
                                    print(f"[DEBUG] PNG에서 AI 프롬프트 발견: {key}")
                                    # NovelAI V4 프롬프트 파싱 시도
                                    parsed_prompt = self.parse_novelai_prompt(value)
                                    return parsed_prompt if parsed_prompt else value
                
                # 기타 메타데이터 확인
                if hasattr(img, 'info'):
                    for key, value in img.info.items():
                        if isinstance(value, str) and len(value) > 10:
                            print(f"[DEBUG] Info 검사: {key} = {str(value)[:50]}...")
                            for field in ai_fields:
                                if field.lower() in str(key).lower():
                                    print(f"[DEBUG] Info에서 AI 프롬프트 발견: {key}")
                                    # NovelAI V4 프롬프트 파싱 시도
                                    parsed_prompt = self.parse_novelai_prompt(value)
                                    return parsed_prompt if parsed_prompt else value
                
                # 특별한 경우: 모든 긴 텍스트 필드 검사
                all_text_data = []
                
                # EXIF에서 긴 텍스트 수집
                for tag_id, value in exif_data.items():
                    if isinstance(value, str) and len(value) > 50:
                        all_text_data.append(f"EXIF-{TAGS.get(tag_id, tag_id)}: {value}")
                
                # PNG 텍스트에서 수집
                if hasattr(img, 'text'):
                    for key, value in img.text.items():
                        if isinstance(value, str) and len(value) > 50:
                            all_text_data.append(f"PNG-{key}: {value}")
                
                # Info에서 수집
                if hasattr(img, 'info'):
                    for key, value in img.info.items():
                        if isinstance(value, str) and len(value) > 50:
                            all_text_data.append(f"Info-{key}: {value}")
                
                if all_text_data:
                    print(f"[DEBUG] 발견된 긴 텍스트 데이터 {len(all_text_data)}개:")
                    for data in all_text_data:
                        print(f"  {data[:100]}...")
                    # 첫 번째 긴 텍스트를 반환 (NovelAI 파싱 시도)
                    raw_text = all_text_data[0].split(': ', 1)[1] if ': ' in all_text_data[0] else all_text_data[0]
                    parsed_prompt = self.parse_novelai_prompt(raw_text)
                    return parsed_prompt if parsed_prompt else raw_text
                
                print("[DEBUG] AI 프롬프트 정보를 찾을 수 없습니다.")
                return None
                
        except Exception as e:
            print(f"[ERROR] 이미지 메타데이터 읽기 실패: {e}")
            import traceback
            traceback.print_exc()
            return None

    def parse_novelai_prompt(self, raw_prompt):
        """NovelAI V4 프롬프트를 구조화된 형태로 파싱"""
        try:
            import json
            
            # JSON 형태인지 확인
            if raw_prompt.strip().startswith('{') and raw_prompt.strip().endswith('}'):
                print("[DEBUG] NovelAI JSON 프롬프트 파싱 시도")
                prompt_data = json.loads(raw_prompt)
                

                # NovelAI V4 구조 확인
                if 'prompt' in prompt_data:
                    formatted_prompt = ""
                    
                    # 메인 프롬프트
                    main_prompt = prompt_data.get('prompt', '')
                    if main_prompt:
                        formatted_prompt += "📝 메인 프롬프트:\n"
                        formatted_prompt += f"{main_prompt}\n\n"
                    
                    # 네거티브 프롬프트
                    negative_prompt = prompt_data.get('uc', '')
                    if negative_prompt:
                        formatted_prompt += "🚫 메인 네거티브:\n"
                        formatted_prompt += f"{negative_prompt}\n\n"
                    
                    # V4 캐릭터 정보 파싱
                    v4_prompt = prompt_data.get('v4_prompt', {})
                    v4_negative = prompt_data.get('v4_negative_prompt', {})
                    
                    # 캐릭터 프롬프트 추출
                    char_prompts = []
                    char_negatives = []
                    
                    if v4_prompt and isinstance(v4_prompt, dict) and 'caption' in v4_prompt:
                        caption_data = v4_prompt['caption']
                        if isinstance(caption_data, dict) and 'char_captions' in caption_data:
                            char_captions = caption_data['char_captions']
                            if isinstance(char_captions, list):
                                for char_data in char_captions:
                                    if isinstance(char_data, dict) and 'char_caption' in char_data:
                                        char_prompts.append(char_data['char_caption'])
                    
                    if v4_negative and isinstance(v4_negative, dict) and 'caption' in v4_negative:
                        caption_data = v4_negative['caption']
                        if isinstance(caption_data, dict) and 'char_captions' in caption_data:
                            char_captions = caption_data['char_captions']
                            if isinstance(char_captions, list):
                                for char_data in char_captions:
                                    if isinstance(char_data, dict) and 'char_caption' in char_data:
                                        char_negatives.append(char_data['char_caption'])
                    
                    # 캐릭터 정보 표시
                    max_chars = max(len(char_prompts), len(char_negatives))
                    if max_chars > 0:
                        for i in range(max_chars):
                            if i < len(char_prompts) and char_prompts[i]:
                                formatted_prompt += f"👥 캐릭터{i+1} 프롬프트:\n"
                                formatted_prompt += f"{char_prompts[i]}\n\n"
                            
                            if i < len(char_negatives) and char_negatives[i]:
                                formatted_prompt += f"🚫 캐릭터{i+1} 네거티브:\n"
                                formatted_prompt += f"{char_negatives[i]}\n\n"
                    
                    print(f"[DEBUG] NovelAI 프롬프트 파싱 완료: {len(formatted_prompt)}자")
                    return formatted_prompt
                    
            # JSON이 아니거나 NovelAI 형식이 아닌 경우
            print("[DEBUG] NovelAI 형식이 아님, 원본 반환")
            return None
            
        except json.JSONDecodeError:
            print("[DEBUG] JSON 파싱 실패, 원본 반환")
            return None
        except Exception as e:
            print(f"[DEBUG] NovelAI 프롬프트 파싱 오류: {e}")
            return None

    def eventFilter(self, obj, event):
        """이벤트 필터 - 기본 동작 허용"""
        return super().eventFilter(obj, event)

    def copy_selected_text(self):
        """선택된 텍스트를 클립보드에 복사 (버튼용)"""
        try:
            cursor = self.prompt_text_area.textCursor()
            selected_text = cursor.selectedText()
            
            if selected_text:
                QApplication.clipboard().setText(selected_text)
                print(f"[DEBUG] 선택된 텍스트 복사됨: {len(selected_text)}자")
            else:
                text = self.prompt_text_area.toPlainText()
                if text.strip():
                    QApplication.clipboard().setText(text)
                    print(f"[DEBUG] 전체 텍스트 복사됨: {len(text)}자")
                    
        except Exception as e:
            print(f"[ERROR] 텍스트 복사 실패: {e}")



    def paste_prompt_to_input(self):
        """프롬프트를 입력란에 붙여넣기"""
        # 부모 PromptBook 인스턴스 찾기
        parent = self.parent()
        while parent is not None:
            if isinstance(parent, PromptBook):
                current_text = parent.prompt_input.toPlainText()
                new_text = self.prompt_text_area.toPlainText()
                
                if current_text.strip():
                    # 기존 텍스트가 있으면 줄바꿈 후 추가
                    combined_text = current_text + "\n\n" + new_text
                else:
                    # 기존 텍스트가 없으면 그대로 추가
                    combined_text = new_text
                
                parent.prompt_input.setPlainText(combined_text)
                self.hide_exif_overlay()
                
                # 툴팁 표시
                QToolTip.showText(
                    self.paste_prompt_btn.mapToGlobal(self.paste_prompt_btn.rect().center()),
                    "프롬프트가 입력란에 추가되었습니다!"
                )
                break
            parent = parent.parent()



class ClickableLabel(QLabel):
    """클릭 가능한 라벨"""
    clicked = Signal()
    
    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            self.clicked.emit()
            event.accept()  # 이벤트 전파를 막아서 부모 리스트의 선택을 방지
            # 이벤트를 완전히 소비하여 부모로 전파되지 않도록 함
            return
        super().mousePressEvent(event)
    
    def mouseReleaseEvent(self, event):
        # 마우스 릴리즈 이벤트도 차단
        if event.button() == Qt.LeftButton:
            event.accept()
            return
        super().mouseReleaseEvent(event)

class PageItemWidget(QWidget):
    def __init__(self, name, is_favorite=False, emoji="📄", is_locked=False, parent=None):
        super().__init__(parent)
        self.page_name = name
        
        layout = QHBoxLayout(self)
        layout.setContentsMargins(4, 2, 4, 2)  # 여백 줄이기
        layout.setSpacing(2)  # 간격 대폭 줄이기
        
        # 별 표시 라벨 (클릭 가능)
        self.star_label = ClickableLabel()
        self.star_label.setFixedWidth(16)  # 폭 줄이기
        self.star_label.setAlignment(Qt.AlignCenter)
        self.star_label.setCursor(Qt.PointingHandCursor)  # 마우스 커서 변경
        self.star_label.setToolTip("클릭하여 즐겨찾기 토글")
        self.star_label.clicked.connect(self.toggle_favorite)
        
        # 페이지 아이콘 라벨
        self.page_label = QLabel(emoji)
        self.page_label.setFixedWidth(16)  # 폭 줄이기
        
        # 페이지 이름 라벨
        self.name_label = QLabel(name)
        
        # 잠금 상태 라벨
        self.lock_label = QLabel()
        self.lock_label.setFixedWidth(16)  # 폭 줄이기
        self.lock_label.setAlignment(Qt.AlignCenter)
        
        # 레이아웃에 추가
        layout.addWidget(self.star_label)
        layout.addWidget(self.page_label)
        layout.addWidget(self.name_label)
        layout.addStretch()  # 오른쪽 여백
        layout.addWidget(self.lock_label)
        
        # 초기 상태 설정
        self.set_favorite(is_favorite)
        self.set_locked(is_locked)
        
        # 이벤트 필터 설치
        self.installEventFilter(self)
    
    def mousePressEvent(self, event):
        """마우스 이벤트 처리 - Ctrl/Shift 키가 눌린 상태에서는 즐겨찾기 토글 방지"""
        if event.button() == Qt.LeftButton:
            modifiers = event.modifiers()
            
            # Ctrl이나 Shift 키가 눌린 상태에서는 즐겨찾기 토글하지 않고 선택만 처리
            if modifiers & (Qt.ControlModifier | Qt.ShiftModifier):
                # 이벤트를 부모로 전파하여 다중 선택 처리
                super().mousePressEvent(event)
                return
        
        # 일반 클릭인 경우 기본 동작
        super().mousePressEvent(event)
    
    def mouseDoubleClickEvent(self, event):
        """더블클릭으로 페이지 이름 변경"""
        if event.button() == Qt.LeftButton:
            # 부모 PromptBook 인스턴스 찾기
            parent = self.parent()
            while parent is not None:
                if isinstance(parent, PromptBook):
                    # 현재 페이지 찾기
                    for i in range(parent.char_list.count()):
                        item = parent.char_list.item(i)
                        widget = parent.char_list.itemWidget(item)
                        if widget == self:
                            # 이름 변경 대화상자 호출
                            parent.rename_character_dialog(item)
                            return
                    break
                parent = parent.parent()
        
        super().mouseDoubleClickEvent(event)
    
    def contextMenuEvent(self, event):
        """컨텍스트 메뉴 이벤트를 부모 리스트로 전달"""
        # 부모 리스트 위젯 찾기
        parent_list = self.parent()
        while parent_list and not isinstance(parent_list, QListWidget):
            parent_list = parent_list.parent()
        
        if parent_list and hasattr(parent_list, 'customContextMenuRequested'):
            # 리스트 위젯의 좌표계로 변환
            list_pos = parent_list.mapFromGlobal(event.globalPos())
            parent_list.customContextMenuRequested.emit(list_pos)

    def eventFilter(self, obj, event):
        """키보드 이벤트를 부모 리스트로 전달"""
        if event.type() == QEvent.KeyPress:
            # 부모 리스트 위젯 찾기
            parent_list = self.parent()
            while parent_list and not isinstance(parent_list, QListWidget):
                parent_list = parent_list.parent()
            
            if parent_list:
                # 키 이벤트를 부모 리스트로 전달
                QApplication.sendEvent(parent_list, event)
                return True
        
        return super().eventFilter(obj, event)
    
    def set_locked(self, is_locked):
        """잠금 상태 설정"""
        self.lock_label.setText("🔒" if is_locked else "")

    def toggle_favorite(self):
        """즐겨찾기 토글 - 부모 PromptBook 인스턴스 찾아서 처리"""
        # 부모 위젯 체인을 따라 PromptBook 인스턴스 찾기
        parent = self.parent()
        while parent is not None:
            if isinstance(parent, PromptBook):
                # 즐겨찾기 토글 중임을 표시하는 플래그 설정
                parent._toggling_favorite = True
                
                # 이벤트 처리를 일시적으로 차단
                parent.book_list.blockSignals(True)
                
                try:
                    # 현재 페이지에 대해 즐겨찾기 토글
                    for char in parent.state.characters:
                        if char.get("name") == self.page_name:
                            is_favorite = not char.get("favorite", False)
                            char["favorite"] = is_favorite
                            
                            # 상태 업데이트
                            if parent.current_book:
                                parent.state.books[parent.current_book]["pages"] = parent.state.characters
                            
                            # 위젯 업데이트
                            self.set_favorite(is_favorite)
                            
                            # 정렬 적용 후 선택 해제하여 페이지 내용 숨기기
                            if not parent.sort_mode_custom:
                                current_mode = parent.sort_selector.currentText() if hasattr(parent, "sort_selector") else "오름차순 정렬"
                                from promptbook_features import sort_characters
                                parent.state.characters = sort_characters(parent.state.characters, current_mode)
                                
                                # refresh_character_list 대신 직접 리스트 업데이트
                                parent.char_list.blockSignals(True)
                                parent.char_list.clear()
                                
                                # 정렬된 캐릭터로 리스트 다시 생성
                                from PySide6.QtWidgets import QListWidgetItem
                                from PySide6.QtCore import Qt
                                for i, char in enumerate(parent.state.characters):
                                    text = char.get("name", "(이름 없음)")
                                    is_favorite = char.get("favorite", False)
                                    emoji = char.get("emoji", "📄")
                                    is_locked = char.get("locked", False)
                                    
                                    # 새 아이템 생성
                                    item = QListWidgetItem()
                                    widget = PageItemWidget(text, is_favorite, emoji, is_locked)
                                    item.setData(Qt.UserRole, text)
                                    
                                    parent.char_list.addItem(item)
                                    parent.char_list.setItemWidget(item, widget)
                                    item.setSizeHint(widget.sizeHint())
                                
                                parent.char_list.blockSignals(False)
                                parent.char_list.clearSelection()  # 선택 해제
                                
                                # 페이지 선택만 해제하고 페이지 내용만 숨기기 (페이지 리스트는 유지)
                                parent.current_index = -1
                                parent.name_input.clear()
                                parent.tag_input.clear()
                                parent.desc_input.clear()
                                parent.prompt_input.clear()
                                parent.image_scene.clear()
                                parent.image_view.update_drop_hint_visibility()
                            else:
                                # 커스텀 모드에서도 선택 해제하고 페이지 내용만 숨기기
                                parent.char_list.clearSelection()
                                parent.current_index = -1
                                parent.name_input.clear()
                                parent.tag_input.clear()
                                parent.desc_input.clear()
                                parent.prompt_input.clear()
                                parent.image_scene.clear()
                                parent.image_view.update_drop_hint_visibility()
                            
                            # 버튼 상태 업데이트
                            parent.update_all_buttons_state()
                            parent.update_image_buttons_state()
                            
                            # 즐겨찾기 토글 완료 후 저장
                            if parent.current_book and parent.current_book in parent.state.books:
                                parent.state.books[parent.current_book]["pages"] = parent.state.characters
                                parent.save_to_file()
                            break
                finally:
                    # 이벤트 처리 복원
                    parent.book_list.blockSignals(False)
                    # 즐겨찾기 토글 플래그를 약간 지연시켜 해제 (이벤트 큐 처리 완료 대기)
                    from PySide6.QtCore import QTimer
                    def clear_flag():
                        parent._toggling_favorite = False
                    QTimer.singleShot(500, clear_flag)  # 500ms로 지연 시간 증가
                
                return
            parent = parent.parent()
    
    def set_favorite(self, is_favorite):
        self.star_label.setText("❤️" if is_favorite else "🖤")
    
    def set_name(self, name):
        self.name_label.setText(name)
        self.page_name = name
    
    def set_emoji(self, emoji):
        self.page_label.setText(emoji)
        
    def set_locked(self, is_locked):
        """잠금 상태 설정"""
        self.lock_label.setText("🔒" if is_locked else "")

class BookItemWidget(QWidget):
    def __init__(self, name, is_favorite=False, emoji="📕", parent=None):
        super().__init__(parent)
        self.book_name = name  # 북 이름 저장
        
        layout = QHBoxLayout(self)
        layout.setContentsMargins(4, 2, 4, 2)  # 여백 줄이기
        layout.setSpacing(2)  # 간격 대폭 줄이기
        
        # 별 표시 라벨 (클릭 가능)
        self.star_label = ClickableLabel()
        self.star_label.setFixedWidth(16)  # 폭 줄이기
        self.star_label.setAlignment(Qt.AlignCenter)
        self.star_label.setCursor(Qt.PointingHandCursor)  # 마우스 커서 변경
        self.star_label.setToolTip("클릭하여 즐겨찾기 토글")
        self.star_label.clicked.connect(self.toggle_favorite)
        
        # 북 아이콘 라벨
        self.book_label = QLabel(emoji)
        self.book_label.setFixedWidth(16)  # 폭 줄이기
        
        # 북 이름 라벨
        self.name_label = QLabel(name)
        
        # 레이아웃에 추가
        layout.addWidget(self.star_label)
        layout.addWidget(self.book_label)
        layout.addWidget(self.name_label)
        layout.addStretch()  # 오른쪽 여백
        
        # 즐겨찾기 상태 설정
        self.set_favorite(is_favorite)
        
        # 이벤트 필터 설치
        self.installEventFilter(self)
    
    def toggle_favorite(self):
        """즐겨찾기 토글 - 부모 PromptBook 인스턴스 찾아서 처리"""
        # 부모 위젯 체인을 따라 PromptBook 인스턴스 찾기
        parent = self.parent()
        while parent is not None:
            if isinstance(parent, PromptBook):
                # 이벤트 처리를 일시적으로 차단
                parent.book_list.blockSignals(True)
                
                try:
                    # 현재 북에 대해 즐겨찾기 토글
                    if self.book_name in parent.state.books:
                        is_favorite = not parent.state.books[self.book_name].get("favorite", False)
                        parent.state.books[self.book_name]["favorite"] = is_favorite
                        
                        # 위젯 업데이트
                        self.set_favorite(is_favorite)
                        
                        # 정렬 적용 후 선택 해제하여 북 내용 숨기기
                        if not parent.book_sort_custom:
                            parent.handle_book_sort()
                            # 북 선택 해제
                            parent.book_list.clearSelection()
                            parent.current_book = None
                            parent.state.characters = []
                            parent.char_list.clear()
                            parent.current_index = -1
                            parent.clear_page_list()
                        else:
                            # 커스텀 모드에서도 선택 해제
                            parent.book_list.clearSelection()
                            parent.current_book = None
                            parent.state.characters = []
                            parent.char_list.clear()
                            parent.current_index = -1
                            parent.clear_page_list()
                        
                        # 버튼 상태 업데이트
                        parent.update_all_buttons_state()
                        parent.update_image_buttons_state()
                        
                        parent.save_to_file()
                finally:
                    # 이벤트 처리 복원
                    parent.book_list.blockSignals(False)
                
                return
            parent = parent.parent()
    
    def set_favorite(self, is_favorite):
        self.star_label.setText("❤️" if is_favorite else "🖤")
    
    def set_name(self, name):
        self.name_label.setText(name)
        self.book_name = name
    
    def set_emoji(self, emoji):
        self.book_label.setText(emoji)
    
    def mouseDoubleClickEvent(self, event):
        """더블클릭으로 북 이름 변경"""
        if event.button() == Qt.LeftButton:
            # 부모 PromptBook 인스턴스 찾기
            parent = self.parent()
            while parent is not None:
                if isinstance(parent, PromptBook):
                    # 현재 북 찾기
                    for i in range(parent.book_list.count()):
                        item = parent.book_list.item(i)
                        widget = parent.book_list.itemWidget(item)
                        if widget == self:
                            # 이름 변경 대화상자 호출
                            parent.rename_book_dialog(item)
                            return
                    break
                parent = parent.parent()
        
        super().mouseDoubleClickEvent(event)
    
    def contextMenuEvent(self, event):
        """컨텍스트 메뉴 이벤트를 부모 리스트로 전달"""
        # 부모 리스트 위젯 찾기
        parent_list = self.parent()
        while parent_list and not isinstance(parent_list, QListWidget):
            parent_list = parent_list.parent()
        
        if parent_list and hasattr(parent_list, 'customContextMenuRequested'):
            # 리스트 위젯의 좌표계로 변환
            list_pos = parent_list.mapFromGlobal(event.globalPos())
            parent_list.customContextMenuRequested.emit(list_pos)

    def eventFilter(self, obj, event):
        """키보드 이벤트를 부모 리스트로 전달"""
        if event.type() == QEvent.KeyPress:
            # 부모 리스트 위젯 찾기
            parent_list = self.parent()
            while parent_list and not isinstance(parent_list, QListWidget):
                parent_list = parent_list.parent()
            
            if parent_list:
                # 키 이벤트를 부모 리스트로 전달
                QApplication.sendEvent(parent_list, event)
                return True
        
        return super().eventFilter(obj, event)

class BookList(QListWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAcceptDrops(False)  # 외부 드롭 비활성화
        
    def dragEnterEvent(self, event):
        # 내부 항목 이동인 경우만 허용
        if event.source() == self:
            event.accept()
        else:
            event.ignore()
            
    def dropEvent(self, event):
        # 내부 항목 이동인 경우만 처리
        if event.source() == self:
            super().dropEvent(event)
            # 다중 선택 이동 시 북 순서 업데이트
            self.update_book_order()
        else:
            event.ignore()
    
    def update_book_order(self):
        """북 순서 업데이트"""
        # 부모 PromptBook 인스턴스 찾기
        parent = self.parent()
        while parent is not None:
            if hasattr(parent, 'handle_book_reorder'):
                parent.handle_book_reorder()
                break
            parent = parent.parent()

class CharacterList(QListWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAcceptDrops(False)  # 외부 드롭 비활성화
        
    def dragEnterEvent(self, event):
        # 내부 항목 이동인 경우만 허용
        if event.source() == self:
            event.accept()
        else:
            event.ignore()
            
    def dropEvent(self, event):
        # 내부 항목 이동인 경우만 처리
        if event.source() == self:
            super().dropEvent(event)
            # 다중 선택 이동 시 페이지 순서 업데이트
            self.update_character_order()
        else:
            event.ignore()
    
    def update_character_order(self):
        """페이지 순서 업데이트"""
        # 부모 PromptBook 인스턴스 찾기
        parent = self.parent()
        while parent is not None:
            if hasattr(parent, 'on_character_reordered'):
                parent.on_character_reordered()
                break
            parent = parent.parent()

class CustomSplitterHandle(QSplitterHandle):
    def __init__(self, orientation, parent):
        super().__init__(orientation, parent)
    
    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
        
        # 부모 스플리터에서 현재 테마 가져오기
        main_window = self.parent()
        while main_window and not isinstance(main_window, PromptBook):
            main_window = main_window.parent()
        
        if main_window:
            current_theme = getattr(main_window, 'current_theme', '어두운 모드')
            
            # 커스텀 테마인 경우 아무것도 그리지 않음
            if current_theme == "커스텀 테마":
                return
            
            theme = main_window.THEMES.get(current_theme, main_window.THEMES['어두운 모드'])
            
            # 배경색을 메인 배경색과 통일
            bg_color = QColor(theme['background'])
            painter.fillRect(self.rect(), bg_color)
            
            rect = self.rect()
            center_x = rect.width() // 2
            center_y = rect.height() // 2
            
            if self.orientation() == Qt.Horizontal:
                # 세로 스플리터: 작은 점들로 그립 표시 (상하 중앙에)
                grip_color = QColor(theme['text_secondary'])
                if current_theme in ["블루 네온", "핑크 네온"]:
                    grip_color = QColor(theme['primary'])
                
                painter.setBrush(QBrush(grip_color))
                painter.setPen(Qt.NoPen)
                
                # 3개의 작은 원형 점들
                dot_size = 2
                spacing = 6
                
                for i in range(3):
                    y = center_y - spacing + (i * spacing)
                    painter.drawEllipse(center_x - dot_size//2, y - dot_size//2, dot_size, dot_size)
            else:
                # 가로 스플리터: 작은 점들로 그립 표시
                grip_color = QColor(theme['text_secondary'])
                if current_theme in ["블루 네온", "핑크 네온"]:
                    grip_color = QColor(theme['primary'])
                
                painter.setBrush(QBrush(grip_color))
                painter.setPen(Qt.NoPen)
                
                # 3개의 작은 원형 점들
                dot_size = 2
                spacing = 6
                
                for i in range(3):
                    x = center_x - spacing + (i * spacing)
                    painter.drawEllipse(x - dot_size//2, center_y - dot_size//2, dot_size, dot_size)

class CustomSplitter(QSplitter):
    def __init__(self, orientation, parent=None):
        super().__init__(orientation, parent)
        self.setHandleWidth(6)  # 더 작게 조정
        self.setChildrenCollapsible(False)
    
    def createHandle(self):
        return CustomSplitterHandle(self.orientation(), self)
    
    def update_handle_width(self, theme_name):
        """테마에 따라 핸들 너비 조정"""
        if theme_name == "커스텀 테마":
            self.setHandleWidth(0)  # 커스텀 테마에서는 완전히 숨김
        else:
            self.setHandleWidth(6)  # 다른 테마에서는 기본값

class ResizeHandle(QWidget):
    """투명한 윈도우 리사이즈 핸들"""
    def __init__(self, direction, parent=None):
        super().__init__(parent)
        self.direction = direction
        self.parent_window = parent
        self.dragging = False
        self.drag_start_pos = None
        self.drag_start_geo = None
        
        # 기본 설정
        self.setMouseTracking(True)
        self.setAttribute(Qt.WA_TransparentForMouseEvents, False)
        
        # 커서 설정
        self.setup_cursor()
        
        # 초기 스타일 (완전 투명)
        self.setStyleSheet("""
            QWidget {
                background-color: transparent;
                border: none;
            }
        """)
    
    def setup_cursor(self):
        """방향에 따른 커서 설정"""
        if self.direction in ['top', 'bottom']:
            self.setCursor(Qt.SizeVerCursor)
        elif self.direction in ['left', 'right']:
            self.setCursor(Qt.SizeHorCursor)
        elif self.direction in ['top-left', 'bottom-right']:
            self.setCursor(Qt.SizeFDiagCursor)
        elif self.direction in ['top-right', 'bottom-left']:
            self.setCursor(Qt.SizeBDiagCursor)
    
    def enterEvent(self, event):
        """마우스 호버 시 약간 보이게"""
        if not self.parent_window.isMaximized():
            # 현재 테마에 맞는 색상으로 호버 효과
            current_theme = getattr(self.parent_window, 'current_theme', '어두운 모드')
            theme = self.parent_window.THEMES.get(current_theme, self.parent_window.THEMES['어두운 모드'])
            
            self.setStyleSheet(f"""
                QWidget {{
                    background-color: {theme['primary']};
                    border: none;
                    opacity: 0.3;
                }}
            """)
        super().enterEvent(event)
    
    def leaveEvent(self, event):
        """마우스 벗어나면 다시 투명하게"""
        self.setStyleSheet("""
            QWidget {
                background-color: transparent;
                border: none;
            }
        """)
        super().leaveEvent(event)
    
    def mousePressEvent(self, event):
        """리사이즈 시작"""
        if event.button() == Qt.LeftButton and not self.parent_window.isMaximized():
            self.dragging = True
            self.drag_start_pos = event.globalPosition().toPoint()
            self.drag_start_geo = self.parent_window.geometry()
            event.accept()
    
    def mouseMoveEvent(self, event):
        """리사이즈 처리"""
        if self.dragging and event.buttons() == Qt.LeftButton:
            self.handle_resize(event.globalPosition().toPoint())
            event.accept()
    
    def mouseReleaseEvent(self, event):
        """리사이즈 종료"""
        self.dragging = False
        self.drag_start_pos = None
        self.drag_start_geo = None
    
    def handle_resize(self, global_pos):
        """실제 리사이즈 수행"""
        if not self.drag_start_pos or not self.drag_start_geo:
            return
            
        # 마우스 이동 거리 계산
        delta = global_pos - self.drag_start_pos
        dx, dy = delta.x(), delta.y()
        
        # 원래 지오메트리
        old_geo = self.drag_start_geo
        new_x, new_y = old_geo.x(), old_geo.y()
        new_width, new_height = old_geo.width(), old_geo.height()
        
        # 최소 크기 제한
        min_width, min_height = 400, 300
        
        # 최소 크기 체크
        proposed_width = new_width
        proposed_height = new_height
        width_at_limit = False
        height_at_limit = False
        
        # 방향에 따른 리사이즈 처리 (정상적인 윈도우 동작)
        if 'left' in self.direction:
            # 왼쪽에서 리사이즈: 왼쪽으로 드래그하면 왼쪽으로 늘어남
            proposed_width = old_geo.width() - dx
            if proposed_width >= min_width:
                new_width = proposed_width
                new_x = old_geo.x() + dx  # 왼쪽 가장자리 이동
            else:
                # 최소 크기에 도달하면 더 이상 축소하지 않음
                width_at_limit = True
        elif 'right' in self.direction:
            # 오른쪽에서 리사이즈: 오른쪽으로 드래그하면 오른쪽으로 늘어남
            proposed_width = old_geo.width() + dx
            if proposed_width >= min_width:
                new_width = proposed_width
            else:
                width_at_limit = True
            
        if 'top' in self.direction:
            # 위쪽에서 리사이즈: 위로 드래그하면 위로 늘어남
            proposed_height = old_geo.height() - dy
            if proposed_height >= min_height:
                new_height = proposed_height
                new_y = old_geo.y() + dy  # 위쪽 가장자리 이동
            else:
                # 최소 크기에 도달하면 더 이상 축소하지 않음
                height_at_limit = True
        elif 'bottom' in self.direction:
            # 아래쪽에서 리사이즈: 아래로 드래그하면 아래로 늘어남
            proposed_height = old_geo.height() + dy
            if proposed_height >= min_height:
                new_height = proposed_height
            else:
                height_at_limit = True
        
        # 최소 크기에 도달하지 않았을 때만 지오메트리 적용
        if not width_at_limit and not height_at_limit:
            self.parent_window.setGeometry(new_x, new_y, new_width, new_height)

class PromptBook(QMainWindow):
    # 클래스 레벨 상수 정의
    VERSION = "v2.3.6"
    
    @property
    def SAVE_FILE(self):
        """데이터 파일 경로를 실행 파일 위치 기준으로 반환"""
        return os.path.join(get_app_directory(), "character_data.json")
    
    @property
    def SETTINGS_FILE(self):
        """설정 파일 경로를 실행 파일 위치 기준으로 반환"""
        return os.path.join(get_app_directory(), "ui_settings.json")
    
    # 테마 정의
    THEMES = {
        "어두운 모드": {
            "background": "#2b2b2b",
            "surface": "#3c3c3c", 
            "primary": "#8a8a8a",
            "text": "#ffffff",
            "text_secondary": "#cccccc",
            "border": "#555555",
            "hover": "#4a4a4a",
            "selected": "#8a8a8a",
            "button": "#404040",
            "button_hover": "#525252"
        },
        "밝은 모드": {
            "background": "#ffffff",
            "surface": "#f8f9fa",
            "primary": "#007bff", 
            "text": "#212529",
            "text_secondary": "#6c757d",
            "border": "#666666",
            "hover": "#aaaaaa",
            "selected": "#007bff",
            "button": "#f8f9fa",
            "button_hover": "#aaaaaa"
        },
        "파란 바다": {
            "background": "#1a2332",
            "surface": "#233447",
            "primary": "#4fa8da",
            "text": "#e8f4fd",
            "text_secondary": "#b8d4ea",
            "border": "#4a6b8a",
            "hover": "#2d4a61",
            "selected": "#4fa8da",
            "button": "#2a3f56",
            "button_hover": "#355070"
        },
        "숲속": {
            "background": "#1a2e1a",
            "surface": "#254725",
            "primary": "#4caf50",
            "text": "#e8f5e8",
            "text_secondary": "#b8e6b8",
            "border": "#4a7c4a",
            "hover": "#2d5a2d",
            "selected": "#4caf50",
            "button": "#2a4a2a",
            "button_hover": "#356535"
        },
        "보라 우주": {
            "background": "#2a1a2e",
            "surface": "#3d2547", 
            "primary": "#9c27b0",
            "text": "#f3e8f5",
            "text_secondary": "#d1b8d6",
            "border": "#7a4a7c",
            "hover": "#512d5a",
            "selected": "#9c27b0",
            "button": "#4a2a4a",
            "button_hover": "#653565"
        },
        "황혼": {
            "background": "#2e221a",
            "surface": "#473525",
            "primary": "#ff9800",
            "text": "#fff2e8",
            "text_secondary": "#e6c8b8",
            "border": "#7c5a4a",
            "hover": "#5a3d2d",
            "selected": "#ff9800", 
            "button": "#4a3a2a",
            "button_hover": "#654535"
        },
        "벚꽃": {
            "background": "#2e1a26",
            "surface": "#472535",
            "primary": "#e91e63",
            "text": "#fde8f0",
            "text_secondary": "#e6b8ca",
            "border": "#7c4a5f",
            "hover": "#5a2d41",
            "selected": "#e91e63",
            "button": "#4a2a38",
            "button_hover": "#65354a"
        },
        "민트": {
            "background": "#1a4d40",
            "surface": "#2d6659",
            "primary": "#66ffcc",
            "text": "#f0fff0",
            "text_secondary": "#99ffdd",
            "border": "#80ffcc",
            "hover": "#40a085",
            "selected": "#66ffcc",
            "button": "#40a085",
            "button_hover": "#66ffcc"
        },
        "블루 네온": {
            "background": "#0a0a0a",
            "surface": "#1a1a1a",
            "primary": "#00ffff",
            "text": "#ffffff",
            "text_secondary": "#80ffff",
            "border": "#00cccc",
            "hover": "#2a2a2a",
            "selected": "#00ffff",
            "button": "#1a1a1a",
            "button_hover": "#2a2a2a"
        },
        "핑크 네온": {
            "background": "#0a0a0a",
            "surface": "#1a1a1a",
            "primary": "#ff00ff",
            "text": "#ffffff",
            "text_secondary": "#ff80ff",
            "border": "#cc00cc",
            "hover": "#2a2a2a",
            "selected": "#ff00ff",
            "button": "#1a1a1a",
            "button_hover": "#2a2a2a"
        },
        "커스텀 테마": {
            "background": "#2b2b2b",
            "surface": "#3c3c3c", 
            "primary": "#8a8a8a",
            "text": "#ffffff",
            "text_secondary": "#cccccc",
            "border": "#555555",
            "hover": "#4a4a4a",
            "selected": "#8a8a8a",
            "button": "#404040",
            "button_hover": "#525252"
        }
    }
    
    emoji_options = [
        "📕", "📘", "📙", "📗", "📓", "📔", "📒", "📚", "📖", "📝",
        "🌟", "✨", "🔥", "🎯", "🚀", "🧩", "🎨", "💡", "❤️", "💀",
        "👑", "🎵", "🐉", "🦄", "🐱", "👻", "🍀", "🪐", "😀", "😎",
        "🥳", "😈", "🤖", "👽", "👾", "🙈", "😺", "🫠", "👧", "👩",
        "🧒", "👸", "💃", "🧝‍♀️", "🧚‍♀️", "🧞‍♀️", "👩‍🎤", "👩‍🔬"
    ]
    
    # 페이지용 이모지 옵션 (북 관련 이모지 제외)
    page_emoji_options = [
        "📄", "📃", "🗒️", "📑", "🧾", "📰", "🗞️", "📋", "📌", "📎",
        "🌟", "✨", "🔥", "🎯", "🚀", "🧩", "🎨", "💡", "❤️", "💀",
        "👑", "🎵", "🐉", "🦄", "🐱", "👻", "🍀", "🪐", "😀", "😎",
        "🥳", "😈", "🤖", "👽", "👾", "🙈", "😺", "🫠", "👧", "👩",
        "🧒", "👸", "💃", "🧝‍♀️", "🧚‍♀️", "🧞‍♀️", "👩‍🎤", "👩‍🔬"
    ]

    def __init__(self):
        # 부모 클래스 초기화
        super().__init__()
        
        # 모든 에러 대화상자 차단
        self.disable_all_error_dialogs()
        
        # 상태 및 핸들러 초기화
        self.state = PromptBookState()
        self.handlers = PromptBookEventHandlers()
        
        # 상태 변수 초기화
        self.current_book = None
        self.current_index = -1
        self.block_save = False
        self.edited = False
        self._initial_loading = True
        self.sort_mode_custom = False
        self.book_sort_custom = False  # 북 정렬 모드 추가

        # 창 고정 상태 변수 추가
        self.always_on_top = False
        
        # 시스템 트레이 상주 상태 변수
        self.stay_in_tray = False
        
        # UI 좌우반전 상태 변수
        self.ui_flipped = False
        self.original_splitter_sizes = None  # 원래 스플리터 크기 저장

        # UI 관련 변수 초기화
        self.book_list = None
        self.char_list = None
        self.name_input = None
        self.tag_input = None
        self.desc_input = None
        self.prompt_input = None
        self.image_view = None
        self.image_scene = None
        self.left_layout = None
        self.middle_layout = None
        self.right_layout = None
        self.sort_selector = None
        self.book_sort_selector = None
        
        # 기본 윈도우 설정
        self.setWindowTitle(f"프롬프트 북 {self.VERSION}")
        self.setMinimumSize(1000, 600)  # 최소 크기 설정
        self.resize(1000, 600)  # 기본 크기 설정
        self.setAcceptDrops(True)
        
        # 앱 아이콘 설정 (PyInstaller 리소스 포함)
        try:
            if getattr(sys, 'frozen', False):
                # PyInstaller로 빌드된 exe에서는 임시 폴더의 아이콘 사용
                icon_path = os.path.join(sys._MEIPASS, "icon.ico")
                if os.path.exists(icon_path):
                    self.setWindowIcon(QIcon(icon_path))
                else:
                    print("[DEBUG] 내장된 아이콘 파일을 찾을 수 없습니다.")
            else:
                # 개발 환경에서는 로컬 아이콘 파일 사용
                if os.path.exists("icon.ico"):
                    self.setWindowIcon(QIcon("icon.ico"))
                elif os.path.exists("icon.png"):
                    self.setWindowIcon(QIcon("icon.png"))
                else:
                    print("[DEBUG] 개발 환경: 아이콘 파일을 찾을 수 없습니다.")
        except Exception as e:
            print(f"[DEBUG] 아이콘 설정 실패: {e}")
        
        # 프레임리스 윈도우로 설정 (커스텀 타이틀 바를 위해)
        self.setWindowFlags(Qt.FramelessWindowHint)
        
        # 마우스 트래킹 활성화 (마우스 버튼을 누르지 않아도 이벤트 받기)
        self.setMouseTracking(True)
        
        # 드래그 관련 변수
        self.drag_position = None
        
        # 둥근 모서리를 위한 변수
        self.border_radius = 12
        
        # 리사이즈 핸들들
        self.resize_handles = {}
        
        # 클립보드 관련 변수
        self.clipboard_pages = []  # 복사/잘라내기된 페이지들
        self.clipboard_operation = None  # 'copy' 또는 'cut'
        self.clipboard_source_book = None  # 소스 북 이름
        
        # 저장된 설정 먼저 로드 (테마 정보 포함)
        self.load_ui_settings_early()
        
        # 테마 관련 초기화 (apply_theme 호출 전에 필요)
        self.theme_group = QActionGroup(self)
        
        # UI 구성
        self.setup_ui()
        
        # UI 구성 후 나머지 설정 적용
        if os.path.exists(self.SETTINGS_FILE):
            self.load_ui_settings_late()
            
        # 데이터 로드
        self.load_from_file()
        
        # 저장된 테마 적용 또는 기본 테마 적용
        self.apply_theme(getattr(self, 'current_theme', '어두운 모드'))
            
        # 단축키 설정
        self.setup_shortcuts()
        
        # 리사이즈 핸들 설정
        self.setup_resize_handles()
        
        # 시스템 트레이 설정
        self.setup_system_tray()

    def setup_ui(self):
        self.setWindowTitle("프롬프트 북")
        self.setMinimumSize(1000, 600)
        # self.setup_menubar()  # 메뉴바는 커스텀 타이틀바에 통합
        self.setup_theme_actions()  # 테마 액션들 설정
        self.setup_central_widget()
        self.setup_book_list()
        self.setup_character_list()
        self.setup_input_fields()
        self.setup_image_view()
        self.setup_buttons()
        self.update_all_buttons_state()

    def setup_menubar(self):
        menubar = self.menuBar()
        
        # 파일 메뉴
        file_menu = menubar.addMenu("파일")
        
        # 선택된 북 저장하기
        save_book_action = QAction("선택된 북 저장하기", self)
        save_book_action.triggered.connect(self.save_selected_book)
        file_menu.addAction(save_book_action)
        
        # 저장된 북 불러오기
        load_book_action = QAction("저장된 북 불러오기", self)
        load_book_action.triggered.connect(self.load_saved_book)
        file_menu.addAction(load_book_action)
        
        # 구분선 추가
        file_menu.addSeparator()
        
        # 백업 서브메뉴
        backup_menu = file_menu.addMenu("💾 백업")
        
        # 현재 북 리스트 백업
        backup_action = QAction("📦 현재 북 리스트 백업", self)
        backup_action.triggered.connect(self.backup_book_list)
        backup_menu.addAction(backup_action)
        
        # 백업된 북 리스트로 복구
        restore_action = QAction("📥 백업된 북 리스트로 복구", self)
        restore_action.triggered.connect(self.restore_book_list)
        backup_menu.addAction(restore_action)
        
        # 테마 메뉴
        theme_menu = menubar.addMenu("테마")
        
        # 테마 액션 그룹 (라디오 버튼처럼 동작)
        self.theme_group = QActionGroup(self)
        
        for theme_name in self.THEMES.keys():
            theme_action = QAction(theme_name, self)
            theme_action.setCheckable(True)
            theme_action.triggered.connect(lambda checked, name=theme_name: self.apply_theme(name))
            self.theme_group.addAction(theme_action)
            theme_menu.addAction(theme_action)
            
            # 기본 테마 설정
            if theme_name == "어두운 모드":
                theme_action.setChecked(True)
        
        # 현재 테마 저장용 변수
        self.current_theme = "어두운 모드"
        
        # 커스텀 배경 이미지 경로
        self.custom_background_image = None
        
        # 커스텀 테마 투명도 설정 (기본값: 중간 투명도)
        self.custom_transparency_level = 0.5  # 0.0 (완전 투명) ~ 1.0 (완전 불투명)
        
        # 도구 메뉴 추가
        tools_menu = menubar.addMenu("🔧 도구")
        
        # 이미지 정리 메뉴 항목 추가
        cleanup_action = tools_menu.addAction("🗑️ 사용하지 않는 이미지 정리")
        cleanup_action.triggered.connect(self.cleanup_unused_images)
        cleanup_action.setToolTip("현재 페이지들에서 사용되지 않는 이미지를 휴지통으로 이동합니다")
        
        # 정보 메뉴
        info_menu = menubar.addMenu("정보")

    def setup_central_widget(self):
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        layout = QVBoxLayout(central_widget)
        layout.setContentsMargins(0, 0, 0, 0)  # 여백 제거
        
        # 커스텀 타이틀 바 추가
        self.setup_custom_title_bar(layout)
        
        # 메인 스플리터 생성 (커스텀 스플리터 사용)
        self.main_splitter = CustomSplitter(Qt.Horizontal)  # 커스텀 스플리터 사용
        layout.addWidget(self.main_splitter)

        # Left panel
        left_widget = QWidget()
        self.left_layout = QVBoxLayout(left_widget)
        self.main_splitter.addWidget(left_widget)
        
        # Middle panel
        middle_widget = QWidget()
        self.middle_layout = QVBoxLayout(middle_widget)
        self.main_splitter.addWidget(middle_widget)
        
        # Right panel
        right_widget = QWidget()
        self.right_layout = QVBoxLayout(right_widget)
        self.main_splitter.addWidget(right_widget)

    def setup_book_list(self):
        # 북 검색 입력란 추가
        self.book_search_input = QLineEdit()
        self.book_search_input.setPlaceholderText("북 이름으로 검색...")
        self.book_search_input.textChanged.connect(self.filter_books)
        
        self.book_list = BookList()  # BookList 사용
        self.book_list.setSelectionMode(QAbstractItemView.ExtendedSelection)  # 다중 선택 모드 활성화
        self.book_list.setFocusPolicy(Qt.StrongFocus)
        # 델리게이트 제거 - 커스텀 위젯 사용할 예정
        self.book_list.installEventFilter(self)
        self.book_list.itemClicked.connect(lambda item: self.on_book_selected(self.book_list.row(item)))
        self.book_list.itemSelectionChanged.connect(self.on_book_selection_changed)  # 다중 선택 변경 감지
        self.book_list.setContextMenuPolicy(Qt.CustomContextMenu)
        self.book_list.customContextMenuRequested.connect(self.show_book_context_menu)
        
        # 북 정렬 선택기 추가
        self.book_sort_selector = QComboBox()
        self.book_sort_selector.addItems(["오름차순 정렬", "내림차순 정렬", "커스텀 정렬"])
        self.book_sort_selector.currentIndexChanged.connect(self.handle_book_sort)
        
        self.left_layout.addWidget(QLabel("북 리스트"))
        self.left_layout.addWidget(self.book_search_input)
        self.left_layout.addWidget(self.book_sort_selector)
        self.left_layout.addWidget(self.book_list)
        
        self.book_add_button = QPushButton("➕ 북 추가")
        self.book_add_button.clicked.connect(self.add_book)
        self.left_layout.addWidget(self.book_add_button)

    def setup_character_list(self):
        # 페이지 검색 입력란 추가
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("이름 또는 태그로 검색...")
        self.search_input.textChanged.connect(self.filter_characters)
        
        self.char_list = CharacterList()  # QListWidget 대신 CharacterList 사용
        # 기본적으로 드래그 앤 드롭 비활성화
        self.char_list.setDragDropMode(QAbstractItemView.NoDragDrop)
        self.char_list.setSelectionMode(QAbstractItemView.ExtendedSelection)  # 다중 선택 모드 활성화
        self.char_list.itemClicked.connect(self.on_character_clicked)
        self.char_list.itemSelectionChanged.connect(self.on_character_selection_changed)  # 다중 선택 변경 감지
        self.char_list.model().rowsMoved.connect(self.on_character_reordered)
        self.char_list.installEventFilter(self)
        self.char_list.setContextMenuPolicy(Qt.CustomContextMenu)
        self.char_list.customContextMenuRequested.connect(self.show_character_context_menu)
        
        # 페이지 정렬 선택기 추가
        self.sort_selector = QComboBox()
        self.sort_selector.addItems(["오름차순 정렬", "내림차순 정렬", "커스텀 정렬"])
        self.sort_selector.currentIndexChanged.connect(self.handle_character_sort)
        
        # 정렬 콤보박스에 강제 스타일 적용 (밝은 모드 호버 효과 확실히 적용)
        sort_combo_style = """
            QComboBox {
                background-color: #f8f9fa;
                border: 1px solid #666666;
                color: #212529;
                padding: 4px 8px;
                border-radius: 3px;
            }
            QComboBox:hover {
                background-color: #aaaaaa !important;
                border: 1px solid #007bff !important;
            }
            QComboBox::drop-down {
                border: none;
                background-color: transparent;
            }
            QComboBox::drop-down:hover {
                background-color: #aaaaaa !important;
            }
            QComboBox QAbstractItemView {
                background-color: #f8f9fa;
                border: 1px solid #666666;
                selection-background-color: #aaaaaa;
                color: #212529;
                outline: none;
            }
            QComboBox QAbstractItemView::item {
                padding: 4px 8px;
                border: none;
                background-color: #f8f9fa;
                color: #212529;
            }
            QComboBox QAbstractItemView::item:hover {
                background-color: #aaaaaa !important;
                color: #212529 !important;
            }
            QComboBox QAbstractItemView::item:selected {
                background-color: #aaaaaa !important;
                color: #212529 !important;
            }
            QComboBox QAbstractItemView::item:selected:hover {
                background-color: #aaaaaa !important;
                color: #212529 !important;
            }
        """
        self.sort_selector.setStyleSheet(sort_combo_style)
        
        self.left_layout.addWidget(QLabel("페이지 리스트"))
        self.left_layout.addWidget(self.search_input)
        self.left_layout.addWidget(self.sort_selector)
        self.left_layout.addWidget(self.char_list)
        
        # 페이지 추가 버튼
        self.add_button = QPushButton("➕ 페이지 추가")
        self.add_button.clicked.connect(self.add_character)
        self.add_button.setEnabled(False)
        self.left_layout.addWidget(self.add_button)



    def setup_input_fields(self):
        self.name_input = QLineEdit()
        self.tag_input = QLineEdit()
        self.desc_input = QTextEdit()
        self.desc_input.setAcceptDrops(False)  # 설명 입력칸 드래그 앤 드롭 비활성화
        
        # 프롬프트 입력란에 자동완성 기능 추가
        self.prompt_input = CustomLineEdit()
        self.prompt_input.setAcceptDrops(False)  # 드래그 앤 드롭 비활성화
        try:
            autocomplete_path = os.path.join(get_app_directory(), "autocomplete.txt")
            with open(autocomplete_path, 'r', encoding='utf-8') as f:
                prompts = [line.strip() for line in f if line.strip()]
            completer = QCompleter(prompts)
            self.prompt_input.set_custom_completer(completer)
        except Exception as e:
            print(f"자동완성 목록 로드 실패: {e}")
            # 기본 자동완성 목록 사용
            default_prompts = ["masterpiece", "best quality", "ultra-detailed", "8k uhd", "highres"]
            completer = QCompleter(default_prompts)
            self.prompt_input.set_custom_completer(completer)
        
        # 페이지 잠금 체크박스
        self.lock_checkbox = QCheckBox("🔓 페이지 잠금")
        self.lock_checkbox.setToolTip("잠금된 페이지는 삭제할 수 없습니다")
        self.lock_checkbox.setEnabled(False)
        self.lock_checkbox.stateChanged.connect(self.on_lock_changed)
        
        self.middle_layout.addWidget(QLabel("이름"))
        
        # 이름 입력란과 잠금 체크박스를 한 줄에 배치
        name_layout = QHBoxLayout()
        name_layout.addWidget(self.name_input)
        name_layout.addWidget(self.lock_checkbox)
        self.middle_layout.addLayout(name_layout)
        
        self.middle_layout.addWidget(QLabel("태그"))
        self.middle_layout.addWidget(self.tag_input)
        self.middle_layout.addWidget(QLabel("설명"))
        self.middle_layout.addWidget(self.desc_input)
        self.middle_layout.addWidget(QLabel("프롬프트"))
        self.middle_layout.addWidget(self.prompt_input)

    def setup_image_view(self):
        self.image_view = ImageView(self)
        self.image_scene = QGraphicsScene()
        self.image_view.setScene(self.image_scene)
        self.image_view.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.image_view.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.image_view.setRenderHint(QPainter.SmoothPixmapTransform)
        
        self.right_layout.addWidget(self.image_view)

    def setup_buttons(self):
        # 페이지 관리 버튼들
        button_layout = QHBoxLayout()
        
        self.save_button = QPushButton("💾 저장")
        self.save_button.clicked.connect(lambda: (self.save_current_character(), QToolTip.showText(self.save_button.mapToGlobal(self.save_button.rect().center()), "페이지가 저장되었습니다.")))
        self.save_button.setEnabled(False)
        
        self.copy_button = QPushButton("📋 프롬프트 복사")
        self.copy_button.clicked.connect(self.copy_prompt_to_clipboard)
        self.copy_button.setEnabled(False)
        
        self.duplicate_button = QPushButton("📄 복제")
        self.duplicate_button.clicked.connect(self.duplicate_selected_character_with_tooltip)
        self.duplicate_button.setEnabled(False)
        
        self.delete_button = QPushButton("🗑️ 삭제")
        self.delete_button.clicked.connect(self.delete_selected_character_with_tooltip)
        self.delete_button.setEnabled(False)
        
        button_layout.addWidget(self.save_button)
        button_layout.addWidget(self.copy_button)
        button_layout.addWidget(self.duplicate_button)
        button_layout.addWidget(self.delete_button)
        
        self.middle_layout.addLayout(button_layout)
        
        # 이미지 관리 버튼들
        image_button_layout = QHBoxLayout()
        
        self.image_load_btn = QPushButton("🖼️ 이미지 불러오기")
        self.image_load_btn.clicked.connect(self.load_preview_image)
        self.image_load_btn.setEnabled(False)
        
        self.image_remove_btn = QPushButton("🗑️ 이미지 제거")
        self.image_remove_btn.clicked.connect(self.remove_preview_image)
        self.image_remove_btn.setEnabled(False)
        
        # EXIF 정보 보기 체크박스
        self.exif_checkbox = QCheckBox("🔍 프롬프트 보기")
        self.exif_checkbox.setToolTip("AI 생성 이미지의 프롬프트 정보를 오버레이로 표시합니다")
        self.exif_checkbox.setEnabled(False)
        self.exif_checkbox.stateChanged.connect(self.on_exif_checkbox_changed)
        self._exif_programmatic_change = False  # 프로그래밍적 변경 플래그
        
        image_button_layout.addWidget(self.image_load_btn)
        image_button_layout.addWidget(self.image_remove_btn)
        image_button_layout.addWidget(self.exif_checkbox)
        
        self.right_layout.addLayout(image_button_layout)

    def update_image_view(self, path):
        if not os.path.exists(path):
            self.image_scene.clear()
            self.image_view.update_drop_hint_visibility()
            return

        # 이미지 리더 설정
        reader = QImageReader(path)
        reader.setAutoTransform(True)  # EXIF 정보 기반 자동 회전
        reader.setDecideFormatFromContent(True)  # 파일 내용 기반으로 포맷 결정
        reader.setQuality(100)  # 최고 품질 설정
        
        # 이미지 로드 전 크기 확인
        original_size = reader.size()
        if not original_size.isValid():
            self.image_scene.clear()
            self.image_view.update_drop_hint_visibility()
            return

        # 고품질 이미지 로딩
        image = reader.read()
        if image.isNull():
            self.image_scene.clear()
            self.image_view.update_drop_hint_visibility()
            return

        # 이미지 품질 향상을 위한 변환 설정
        pixmap = QPixmap.fromImage(image, Qt.PreferDither | Qt.AutoColor)
        
        # 씬 초기화 및 이미지 추가
        self.image_scene.clear()
        pixmap_item = QGraphicsPixmapItem()
        pixmap_item.setPixmap(pixmap)
        pixmap_item.setTransformationMode(Qt.SmoothTransformation)  # 부드러운 변환 모드 설정
        pixmap_item.setShapeMode(QGraphicsPixmapItem.BoundingRectShape)  # 성능 최적화
        self.image_scene.addItem(pixmap_item)
        
        # 이미지 상태에 따라 힌트 가시성 업데이트
        self.image_view.update_drop_hint_visibility()
        
        # 이미지 크기 및 위치 조정
        self.update_image_fit()

    def update_image_fit(self):
        if not self.image_scene.items():
            return
            
        # 현재 이미지 아이템 가져오기
        image_item = None
        for item in self.image_scene.items():
            if isinstance(item, QGraphicsPixmapItem):
                image_item = item
                break
                
        if not image_item:
            return
            
        # 뷰포트 크기 가져오기
        viewport_rect = self.image_view.viewport().rect()
        viewport_width = viewport_rect.width()
        viewport_height = viewport_rect.height()
        
        # 최소 크기 확인 (너무 작으면 처리하지 않음)
        if viewport_width < 10 or viewport_height < 10:
            return
        
        # 이미지 크기 가져오기
        pixmap = image_item.pixmap()
        image_width = pixmap.width()
        image_height = pixmap.height()
        
        # 이미지와 뷰포트의 비율 계산 (비율 유지하면서 최대한 크게)
        scale_width = viewport_width / image_width
        scale_height = viewport_height / image_height
        scale = min(scale_width, scale_height)
        
        # 최소 스케일 제한 (너무 작아지지 않도록)
        scale = max(scale, 0.1)
        
        # 변환 매트릭스 초기화
        self.image_view.resetTransform()
        
        # 씬 크기를 이미지 크기로 설정
        self.image_scene.setSceneRect(0, 0, image_width, image_height)
        
        # 이미지를 뷰에 맞게 조정 (Qt의 내장 메서드 사용)
        self.image_view.fitInView(self.image_scene.sceneRect(), Qt.KeepAspectRatio)
        
        # 중앙 정렬 확인
        self.image_view.centerOn(image_item)

    def copy_prompt_to_clipboard(self):
        QApplication.clipboard().setText(self.prompt_input.toPlainText())
        QToolTip.showText(self.copy_button.mapToGlobal(self.copy_button.rect().center()), "프롬프트가 복사되었습니다.")

    def toggle_favorite_star(self, item):
        """페이지 즐겨찾기 토글 - 사용하지 않음 (PageItemWidget.toggle_favorite 사용)"""
        # 이 메서드는 더 이상 사용하지 않습니다.
        # PageItemWidget.toggle_favorite()에서 모든 처리를 담당합니다.
        pass

    def on_character_reordered(self):
        print("[DEBUG] on_character_reordered 호출됨")
        self.sort_mode_custom = True
        new_order = []
        for i in range(self.char_list.count()):
            name = self.char_list.item(i).data(Qt.UserRole)
            for char in self.state.characters:
                if char.get("name") == name:
                    new_order.append(char)
                    break
        self.state.characters = new_order
        if self.current_book and self.current_book in self.state.books:
                self.state.books[self.current_book]["pages"] = self.state.characters
        print("[DEBUG] 새로운 순서로 저장됨")
        self.save_to_file()

    def filter_characters(self):
        query = self.search_input.text().strip().lower()
        
        # 검색어가 비어있으면 전체 리스트 갱신 (선택 없이)
        if not query:
            self.refresh_character_list(selected_name=None)  # 명시적으로 None 전달
            # 선택 상태 완전히 초기화
            self.current_index = -1
            self.char_list.clearSelection()
            if hasattr(self, 'name_input'):
                self.name_input.clear()
            if hasattr(self, 'tag_input'):
                self.tag_input.clear()
            if hasattr(self, 'desc_input'):
                self.desc_input.clear()
            if hasattr(self, 'prompt_input'):
                self.prompt_input.clear()
            if hasattr(self, 'lock_checkbox'):
                self.lock_checkbox.setChecked(False)
                self.lock_checkbox.setText("🔓 페이지 잠금")
                self.lock_checkbox.setEnabled(False)
            self.image_scene.clear()
            self.image_view.update_drop_hint_visibility()
            self.update_all_buttons_state()
            self.update_image_buttons_state()
            return
            
        self.char_list.blockSignals(True)
        self.char_list.clear()
        
        # 검색 시 현재 선택 상태 초기화
        self.current_index = -1
        if hasattr(self, 'name_input'):
            self.name_input.clear()
        if hasattr(self, 'tag_input'):
            self.tag_input.clear()
        if hasattr(self, 'desc_input'):
            self.desc_input.clear()
        if hasattr(self, 'prompt_input'):
            self.prompt_input.clear()
        if hasattr(self, 'lock_checkbox'):
            self.lock_checkbox.setChecked(False)
            self.lock_checkbox.setText("🔓 페이지 잠금")
            self.lock_checkbox.setEnabled(False)
        self.image_scene.clear()
        self.image_view.update_drop_hint_visibility()
        
        for i, char in enumerate(self.state.characters):
            name = char.get("name", "").lower()
            tags = char.get("tags", "").lower()
            if query in name or query in tags:
                item = QListWidgetItem()
                text = char.get("name", "(이름 없음)")
                is_favorite = char.get("favorite", False)
                emoji = char.get("emoji", "📄")
                is_locked = char.get("locked", False)  # 잠금 상태 가져오기
                
                # 커스텀 위젯 생성
                widget = PageItemWidget(text, is_favorite, emoji, is_locked)  # is_locked 전달
                item.setData(Qt.UserRole, text)
                
                self.char_list.addItem(item)
                self.char_list.setItemWidget(item, widget)
                item.setSizeHint(widget.sizeHint())
                
        self.char_list.blockSignals(False)
        
        # 버튼 상태 업데이트
        self.update_all_buttons_state()
        self.update_image_buttons_state()

    def filter_books(self):
        """북 검색 필터링"""
        query = self.book_search_input.text().strip().lower() if hasattr(self, "book_search_input") else ""
        
        # 검색 시 현재 북과 페이지 상태 초기화
        self.current_book = None
        self.state.characters = []
        self.char_list.clear()
        self.current_index = -1
        
        # 입력 필드 비우기
        if hasattr(self, 'name_input'):
            self.name_input.clear()
        if hasattr(self, 'tag_input'):
            self.tag_input.clear()
        if hasattr(self, 'desc_input'):
            self.desc_input.clear()
        if hasattr(self, 'prompt_input'):
            self.prompt_input.clear()
        if hasattr(self, 'lock_checkbox'):
            self.lock_checkbox.setChecked(False)
            self.lock_checkbox.setText("🔓 페이지 잠금")
            self.lock_checkbox.setEnabled(False)
        self.image_scene.clear()
        self.image_view.update_drop_hint_visibility()
        
        # 북 리스트 갱신
        self.refresh_book_list()
        
        # 버튼 상태 업데이트
        self.update_all_buttons_state()
        self.update_image_buttons_state()

    def refresh_book_list(self, selected_name=None):
        """북 리스트 갱신"""
        # 검색어가 있으면 필터링, 없으면 전체 표시
        query = self.book_search_input.text().strip().lower() if hasattr(self, "book_search_input") else ""
        
        self.book_list.blockSignals(True)
        self.book_list.clear()
        
        for name, data in self.state.books.items():
            if isinstance(data, dict):  # 딕셔너리 형식 확인
                book_name_lower = name.lower()
                if not query or query in book_name_lower:
                    emoji = data.get("emoji", "📕")
                    is_favorite = data.get("favorite", False)
                    item = QListWidgetItem()
                    
                    # 커스텀 위젯 생성
                    widget = BookItemWidget(name, is_favorite, emoji)
                    item.setData(Qt.UserRole, name)
                    
                    self.book_list.addItem(item)
                    self.book_list.setItemWidget(item, widget)
                    item.setSizeHint(widget.sizeHint())
        
        # 선택 상태 복원
        book_found = False
        if selected_name:
            for i in range(self.book_list.count()):
                item = self.book_list.item(i)
                if item.data(Qt.UserRole) == selected_name:
                    self.book_list.setCurrentItem(item)
                    book_found = True
                    break
        
        # 선택된 북이 검색 결과에 없으면 선택 해제
        if not book_found:
            self.book_list.clearSelection()
            # 검색으로 인해 현재 북이 보이지 않으면 페이지 리스트도 비우기
            if self.current_book and selected_name and self.current_book == selected_name:
                self.current_book = None
                self.state.characters = []
                self.char_list.clear()
                self.current_index = -1
                
                # 입력 필드 비우기
                if hasattr(self, 'name_input'):
                    self.name_input.clear()
                if hasattr(self, 'tag_input'):
                    self.tag_input.clear()
                if hasattr(self, 'desc_input'):
                    self.desc_input.clear()
                if hasattr(self, 'prompt_input'):
                    self.prompt_input.clear()
                if hasattr(self, 'lock_checkbox'):
                    self.lock_checkbox.setChecked(False)
                    self.lock_checkbox.setText("🔓 페이지 잠금")
                    self.lock_checkbox.setEnabled(False)
                self.image_scene.clear()
                self.image_view.update_drop_hint_visibility()
        
        self.book_list.blockSignals(False)

    def save_current_character(self):
        if self.current_book and 0 <= self.current_index < len(self.state.characters):
            data = self.state.characters[self.current_index]
            data["name"] = self.name_input.text()
            data["tags"] = self.tag_input.text()
            data["desc"] = self.desc_input.toPlainText()
            data["prompt"] = self.prompt_input.toPlainText()
            if self.current_book and self.current_book in self.state.books:
                    self.state.books[self.current_book]["pages"] = self.state.characters
            
            # 현재 아이템의 위젯 업데이트
            item = self.char_list.item(self.current_index)
            if item:
                widget = self.char_list.itemWidget(item)
                if isinstance(widget, PageItemWidget):
                    widget.set_name(data["name"])
                    widget.set_favorite(data.get("favorite", False))
                    widget.set_emoji(data.get("emoji", "📄"))
            
            self.save_to_file()

    def on_character_selected(self, index):
        print(f"[DEBUG] on_character_selected: index={index}")
        self.update_all_buttons_state()  # 입력창 상태 갱신
        
        if 0 <= index < self.char_list.count():
            item = self.char_list.item(index)
            if not item:
                return
                
            name = item.data(Qt.UserRole)
            print(f"[DEBUG] 선택된 페이지 이름: {name}")
            
            # characters 리스트에서 해당 페이지 찾기
            for i, char in enumerate(self.state.characters):
                if char.get("name") == name:
                    print(f"[DEBUG] 페이지 데이터 찾음: {char}")
                    self.current_index = i
                    
                    # 입력 필드 업데이트
                    self.name_input.setText(char.get("name", ""))
                    self.tag_input.setText(char.get("tags", ""))
                    self.desc_input.setPlainText(char.get("desc", ""))
                    self.prompt_input.setPlainText(char.get("prompt", ""))
                    
                    # 잠금 상태 표시
                    is_locked = char.get('locked', False)
                    self.lock_checkbox.setChecked(is_locked)
                    self.lock_checkbox.setEnabled(True)
                    
                    # 체크박스 텍스트 업데이트
                    if is_locked:
                        self.lock_checkbox.setText("🔒 페이지 잠금")
                    else:
                        self.lock_checkbox.setText("🔓 페이지 잠금")
                    
                    # 이미지 업데이트
                    if "image_path" in char and os.path.exists(char["image_path"]):
                        self.update_image_view(char["image_path"])
                    else:
                        self.image_scene.clear()
                        self.image_view.update_drop_hint_visibility()
                    break
        else:
            print("[DEBUG] 페이지 선택 해제")
            self.current_index = -1
            self.name_input.clear()
            self.tag_input.clear()
            self.desc_input.clear()
            self.prompt_input.clear()
            self.lock_checkbox.setChecked(False)
            self.lock_checkbox.setText("🔓 페이지 잠금")
            self.lock_checkbox.setEnabled(False)
            self.image_scene.clear()
            self.image_view.update_drop_hint_visibility()
            
        self.update_all_buttons_state()
        self.update_image_buttons_state()

    def on_lock_changed(self):
        """잠금 상태가 변경되었을 때 실행되는 함수"""
        if self.current_index >= 0 and self.current_index < len(self.state.characters):
            is_locked = self.lock_checkbox.isChecked()
            self.state.characters[self.current_index]['locked'] = is_locked
            
            # 체크박스 텍스트 업데이트
            if is_locked:
                self.lock_checkbox.setText("🔒 페이지 잠금")
            else:
                self.lock_checkbox.setText("🔓 페이지 잠금")
                
            # 리스트 갱신
            current_name = self.state.characters[self.current_index].get('name')
            self.refresh_character_list(selected_name=current_name)
            self.save_to_file()

    def save_ui_settings(self):
        settings = {
            "width": self.width(),
            "height": self.height(),
            "splitter_sizes": self.main_splitter.sizes() if hasattr(self, "main_splitter") else [200, 400, 372],
            "sort_mode": self.sort_selector.currentText() if hasattr(self, "sort_selector") else "오름차순 정렬",
            "sort_mode_custom": self.sort_mode_custom,
            "book_sort_mode": self.book_sort_selector.currentText() if hasattr(self, "book_sort_selector") else "오름차순 정렬",
            "book_sort_custom": getattr(self, "book_sort_custom", False),
            "current_theme": getattr(self, "current_theme", "어두운 모드"),
            "custom_background_image": getattr(self, "custom_background_image", None),
            "custom_transparency_level": getattr(self, "custom_transparency_level", 0.5),
            "custom_image_brightness": getattr(self, "custom_image_brightness", 50),
            "always_on_top": getattr(self, "always_on_top", False),
            "stay_in_tray": getattr(self, "stay_in_tray", False),
            "ui_flipped": getattr(self, "ui_flipped", False)
        }
        try:
            with open(self.SETTINGS_FILE, 'w', encoding='utf-8') as f:
                json.dump(settings, f, indent=2)
        except Exception as e:
            print(f"[ERROR] UI 설정 저장 실패: {e}")

    def load_ui_settings_early(self):
        """UI 구성 전에 로드할 설정들 (테마 등)"""
        if not os.path.exists(self.SETTINGS_FILE):
            return
            
        try:
            with open(self.SETTINGS_FILE, 'r', encoding='utf-8') as f:
                settings = json.load(f)
                
                # 테마 설정만 먼저 복원
                saved_theme = settings.get("current_theme", "어두운 모드")
                if saved_theme in self.THEMES:
                    self.current_theme = saved_theme
                    print(f"[DEBUG] 저장된 테마 로드: {saved_theme}")
                
                # 커스텀 배경 이미지 복원 및 검증
                saved_background_image = settings.get("custom_background_image", None)
                if saved_background_image and saved_theme == "커스텀 테마":
                    # 커스텀 테마인 경우 이미지 파일 존재 여부 확인
                    if os.path.exists(saved_background_image):
                        self.custom_background_image = saved_background_image
                        print(f"[DEBUG] 커스텀 배경 이미지 확인됨: {saved_background_image}")
                    else:
                        # 이미지 파일이 없으면 기본 테마로 되돌리기
                        print(f"[WARNING] 커스텀 배경 이미지 파일이 존재하지 않음: {saved_background_image}")
                        print(f"[INFO] 기본 어두운 모드로 되돌립니다.")
                        self.current_theme = "어두운 모드"
                        self.custom_background_image = None
                        # 설정 파일도 즉시 업데이트
                        self._update_settings_for_theme_fallback()
                else:
                    self.custom_background_image = saved_background_image
                
                # 커스텀 투명도 설정 복원
                self.custom_transparency_level = settings.get("custom_transparency_level", 0.5)
                
                # 커스텀 이미지 밝기 설정 복원
                self.custom_image_brightness = settings.get("custom_image_brightness", 50)
                
                # 창 고정 상태 복원
                self.always_on_top = settings.get("always_on_top", False)
                
                # 시스템 트레이 상주 상태 복원
                self.stay_in_tray = settings.get("stay_in_tray", False)
                
                # UI 좌우반전 상태 복원
                self.ui_flipped = settings.get("ui_flipped", False)
            
        except Exception as e:
            print(f"[ERROR] 초기 UI 설정 불러오기 실패: {e}")
    
    def _update_settings_for_theme_fallback(self):
        """테마 폴백 시 설정 파일 업데이트"""
        try:
            settings = {}
            if os.path.exists(self.SETTINGS_FILE):
                with open(self.SETTINGS_FILE, 'r', encoding='utf-8') as f:
                    settings = json.load(f)
            
            # 테마 관련 설정 업데이트
            settings["current_theme"] = "어두운 모드"
            settings["custom_background_image"] = None
            
            # 설정 파일 저장
            with open(self.SETTINGS_FILE, 'w', encoding='utf-8') as f:
                json.dump(settings, f, ensure_ascii=False, indent=2)
                
        except Exception as e:
            print(f"[ERROR] 테마 폴백 설정 저장 실패: {e}")
    
    def load_ui_settings_late(self):
        """UI 구성 후에 로드할 설정들 (크기, 정렬 등)"""
        try:
            with open(self.SETTINGS_FILE, 'r', encoding='utf-8') as f:
                settings = json.load(f)
                
                # 윈도우 크기 복원
                if "width" in settings and "height" in settings:
                    self.resize(settings["width"], settings["height"])
                
                # 스플리터 크기 복원
                if "splitter_sizes" in settings and hasattr(self, "main_splitter"):
                    self.main_splitter.setSizes(settings["splitter_sizes"])
                    
                # 페이지 정렬 상태 복원
                if hasattr(self, "sort_selector"):
                    sort_mode = settings.get("sort_mode", "오름차순 정렬")
                    index = self.sort_selector.findText(sort_mode)
                    if index >= 0:
                        self.sort_selector.setCurrentIndex(index)
                    self.sort_mode_custom = settings.get("sort_mode_custom", False)
                    
                # 북 정렬 상태 복원
                if hasattr(self, "book_sort_selector"):
                    book_sort_mode = settings.get("book_sort_mode", "오름차순 정렬")
                    index = self.book_sort_selector.findText(book_sort_mode)
                    if index >= 0:
                        self.book_sort_selector.setCurrentIndex(index)
                    self.book_sort_custom = settings.get("book_sort_custom", False)
                    
                    # 현재 북 정렬 모드 적용
                    if not self.book_sort_custom:
                        self.handle_book_sort()
                    
                    # 현재 북이 선택되어 있고 페이지가 있다면 정렬 적용
                    if self.current_book and self.state.characters:
                        from promptbook_features import sort_characters
                        self.state.characters = sort_characters(self.state.characters, sort_mode)
                        self.refresh_character_list()
                
                # 창 고정 상태 복원
                if hasattr(self, 'always_on_top') and self.always_on_top:
                    current_flags = self.windowFlags()
                    self.setWindowFlags(current_flags | Qt.WindowStaysOnTopHint)
                    self.show()
                
                # UI 좌우반전 상태 복원
                saved_ui_flipped = settings.get("ui_flipped", False)
                if saved_ui_flipped:
                    # 저장된 상태가 반전이면 UI를 직접 반전시킴
                    print(f"[DEBUG] UI 좌우반전 상태 복원 시작")
                    
                    # 현재 크기를 원래 크기로 저장
                    if hasattr(self, "main_splitter"):
                        current_sizes = self.main_splitter.sizes()
                        self.original_splitter_sizes = current_sizes.copy()
                        print(f"[DEBUG] UI 복원: 원래 크기 설정 {self.original_splitter_sizes}")
                        
                        # 위젯들을 직접 재배치 (반전 상태로)
                        left_widget = self.main_splitter.widget(0)
                        middle_widget = self.main_splitter.widget(1)
                        right_widget = self.main_splitter.widget(2)
                        
                        # 스플리터에서 모든 위젯 제거
                        for i in range(self.main_splitter.count()):
                            widget = self.main_splitter.widget(0)
                            widget.setParent(None)
                        
                        # 좌우반전: 이미지 | 내용 | 리스트
                        self.main_splitter.addWidget(right_widget)   # 이미지 (오른쪽 -> 왼쪽)
                        self.main_splitter.addWidget(middle_widget)  # 내용 (중간 유지)
                        self.main_splitter.addWidget(left_widget)    # 리스트 (왼쪽 -> 오른쪽)
                        
                        # 크기도 반전 (리스트와 이미지 크기 교체)
                        new_sizes = [current_sizes[2], current_sizes[1], current_sizes[0]]
                        self.main_splitter.setSizes(new_sizes)
                        print(f"[DEBUG] UI 복원: 반전 모드 크기 설정 {new_sizes}")
                    
                    # 상태 설정
                    self.ui_flipped = True
                    print(f"[DEBUG] UI 좌우반전 상태 복원 완료: {self.ui_flipped}")
                        
        except Exception as e:
            print(f"[ERROR] UI 설정 불러오기 실패: {e}")

    def clear_page_list(self):
        self.state.characters = []
        self.char_list.clear()
        self.current_book = None
        self.image_scene.clear()
        self.image_view.update_drop_hint_visibility()
        self.update_all_buttons_state()

    def closeEvent(self, event):
        """창 닫기 이벤트 처리"""
        if self.stay_in_tray and hasattr(self, 'tray_icon') and self.tray_icon.isVisible():
            # 트레이에 상주하는 경우 창만 숨기기
            event.ignore()
            self.hide()
        else:
            # 트레이에 상주하지 않는 경우 완전 종료
            self.save_ui_settings()
            if hasattr(self, 'tray_icon'):
                self.tray_icon.hide()
            event.accept()

    def update_all_buttons_state(self):
        enabled = self.current_book is not None
        self.add_button.setEnabled(enabled)
        
        # 정렬 선택기 활성화/비활성화
        if hasattr(self, "sort_selector"):
            self.sort_selector.setEnabled(enabled)
        
        page_enabled = enabled and self.current_index >= 0
        self.name_input.setEnabled(page_enabled)
        self.tag_input.setEnabled(page_enabled)
        self.desc_input.setEnabled(page_enabled)
        self.prompt_input.setEnabled(page_enabled)
        self.save_button.setEnabled(page_enabled)
        self.copy_button.setEnabled(page_enabled)
        self.duplicate_button.setEnabled(page_enabled)
        self.image_load_btn.setEnabled(page_enabled)
        self.image_remove_btn.setEnabled(page_enabled)
        self.lock_checkbox.setEnabled(page_enabled)  # 페이지 잠금 체크박스 활성화 조건 추가
        
        # 잠금 상태에 따른 삭제 버튼 비활성화
        if page_enabled and self.current_index >= 0 and self.current_index < len(self.state.characters):
            is_locked = self.state.characters[self.current_index].get('locked', False)
            self.delete_button.setEnabled(not is_locked)
        else:
            self.delete_button.setEnabled(page_enabled)

    def refresh_character_list(self, selected_name=None, should_save=True):
        """캐릭터 리스트를 갱신합니다."""
        if not self.current_book:
            self.state.characters = []
            self.char_list.clear()
            self.update_all_buttons_state()
            return

        # 검색어 가져오기
        query = self.search_input.text().strip().lower() if hasattr(self, "search_input") else ""
        
        # 리스트 갱신 준비
        self.char_list.blockSignals(True)
        self.char_list.clear()
        
        # 필터링 및 아이템 추가
        selected_index = -1
        for i, char in enumerate(self.state.characters):
            name = char.get("name", "").lower()
            tags = char.get("tags", "").lower()
            
            if not query or query in name or query in tags:
                item = QListWidgetItem()
                text = char.get("name", "(이름 없음)")
                is_favorite = char.get("favorite", False)
                emoji = char.get("emoji", "📄")
                is_locked = char.get("locked", False)  # 잠금 상태 가져오기
                
                # 커스텀 위젯 생성
                widget = PageItemWidget(text, is_favorite, emoji, is_locked)  # is_locked 전달
                item.setData(Qt.UserRole, text)
                
                self.char_list.addItem(item)
                self.char_list.setItemWidget(item, widget)
                item.setSizeHint(widget.sizeHint())
                
                if text == selected_name:
                    selected_index = self.char_list.count() - 1

        self.char_list.blockSignals(False)

        # 선택 상태 복원
        if selected_index >= 0:
            self.char_list.setCurrentRow(selected_index)
            self.current_index = selected_index
        else:
            # selected_name이 None이거나 찾을 수 없으면 아무것도 선택하지 않음
            self.char_list.clearSelection()
            self.current_index = -1

        self.update_all_buttons_state()
        
        # 상태가 변경되었으면 저장
        if should_save and self.current_book and self.current_book in self.state.books:
            self.state.books[self.current_book]["pages"] = self.state.characters
            self.save_to_file()

    def on_book_selected(self, index):
        # 즐겨찾기 토글 중일 때는 북 선택 처리를 하지 않음
        if getattr(self, '_toggling_favorite', False):
            return
        
        self.sort_mode_custom = False
        
        # 다중 선택 여부 확인
        selected_books = self.book_list.selectedItems()
        
        if len(selected_books) > 1:
            # 다중 선택된 경우 - 페이지 리스트 숨기기
            self.current_book = None
            self.state.characters = []
            self.char_list.clear()
            if hasattr(self, 'add_button'):
                self.add_button.setEnabled(False)
            
            # 입력 필드 초기화
            self.current_index = -1
            if hasattr(self, 'name_input'):
                self.name_input.clear()
            if hasattr(self, 'tag_input'):
                self.tag_input.clear()
            if hasattr(self, 'desc_input'):
                self.desc_input.clear()
            if hasattr(self, 'prompt_input'):
                self.prompt_input.clear()
            self.image_scene.clear()
            self.image_view.update_drop_hint_visibility()
            
            # EXIF 체크박스 해제 (다중 선택 시)
            if hasattr(self, 'exif_checkbox'):
                self._exif_programmatic_change = True
                self.exif_checkbox.setChecked(False)
                self._exif_programmatic_change = False
                self.image_view.hide_exif_overlay()
            
            self.update_all_buttons_state()
            return
        
        # 단일 선택인 경우 기존 로직
        if 0 <= index < self.book_list.count():
            item = self.book_list.item(index)
            book_name = item.data(Qt.UserRole) if item else None
            self.current_book = book_name
            book_data = self.state.books.get(book_name, {})
            self.state.characters = book_data.get("pages", [])
            
            # 현재 정렬 모드 적용 (커스텀 정렬이 아닌 경우)
            if hasattr(self, 'sort_selector') and not self.sort_mode_custom and self.state.characters and self.current_book in self.state.books:
                current_sort_mode = self.sort_selector.currentText()
                from promptbook_features import sort_characters
                self.state.characters = sort_characters(self.state.characters, current_sort_mode)
                if self.current_book and self.current_book in self.state.books:
                    self.state.books[self.current_book]["pages"] = self.state.characters
            
            # 버튼 활성화
            self.add_button.setEnabled(True)
            
            # 페이지 리스트 업데이트 (선택된 페이지 없음)
            self.refresh_character_list(selected_name=None)
            
            # 입력 필드 초기화 및 선택 상태 해제
            self.current_index = -1
            self.char_list.clearSelection()  # 선택 상태 해제
            self.name_input.clear()
            self.tag_input.clear()
            self.desc_input.clear()
            self.prompt_input.clear()
            self.image_scene.clear()
            self.image_view.update_drop_hint_visibility()  # 드롭 힌트 가시성 업데이트
            
            # EXIF 체크박스 해제 (북 변경 시)
            if hasattr(self, 'exif_checkbox'):
                self._exif_programmatic_change = True
                self.exif_checkbox.setChecked(False)
                self._exif_programmatic_change = False
                self.image_view.hide_exif_overlay()
        else:
            # 북이 선택되지 않은 경우
            self.current_book = None
            self.state.characters = []
            self.char_list.clear()
            self.add_button.setEnabled(False)
            self.image_scene.clear()
            self.image_view.update_drop_hint_visibility()  # 드롭 힌트 가시성 업데이트
            
            # EXIF 체크박스 해제 (북 선택 해제 시)
            if hasattr(self, 'exif_checkbox'):
                self._exif_programmatic_change = True
                self.exif_checkbox.setChecked(False)
                self._exif_programmatic_change = False
                self.image_view.hide_exif_overlay()
            
        self.update_all_buttons_state()

    def save_to_file(self):
        """파일 저장 시 자동으로 이미지 정리 실행"""
        if getattr(self, '_initial_loading', False):
            return
        
        # 즐겨찾기 토글 중일 때는 저장하지 않음 (이벤트 충돌 방지)
        if getattr(self, '_toggling_favorite', False):
            return
        
        try:
            with open(self.SAVE_FILE, 'w', encoding='utf-8') as f:
                json.dump(self.state.books, f, ensure_ascii=False, indent=2)
            
            # 즐겨찾기 토글 중에는 이미지 정리를 하지 않음 (UI 이벤트 충돌 방지)
            # self.cleanup_unused_images_silent()
            
        except Exception as e:
            print(f"[ERROR] 저장 실패: {e}")

    def load_from_file(self):
        if os.path.exists(self.SAVE_FILE):
            try:
                with open(self.SAVE_FILE, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 데이터 구조 호환성 검사 및 마이그레이션
                if isinstance(data, dict):
                    # 새로운 형식 (북 딕셔너리)인지 확인
                    if all(isinstance(v, dict) and 'pages' in v for v in data.values() if isinstance(v, dict)):
                        # 새로운 형식: {book_name: {pages: [...], emoji: "...", is_favorite: bool}}
                        self.state.books = data
                        print("[DEBUG] 새로운 형식의 데이터 로드됨")
                    else:
                        # 이전 형식일 가능성 - 기본 북으로 변환
                        print("[DEBUG] 이전 형식 데이터 감지, 마이그레이션 시작")
                        if isinstance(data, list):
                            # 리스트 형태의 이전 데이터
                            self.state.books = {
                                "기본 북": {
                                    "pages": data,
                                    "emoji": "📕",
                                    "is_favorite": False
                                }
                            }
                        else:
                            # 딕셔너리지만 구조가 다른 경우
                            self.state.books = {
                                "기본 북": {
                                    "pages": [],
                                    "emoji": "📕", 
                                    "is_favorite": False
                                }
                            }
                        print("[DEBUG] 마이그레이션 완료, 파일 저장")
                        self.save_to_file()  # 마이그레이션된 데이터 저장
                else:
                    # 예상치 못한 형식
                    print("[DEBUG] 예상치 못한 데이터 형식, 기본값으로 초기화")
                    self.state.books = {}
                
                # 북 리스트 갱신
                self.refresh_book_list()

                self.current_book = None
                self.state.characters = []
                self.char_list.clear()
                self.name_input.clear()
                self.tag_input.clear()
                self.desc_input.clear()
                self.prompt_input.clear()
                self.image_scene.clear()
                self.update_all_buttons_state()

            except Exception as e:
                print(f"불러오기 실패: {e}")
                QMessageBox.warning(self, "오류", f"파일 불러오기 중 오류가 발생했습니다:\n{str(e)}")
                # 오류 발생 시 기본값으로 초기화
                self.state.books = {}
        self._initial_loading = False

    def change_character(self, new_index):
        selected_name = None
        if new_index != -1 and self.char_list.item(new_index):
            selected_name = self.char_list.item(new_index).data(Qt.UserRole)

        new_index = -1
        for i, char in enumerate(self.state.characters):
            if char["name"] == selected_name:
                new_index = i
                break

        self.current_index = new_index
        self.load_character(new_index)

    def copy_prompt_to_clipboard(self):
        QApplication.clipboard().setText(self.prompt_input.toPlainText())
        QToolTip.showText(self.copy_button.mapToGlobal(self.copy_button.rect().center()), "프롬프트가 복사되었습니다.")

    def duplicate_selected_character_with_tooltip(self):
        # 다중 선택이 있는지 확인
        selected_items = self.char_list.selectedItems()
        if len(selected_items) > 1:
            self.duplicate_multiple_characters(selected_items)
        else:
            self.duplicate_selected_character()
            QToolTip.showText(self.duplicate_button.mapToGlobal(self.duplicate_button.rect().center()), "페이지가 복제되었습니다.")

    def delete_selected_character_with_tooltip(self):
        # 다중 선택이 있는지 확인
        selected_items = self.char_list.selectedItems()
        if len(selected_items) > 1:
            self.delete_multiple_characters(selected_items)
        else:
            self.delete_selected_character()
            QToolTip.showText(self.delete_button.mapToGlobal(self.delete_button.rect().center()), "페이지가 삭제되었습니다.")

    def load_preview_image(self):
        file_path, _ = QFileDialog.getOpenFileName(self, "이미지 불러오기", "", "Images (*.png *.jpg *.jpeg *.bmp *.gif)")
        if file_path:
            self.load_image_from_path(file_path)
    
    def load_image_from_path(self, file_path):
        """파일 경로로부터 이미지를 로드하는 공통 메서드"""
        if not file_path or not os.path.exists(file_path):
            print(f"[ERROR] 이미지 파일이 존재하지 않습니다: {file_path}")
            return
            
        # 현재 페이지가 선택되어 있는지 확인
        if not (0 <= self.current_index < len(self.state.characters)):
            QMessageBox.warning(self, "이미지 로드 실패", "먼저 페이지를 선택해 주세요.")
            return
        
        # 이미지를 images 폴더로 복사
        try:
            images_dir = get_images_directory()
            
            # 현재 페이지 이름으로 고유한 파일명 생성
            page_name = self.state.characters[self.current_index].get("name", "page")
            # 파일명에서 특수문자 제거
            safe_page_name = "".join(c for c in page_name if c.isalnum() or c in (' ', '-', '_')).rstrip()
            if not safe_page_name:
                safe_page_name = "page"
            
            # 파일 확장자 가져오기
            _, ext = os.path.splitext(file_path)
            if not ext:
                ext = '.png'  # 기본 확장자
            
            # 대상 파일명 생성
            dest_filename = f"{safe_page_name}{ext}"
            dest_path = os.path.join(images_dir, dest_filename)
            
            # 파일명 중복 방지
            counter = 1
            while os.path.exists(dest_path):
                dest_filename = f"{safe_page_name}_{counter:03d}{ext}"
                dest_path = os.path.join(images_dir, dest_filename)
                counter += 1
            
            # 이미지 파일 복사
            shutil.copy2(file_path, dest_path)
            
            # 복사된 파일 경로 저장
            self.state.characters[self.current_index]["image_path"] = dest_path
            print(f"[DEBUG] 이미지 복사 완료: {file_path} -> {dest_path}")
            
        except Exception as e:
            print(f"[ERROR] 이미지 복사 실패: {e}")
            # 복사 실패 시 원본 경로 저장
            self.state.characters[self.current_index]["image_path"] = file_path
        
        self.edited = True
        
        # 이미지 뷰 업데이트 (복사된 파일 또는 원본 파일)
        stored_path = self.state.characters[self.current_index]["image_path"]
        self.update_image_view(stored_path)
        
        # 버튼 상태 업데이트
        self.update_image_buttons_state()
        
        # 상태 저장
        if self.current_book and self.current_book in self.state.books:
            self.state.books[self.current_book]["pages"] = self.state.characters
            self.save_to_file()
            
        print(f"[DEBUG] 이미지 로드 완료: {stored_path}")

    def load_character(self, index):
        if 0 <= index < len(self.state.characters):
            self.block_save = True
            self.current_index = index
            data = self.state.characters[index]
            self.name_input.setText(data["name"])
            self.tag_input.setText(data["tags"])
            self.desc_input.setPlainText(data["desc"])
            self.prompt_input.setPlainText(data["prompt"])

            if "image_path" in data and os.path.exists(data["image_path"]):
                self.update_image_view(data["image_path"])
            else:
                self.image_scene.clear()

            self.block_save = False
            self.edited = False
        else:
            self.name_input.clear()
            self.tag_input.clear()
            self.desc_input.clear()
            self.prompt_input.clear()
            self.image_scene.clear()

        self.name_input.setEnabled(index != -1)
        self.tag_input.setEnabled(index != -1)
        self.desc_input.setEnabled(index != -1)
        self.prompt_input.setEnabled(index != -1)
        self.save_button.setEnabled(index != -1)
        self.copy_button.setEnabled(index != -1)
        self.delete_button.setEnabled(index != -1)
        self.image_load_btn.setEnabled(index != -1)
        self.image_remove_btn.setEnabled(index != -1)
        self.update_image_buttons_state()

    def on_character_clicked(self, item):
        print("[DEBUG] on_character_clicked 호출됨")
        selected_pages = self.char_list.selectedItems()
        clicked_name = item.data(Qt.UserRole)
        print(f"[DEBUG] 클릭된 아이템: {clicked_name}")
        print(f"[DEBUG] 클릭 후 선택된 페이지 수: {len(selected_pages)}")
        
        # 클릭된 아이템이 실제로 선택되어 있는지 확인
        is_clicked_item_selected = item in selected_pages
        print(f"[DEBUG] 클릭된 아이템이 선택되어 있나? {is_clicked_item_selected}")
        
        # itemSelectionChanged가 모든 선택 처리를 담당하므로 여기서는 아무것도 하지 않음
        print("[DEBUG] itemSelectionChanged 신호에서 처리하므로 여기서는 아무것도 안함")
    
    def on_book_selection_changed(self):
        """북 선택 변경 시 호출 (다중 선택 감지용)"""
        selected_books = self.book_list.selectedItems()
        
        if len(selected_books) > 1:
            # 다중 선택된 경우 - 페이지 리스트 숨기기
            self.current_book = None
            self.state.characters = []
            self.char_list.clear()
            if hasattr(self, 'add_button'):
                self.add_button.setEnabled(False)
            
            # 입력 필드 초기화
            self.current_index = -1
            if hasattr(self, 'name_input'):
                self.name_input.clear()
            if hasattr(self, 'tag_input'):
                self.tag_input.clear()
            if hasattr(self, 'desc_input'):
                self.desc_input.clear()
            if hasattr(self, 'prompt_input'):
                self.prompt_input.clear()
            self.image_scene.clear()
            self.image_view.update_drop_hint_visibility()
            
            self.update_all_buttons_state()
        elif len(selected_books) == 1:
            # 단일 선택으로 돌아온 경우
            current_item = selected_books[0]
            index = self.book_list.row(current_item)
            self.on_book_selected(index)
    
    def on_character_selection_changed(self):
        """페이지 선택 변경 시 호출 (다중 선택 감지용)"""
        # 약간의 지연을 두어 모든 선택 변경이 완료된 후 처리
        QTimer.singleShot(10, self._handle_selection_change)
    
    def _handle_selection_change(self):
        """실제 선택 변경 처리"""
        selected_pages = self.char_list.selectedItems()
        print(f"[DEBUG] _handle_selection_change: 선택된 페이지 수={len(selected_pages)}")
        
        if len(selected_pages) > 1:
            # 다중 선택된 경우 - 내용 포커싱 안하기
            self.current_index = -1
            if hasattr(self, 'name_input'):
                self.name_input.clear()
            if hasattr(self, 'tag_input'):
                self.tag_input.clear()
            if hasattr(self, 'desc_input'):
                self.desc_input.clear()
            if hasattr(self, 'prompt_input'):
                self.prompt_input.clear()
            if hasattr(self, 'lock_checkbox'):
                self.lock_checkbox.setChecked(False)
                self.lock_checkbox.setText("🔓 페이지 잠금")
                self.lock_checkbox.setEnabled(False)
            self.image_scene.clear()
            self.image_view.update_drop_hint_visibility()
            
            # EXIF 체크박스 상태 초기화 (다중 선택 시에는 해제)
            if hasattr(self, 'exif_checkbox'):
                self._exif_programmatic_change = True
                self.exif_checkbox.setChecked(False)
                self._exif_programmatic_change = False
                self.image_view.hide_exif_overlay()
            
            self.update_all_buttons_state()
            self.update_image_buttons_state()
        elif len(selected_pages) == 1:
            # 단일 선택으로 돌아온 경우
            print("[DEBUG] 단일 선택으로 내용 로드")
            # 선택된 아이템만 사용 (currentItem 완전히 무시)
            selected_item = selected_pages[0]
            name = selected_item.data(Qt.UserRole)
            print(f"[DEBUG] 선택된 아이템 이름: {name}")
            
            # characters 리스트에서 해당 페이지 찾기
            for i, char in enumerate(self.state.characters):
                if char.get("name") == name:
                    print(f"[DEBUG] 페이지 데이터 찾음 - 인덱스: {i}")
                    self.current_index = i
                    
                    # 입력 필드 업데이트
                    if hasattr(self, 'name_input'):
                        self.name_input.setText(char.get("name", ""))
                    if hasattr(self, 'tag_input'):
                        self.tag_input.setText(char.get("tags", ""))
                    if hasattr(self, 'desc_input'):
                        self.desc_input.setPlainText(char.get("desc", ""))
                    if hasattr(self, 'prompt_input'):
                        self.prompt_input.setPlainText(char.get("prompt", ""))
                    
                    # 잠금 상태 표시
                    if hasattr(self, 'lock_checkbox'):
                        is_locked = char.get('locked', False)
                        self.lock_checkbox.setChecked(is_locked)
                        self.lock_checkbox.setEnabled(True)
                        
                        # 체크박스 텍스트 업데이트
                        if is_locked:
                            self.lock_checkbox.setText("🔒 페이지 잠금")
                        else:
                            self.lock_checkbox.setText("🔓 페이지 잠금")
                    
                    # 이미지 업데이트
                    if "image_path" in char and os.path.exists(char["image_path"]):
                        self.update_image_view(char["image_path"])
                    else:
                        self.image_scene.clear()
                        self.image_view.update_drop_hint_visibility()
                    
                    # EXIF 체크박스 상태 관리 (페이지 변경 시 항상 해제)
                    if hasattr(self, 'exif_checkbox'):
                        self._exif_programmatic_change = True
                        self.exif_checkbox.setChecked(False)
                        self._exif_programmatic_change = False
                        self.image_view.hide_exif_overlay()
                    
                    self.update_all_buttons_state()
                    self.update_image_buttons_state()
                    break
        elif len(selected_pages) == 0:
            # 모든 선택 해제된 경우 - 내용 비우기
            self.current_index = -1
            if hasattr(self, 'name_input'):
                self.name_input.clear()
            if hasattr(self, 'tag_input'):
                self.tag_input.clear()
            if hasattr(self, 'desc_input'):
                self.desc_input.clear()
            if hasattr(self, 'prompt_input'):
                self.prompt_input.clear()
            if hasattr(self, 'lock_checkbox'):
                self.lock_checkbox.setChecked(False)
                self.lock_checkbox.setText("🔓 페이지 잠금")
                self.lock_checkbox.setEnabled(False)
            self.image_scene.clear()
            self.image_view.update_drop_hint_visibility()
            
            # EXIF 체크박스 상태 초기화 (선택 해제 시에는 해제)
            if hasattr(self, 'exif_checkbox'):
                self._exif_programmatic_change = True
                self.exif_checkbox.setChecked(False)
                self._exif_programmatic_change = False
                self.image_view.hide_exif_overlay()
            
            self.update_all_buttons_state()
            self.update_image_buttons_state()

    def handle_character_sort(self):
        mode = self.sort_selector.currentText()
        print(f"[DEBUG] 정렬 모드: {mode}")

        # 현재 북이 없으면 정렬하지 않음
        if not self.current_book:
            print("[DEBUG] 현재 선택된 북이 없음")
            return

        if mode == "커스텀 정렬":
            self.sort_mode_custom = True
            self.char_list.setDragDropMode(QAbstractItemView.InternalMove)
            self.char_list.setDefaultDropAction(Qt.MoveAction)
        else:
            self.sort_mode_custom = False
            self.char_list.setDragDropMode(QAbstractItemView.NoDragDrop)

        # 정렬 적용
        from promptbook_features import sort_characters
        self.state.characters = sort_characters(self.state.characters, mode)
        
        # 상태 저장
        if self.current_book in self.state.books:
            if self.current_book and self.current_book in self.state.books:
                self.state.books[self.current_book]["pages"] = self.state.characters
            
            # 리스트 갱신 및 저장
            self.refresh_character_list(should_save=True)
            
            # UI 설정 저장
            self.save_ui_settings()
            
            print(f"[DEBUG] 정렬 후 캐릭터 순서:")
            for char in self.state.characters:
                print(f"  - {char.get('name')} (즐겨찾기: {char.get('favorite', False)})")
        else:
            print(f"[DEBUG] 현재 북 '{self.current_book}'이(가) books에 없음")

    def add_book(self):
        print("[DEBUG] add_book 메서드 호출됨")  # 디버그 추가
        base_name = "새 북"
        existing_names = set()
        for i in range(self.book_list.count()):
            item = self.book_list.item(i)
            if item:
                existing_names.add(item.data(Qt.UserRole))
        
        # 고유한 이름 생성
        for i in range(1, 1000):
            candidate = f"{base_name} ({i})"
            if candidate not in existing_names:
                unique_name = candidate
                break
        else:
            # 만약 (1)부터 (999)까지 모두 사용 중이면 기본 이름 사용
            unique_name = base_name

        print(f"[DEBUG] 새 북 이름: {unique_name}")  # 디버그 추가
        
        # 새 북 데이터 생성
        self.state.books[unique_name] = {
            "emoji": "📕",
            "pages": []
        }
        print(f"[DEBUG] 새 북 데이터 생성 완료, 현재 북 수: {len(self.state.books)}")  # 디버그 추가
        
        # 리스트에 아이템 추가
        item = QListWidgetItem()
        
        # 커스텀 위젯 생성
        widget = BookItemWidget(unique_name, False, "📕")
        item.setData(Qt.UserRole, unique_name)
        
        self.book_list.addItem(item)
        self.book_list.setItemWidget(item, widget)
        item.setSizeHint(widget.sizeHint())
        print(f"[DEBUG] 북 리스트에 아이템 추가 완료")  # 디버그 추가
        
        # 현재 정렬 모드가 커스텀이 아니면 정렬 적용
        if hasattr(self, 'book_sort_selector') and not self.book_sort_custom:
            self.handle_book_sort()
            # 정렬 후 새로 생성된 아이템 찾기
            item = None
            for i in range(self.book_list.count()):
                book_item = self.book_list.item(i)
                if book_item.data(Qt.UserRole) == unique_name:
                    item = book_item
                    break
        
        # 새로 추가된 북 선택
        if item:
            self.book_list.setCurrentItem(item)
            self.on_book_selected(self.book_list.row(item))
            print(f"[DEBUG] 새 북 선택 완료")  # 디버그 추가
        else:
            print(f"[DEBUG] 새 북 아이템을 찾을 수 없음")  # 디버그 추가
        
        self.save_to_file()
        print(f"[DEBUG] add_book 완료")  # 디버그 추가

    def save_selected_book(self):
        """선택된 북(들)을 zip 파일로 저장합니다."""
        # 다중 선택된 북들 확인
        selected_books = self.book_list.selectedItems()
        book_names = []
        
        for item in selected_books:
            book_name = item.data(Qt.UserRole)
            if book_name:
                book_names.append(book_name)
        
        # 선택된 북이 없으면 현재 북 사용
        if not book_names:
            if not self.current_book:
                QMessageBox.warning(self, "저장 실패", "선택된 북이 없습니다.")
                return
            book_names = [self.current_book]
        
        # 파일 저장 대화상자
        if len(book_names) == 1:
            default_name = f"{book_names[0]}.zip"
        else:
            default_name = f"북_모음_{len(book_names)}개.zip"
            
        path, _ = QFileDialog.getSaveFileName(self, "북 저장", default_name, "Zip Files (*.zip)")
        if not path:
            return
            
        try:
            from zipfile import ZipFile
            
            with ZipFile(path, 'w') as zipf:
                if len(book_names) == 1:
                    # 단일 북 저장 (기존 형식)
                    book_name = book_names[0]
                    book_data = self.state.books[book_name]
                    pages = book_data.get("pages", [])
                    
                    # 내보낼 데이터 준비
                    export_data = {
                        "book_name": book_name,
                        "emoji": book_data.get("emoji", "📕"),
                        "pages": []
                    }
                    
                    # 각 페이지 처리
                    for i, page in enumerate(pages):
                        page_copy = dict(page)
                        
                        # 이미지가 있으면 zip에 포함
                        img_path = page.get("image_path")
                        if img_path and os.path.exists(img_path):
                            # zip 내부 경로 생성
                            filename = f"images/{i}_{os.path.basename(img_path)}"
                            zipf.write(img_path, filename)
                            page_copy["image_path"] = filename
                        else:
                            page_copy["image_path"] = ""
                            
                        export_data["pages"].append(page_copy)
                    
                    # 북 데이터를 JSON으로 저장
                    zipf.writestr("book_data.json", json.dumps(export_data, ensure_ascii=False, indent=2))
                    
                else:
                    # 다중 북 저장 (새 형식)
                    export_data = {
                        "format": "multiple_books",
                        "books": []
                    }
                    
                    # 각 북 처리
                    for book_name in book_names:
                        book_data = self.state.books[book_name]
                        pages = book_data.get("pages", [])
                        
                        book_export = {
                            "book_name": book_name,
                            "emoji": book_data.get("emoji", "📕"),
                            "pages": []
                        }
                        
                        # 각 페이지 처리
                        for i, page in enumerate(pages):
                            page_copy = dict(page)
                            
                            # 이미지가 있으면 zip에 포함
                            img_path = page.get("image_path")
                            if img_path and os.path.exists(img_path):
                                # zip 내부 경로 생성 (북 이름을 포함하여 중복 방지)
                                filename = f"images/{book_name}_{i}_{os.path.basename(img_path)}"
                                zipf.write(img_path, filename)
                                page_copy["image_path"] = filename
                            else:
                                page_copy["image_path"] = ""
                                
                            book_export["pages"].append(page_copy)
                        
                        export_data["books"].append(book_export)
                    
                    # 다중 북 데이터를 JSON으로 저장
                    zipf.writestr("books_data.json", json.dumps(export_data, ensure_ascii=False, indent=2))
                
            if len(book_names) == 1:
                QMessageBox.information(self, "저장 완료", f"'{book_names[0]}' 북이 성공적으로 저장되었습니다.")
                print(f"[DEBUG] 선택된 북 저장 완료: {book_names[0]} -> {path}")
            else:
                QMessageBox.information(self, "저장 완료", f"{len(book_names)}개의 북이 성공적으로 저장되었습니다.\n{', '.join(book_names[:3])}{' 외' if len(book_names) > 3 else ''}")
                print(f"[DEBUG] 다중 북 저장 완료: {book_names} -> {path}")
            
        except Exception as e:
            QMessageBox.critical(self, "저장 실패", f"북 저장 중 오류가 발생했습니다:\n{str(e)}")
            print(f"[ERROR] 북 저장 실패: {e}")

    def load_saved_book(self):
        """저장된 북을 zip 파일에서 불러옵니다."""
        # 파일 열기 대화상자
        path, _ = QFileDialog.getOpenFileName(self, "북 불러오기", "", "Zip Files (*.zip)")
        if not path:
            return
            
        try:
            from zipfile import ZipFile
            import tempfile
            
            # 임시 디렉토리에 압축 해제
            temp_dir = tempfile.mkdtemp()
            
            with ZipFile(path, 'r') as zipf:
                zipf.extractall(temp_dir)
                
                # 다중 북 형식 확인: books_data.json 파일
                books_json_path = os.path.join(temp_dir, "books_data.json")
                if os.path.exists(books_json_path):
                    # 다중 북 형식 처리
                    self._load_multiple_books_format(temp_dir, books_json_path)
                else:
                    # 단일 북 형식 확인: book_data.json 파일
                    json_path = os.path.join(temp_dir, "book_data.json")
                    if os.path.exists(json_path):
                        # 단일 북 형식 처리
                        self._load_new_format_book(temp_dir, json_path)
                    else:
                        # 기존 형식 확인: character_list.zip 구조
                        json_files = [f for f in os.listdir(temp_dir) if f.endswith('.json')]
                        if json_files:
                            # 기존 형식 처리
                            self._load_legacy_format_book(temp_dir, json_files)
                        else:
                            QMessageBox.warning(self, "불러오기 실패", "올바른 북 파일이 아닙니다.")
                            return
                        
        except Exception as e:
            QMessageBox.critical(self, "불러오기 실패", f"북 불러오기 중 오류가 발생했습니다:\n{str(e)}")
            print(f"[ERROR] 북 불러오기 실패: {e}")

    def _load_new_format_book(self, temp_dir, json_path):
        """새 형식 북 파일 불러오기 (book_data.json)"""
        with open(json_path, 'r', encoding='utf-8') as f:
            book_data = json.load(f)
        
        # 북 이름 중복 체크
        original_name = book_data.get("book_name", "불러온 북")
        book_name = original_name
        existing_names = set(self.state.books.keys())
        
        if book_name in existing_names:
            # 중복된 북 이름이 있을 때 사용자에게 선택권 제공
            msgBox = QMessageBox()
            msgBox.setWindowTitle("북 이름 중복")
            msgBox.setText(f"'{original_name}' 북이 이미 존재합니다.")
            msgBox.setInformativeText("어떻게 하시겠습니까?")
            
            overwrite_btn = msgBox.addButton("덮어쓰기", QMessageBox.AcceptRole)
            add_new_btn = msgBox.addButton("새로 추가", QMessageBox.ActionRole)
            cancel_btn = msgBox.addButton("취소", QMessageBox.RejectRole)
            
            msgBox.setDefaultButton(cancel_btn)
            msgBox.exec()
            
            if msgBox.clickedButton() == overwrite_btn:
                # 기존 북 덮어쓰기
                book_name = original_name
                print(f"[DEBUG] 기존 북 덮어쓰기: {book_name}")
            elif msgBox.clickedButton() == add_new_btn:
                # 새 이름으로 추가
                for i in range(1, 1000):
                    candidate = f"{original_name} ({i})"
                    if candidate not in existing_names:
                        book_name = candidate
                        break
                print(f"[DEBUG] 새 이름으로 추가: {book_name}")
            else:
                # 취소
                print("[DEBUG] 북 불러오기 취소")
                return
        
        # 이미지 파일들을 images 폴더로 복사
        pages = book_data.get("pages", [])
        for page in pages:
            rel_path = page.get("image_path")
            if rel_path:
                full_path = os.path.join(temp_dir, rel_path)
                if os.path.exists(full_path):
                    # images 폴더 생성
                    images_dir = get_images_directory()
                    # 고유한 파일명 생성
                    dest_filename = f"{book_name}_{os.path.basename(full_path)}"
                    dest_path = os.path.join(images_dir, dest_filename)
                    
                    # 파일명 중복 방지
                    counter = 1
                    while os.path.exists(dest_path):
                        name, ext = os.path.splitext(dest_filename)
                        dest_filename = f"{name}_{counter}{ext}"
                        dest_path = os.path.join(images_dir, dest_filename)
                        counter += 1
                    
                    shutil.copy(full_path, dest_path)
                    page["image_path"] = dest_path
                else:
                    page["image_path"] = ""
        
        # 새 북을 books에 추가
        emoji = book_data.get("emoji", "📕")
        self.state.books[book_name] = {
            "emoji": emoji,
            "pages": pages
        }
        
        self._add_book_to_ui(book_name, emoji)
        
        QMessageBox.information(self, "불러오기 완료", f"'{book_name}' 북이 성공적으로 불러와졌습니다.")
        print(f"[DEBUG] 새 형식 북 불러오기 완료: {book_name}")

    def _load_legacy_format_book(self, temp_dir, json_files):
        """기존 형식 북 파일 불러오기 (character_list.zip 구조)"""
        # 모든 페이지를 하나의 북에 통합
        all_pages = []
        
        for json_file in json_files:
            json_path = os.path.join(temp_dir, json_file)
            try:
                with open(json_path, 'r', encoding='utf-8') as f:
                    pages = json.load(f)
                    if isinstance(pages, list):
                        all_pages.extend(pages)
            except Exception as e:
                print(f"[ERROR] JSON 파일 읽기 실패 {json_file}: {e}")
                continue
        
        if not all_pages:
            QMessageBox.warning(self, "불러오기 실패", "불러올 페이지가 없습니다.")
            return
        
        # 새 북 이름 생성
        base_name = "불러온 북"
        book_name = base_name
        existing_names = set(self.state.books.keys())
        
        if book_name in existing_names:
            # 중복된 북 이름이 있을 때 사용자에게 선택권 제공
            msgBox = QMessageBox()
            msgBox.setWindowTitle("북 이름 중복")
            msgBox.setText(f"'{base_name}' 북이 이미 존재합니다.")
            msgBox.setInformativeText("어떻게 하시겠습니까?")
            
            overwrite_btn = msgBox.addButton("덮어쓰기", QMessageBox.AcceptRole)
            add_new_btn = msgBox.addButton("새로 추가", QMessageBox.ActionRole)
            cancel_btn = msgBox.addButton("취소", QMessageBox.RejectRole)
            
            msgBox.setDefaultButton(cancel_btn)
            msgBox.exec()
            
            if msgBox.clickedButton() == overwrite_btn:
                # 기존 북 덮어쓰기
                book_name = base_name
                print(f"[DEBUG] 기존 북 덮어쓰기: {book_name}")
            elif msgBox.clickedButton() == add_new_btn:
                # 새 이름으로 추가
                for i in range(1, 1000):
                    candidate = f"{base_name} ({i})"
                    if candidate not in existing_names:
                        book_name = candidate
                        break
                print(f"[DEBUG] 새 이름으로 추가: {book_name}")
            else:
                # 취소
                print("[DEBUG] 북 불러오기 취소")
                return
        
        # 이미지 파일들을 images 폴더로 복사
        for page in all_pages:
            rel_path = page.get("image_path")
            if rel_path:
                full_path = os.path.join(temp_dir, rel_path)
                if os.path.exists(full_path):
                    # images 폴더 생성
                    images_dir = get_images_directory()
                    # 고유한 파일명 생성
                    dest_filename = f"{book_name}_{os.path.basename(full_path)}"
                    dest_path = os.path.join(images_dir, dest_filename)
                    
                    # 파일명 중복 방지
                    counter = 1
                    while os.path.exists(dest_path):
                        name, ext = os.path.splitext(dest_filename)
                        dest_filename = f"{name}_{counter}{ext}"
                        dest_path = os.path.join(images_dir, dest_filename)
                        counter += 1
                    
                    shutil.copy(full_path, dest_path)
                    page["image_path"] = dest_path
                else:
                    page["image_path"] = ""
        
        # 새 북을 books에 추가
        emoji = "📚"  # 기존 형식은 특별한 이모지 사용
        self.state.books[book_name] = {
            "emoji": emoji,
            "pages": all_pages
        }
        
        self._add_book_to_ui(book_name, emoji)
        
        QMessageBox.information(self, "불러오기 완료", f"'{book_name}' 북이 성공적으로 불러와졌습니다.\n({len(all_pages)}개 페이지)")
        print(f"[DEBUG] 기존 형식 북 불러오기 완료: {book_name} ({len(all_pages)}개 페이지)")

    def _add_book_to_ui(self, book_name, emoji):
        """북을 UI에 추가하는 공통 메서드"""
        # 북 리스트 UI 업데이트
        item = QListWidgetItem()
        
        # 커스텀 위젯 생성
        is_favorite = self.state.books[book_name].get("favorite", False)
        widget = BookItemWidget(book_name, is_favorite, emoji)
        item.setData(Qt.UserRole, book_name)
        
        self.book_list.addItem(item)
        self.book_list.setItemWidget(item, widget)
        item.setSizeHint(widget.sizeHint())
        
        # 북 정렬 적용
        if hasattr(self, 'book_sort_selector') and not self.book_sort_custom:
            self.handle_book_sort()
            # 정렬 후 새로 생성된 아이템 찾기
            for i in range(self.book_list.count()):
                book_item = self.book_list.item(i)
                if book_item.data(Qt.UserRole) == book_name:
                    item = book_item
                    break
        
        # 새로 불러온 북 선택
        if item:
            self.book_list.setCurrentItem(item)
            self.on_book_selected(self.book_list.row(item))
            
            # 불러온 북의 페이지들을 현재 정렬 모드에 맞게 정렬
            if hasattr(self, 'sort_selector') and not self.sort_mode_custom:
                current_sort_mode = self.sort_selector.currentText()
                print(f"[DEBUG] 불러온 북에 정렬 적용: {current_sort_mode}")
                from promptbook_features import sort_characters
                self.state.characters = sort_characters(self.state.characters, current_sort_mode)
                if self.current_book and self.current_book in self.state.books:
                    self.state.books[self.current_book]["pages"] = self.state.characters
                self.refresh_character_list()
        
        # 데이터 저장
        self.save_to_file()

    def _load_multiple_books_format(self, temp_dir, books_json_path):
        """다중 북 형식 파일 불러오기 (books_data.json)"""
        with open(books_json_path, 'r', encoding='utf-8') as f:
            books_data = json.load(f)
        
        books_list = books_data.get("books", [])
        if not books_list:
            QMessageBox.warning(self, "불러오기 실패", "불러올 북이 없습니다.")
            return
        
        existing_names = set(self.state.books.keys())
        loaded_books = []
        name_conflicts = []
        
        # 각 북에 대해 이름 중복 체크
        for book_data in books_list:
            original_name = book_data.get("book_name", "불러온 북")
            if original_name in existing_names:
                name_conflicts.append(original_name)
        
        # 이름 중복이 있는 경우 처리 방법 묻기
        if name_conflicts:
            msgBox = QMessageBox()
            msgBox.setWindowTitle("북 이름 중복")
            msgBox.setText(f"{len(name_conflicts)}개의 북 이름이 중복됩니다:")
            msgBox.setInformativeText(f"{', '.join(name_conflicts[:3])}{' 외' if len(name_conflicts) > 3 else ''}\n\n어떻게 하시겠습니까?")
            
            overwrite_btn = msgBox.addButton("모두 덮어쓰기", QMessageBox.AcceptRole)
            add_new_btn = msgBox.addButton("새 이름으로 추가", QMessageBox.ActionRole)
            cancel_btn = msgBox.addButton("취소", QMessageBox.RejectRole)
            
            msgBox.setDefaultButton(cancel_btn)
            msgBox.exec()
            
            if msgBox.clickedButton() == cancel_btn:
                print("[DEBUG] 다중 북 불러오기 취소")
                return
            
            overwrite_mode = msgBox.clickedButton() == overwrite_btn
        else:
            overwrite_mode = False
        
        # 각 북 처리
        for book_data in books_list:
            original_name = book_data.get("book_name", "불러온 북")
            book_name = original_name
            
            # 이름 중복 처리
            if original_name in existing_names:
                if not overwrite_mode:
                    # 새 이름으로 추가
                    for i in range(1, 1000):
                        candidate = f"{original_name} ({i})"
                        if candidate not in existing_names:
                            book_name = candidate
                            break
                    existing_names.add(book_name)
            else:
                existing_names.add(book_name)
            
            # 이미지 파일들을 images 폴더로 복사
            pages = book_data.get("pages", [])
            for page in pages:
                rel_path = page.get("image_path")
                if rel_path:
                    full_path = os.path.join(temp_dir, rel_path)
                    if os.path.exists(full_path):
                        # images 폴더 생성
                        images_dir = get_images_directory()
                        # 고유한 파일명 생성
                        dest_filename = f"{book_name}_{os.path.basename(full_path)}"
                        dest_path = os.path.join(images_dir, dest_filename)
                        
                        # 파일명 중복 방지
                        counter = 1
                        while os.path.exists(dest_path):
                            name, ext = os.path.splitext(dest_filename)
                            dest_filename = f"{name}_{counter}{ext}"
                            dest_path = os.path.join(images_dir, dest_filename)
                            counter += 1
                        
                        shutil.copy(full_path, dest_path)
                        page["image_path"] = dest_path
                    else:
                        page["image_path"] = ""
            
            # 새 북을 books에 추가
            emoji = book_data.get("emoji", "📕")
            self.state.books[book_name] = {
                "emoji": emoji,
                "pages": pages
            }
            
            self._add_book_to_ui(book_name, emoji)
            loaded_books.append(book_name)
            print(f"[DEBUG] 북 불러오기 완료: {book_name}")
        
        # 첫 번째 불러온 북 선택
        if loaded_books:
            first_book = loaded_books[0]
            for i in range(self.book_list.count()):
                item = self.book_list.item(i)
                if item.data(Qt.UserRole) == first_book:
                    self.book_list.setCurrentItem(item)
                    self.on_book_selected(i)
                    break
        
        QMessageBox.information(self, "불러오기 완료", f"{len(loaded_books)}개의 북이 성공적으로 불러와졌습니다.\n{', '.join(loaded_books[:3])}{' 외' if len(loaded_books) > 3 else ''}")
        print(f"[DEBUG] 다중 북 형식 불러오기 완료: {loaded_books}")

    def add_character(self):
        if not self.current_book:
            return

        base_name = "새 페이지"
        existing_names = {char["name"] for char in self.state.characters}
        
        if base_name not in existing_names:
            unique_name = base_name
        else:
            for i in range(1, 1000):
                candidate = f"{base_name} ({i})"
                if candidate not in existing_names:
                    unique_name = candidate
                    break

        new_data = {
            "name": unique_name,
            "tags": "",
            "desc": "",
            "prompt": "",
            "emoji": "📄"
        }

        self.state.characters.append(new_data)
        
        if not self.sort_mode_custom:
            from promptbook_features import sort_characters
            self.state.characters = sort_characters(self.state.characters, self.sort_selector.currentText())

        if self.current_book and self.current_book in self.state.books:
                self.state.books[self.current_book]["pages"] = self.state.characters
        self.refresh_character_list(selected_name=unique_name)
        
        # 새로 추가된 페이지 찾기
        for i in range(self.char_list.count()):
            item = self.char_list.item(i)
            if item.data(Qt.UserRole) == unique_name:
                self.char_list.setCurrentItem(item)
                self.char_list.scrollToItem(item)
                # 새 페이지의 내용 표시
                self.on_character_selected(i)
                self.name_input.setFocus()  # 이름 입력란에 포커스
                break
                
        self.save_to_file()

    def show_character_context_menu(self, position):
        item = self.char_list.itemAt(position)
        if not item:
            return
            
        menu = QMenu()
        
        # 메뉴 스타일 적용
        menu_style = self.get_menu_style()
        menu.setStyleSheet(menu_style)
        
        # 선택된 아이템들 확인
        selected_items = self.char_list.selectedItems()
        selected_count = len(selected_items)
        
        if selected_count > 1:
            # 다중 선택된 경우
            menu.addAction(f"🔢 선택된 항목: {selected_count}개").setEnabled(False)
            menu.addSeparator()
            
            # 클립보드 액션들 추가
            copy_action = menu.addAction("📋 모두 복사하기")
            cut_action = menu.addAction("✂️ 모두 잘라내기")
            
            menu.addSeparator()
            
            duplicate_action = menu.addAction("📋 모두 복제")
            delete_action = menu.addAction("🗑️ 모두 삭제")
            
            # 메뉴 실행 및 액션 처리
            action = menu.exec(self.char_list.mapToGlobal(position))
            if action == copy_action:
                self.copy_pages_to_clipboard(show_tooltip=True)
            elif action == cut_action:
                self.cut_pages_to_clipboard(show_tooltip=True)
            elif action == duplicate_action:
                self.duplicate_multiple_characters(selected_items)
            elif action == delete_action:
                self.delete_multiple_characters(selected_items)
            return
        
        # 단일 선택인 경우 기존 메뉴
        name = item.data(Qt.UserRole)
        is_favorite = False
        
        # 현재 즐겨찾기 상태 확인
        for char in self.state.characters:
            if char.get("name") == name:
                is_favorite = char.get("favorite", False)
                break
        
        # 즐겨찾기 액션 추가
        if is_favorite:
            favorite_action = menu.addAction("🖤 즐겨찾기 해제")
        else:
            favorite_action = menu.addAction("❤️ 즐겨찾기")
        
        # 구분선 추가
        menu.addSeparator()
        
        # 이모지 변경 서브메뉴
        emoji_menu = QMenu("🔄 이모지 변경")
        emoji_menu.setStyleSheet("""
            QMenu {
                padding: 2px;
            }
            QMenu::item {
                padding: 4px 16px 4px 4px;
                margin: 0px;
            }
            QMenu::item:selected {
                background-color: #505050;
                color: white;
            }
            QMenu::item:hover {
                background-color: #505050;
                color: white;
            }
        """)
        menu.addMenu(emoji_menu)
        
        # 페이지용 이모지 옵션 그룹화
        page_emoji_groups = {
            "페이지": ["📄", "📃", "🗒️", "📑", "🧾", "📰", "🗞️", "📋", "📌", "📎"],
            "특수": ["🌟", "✨", "🔥", "🎯", "🚀", "🧩", "🎨", "💡", "❤️", "💀"],
            "동물": ["🐉", "🦄", "🐱", "👻", "🍀", "🪐", "😺"],
            "표정": ["😀", "😎", "🥳", "😈", "🤖", "👽", "👾", "🙈"],
            "사람": ["👧", "👩", "🧒", "👸", "💃", "🧝‍♀️", "🧚‍♀️", "🧞‍♀️", "👩‍🎤", "👩‍🔬"]
        }
        
        for group_name, emojis in page_emoji_groups.items():
            group_menu = QMenu(group_name)
            group_menu.setStyleSheet(menu_style)
            emoji_menu.addMenu(group_menu)
            for emoji in emojis:
                action = group_menu.addAction(emoji)
                action.triggered.connect(lambda checked, e=emoji, i=item: self.set_page_emoji(i, e))
        
        # 구분선 추가
        menu.addSeparator()
        
        # 클립보드 액션들 추가
        copy_action = menu.addAction("📋 복사하기")
        cut_action = menu.addAction("✂️ 잘라내기")
        
        # 구분선 추가
        menu.addSeparator()
        
        # 기타 액션들 추가
        rename_action = menu.addAction("📝 이름 변경")
        duplicate_action = menu.addAction("📋 복제")
        delete_action = menu.addAction("🗑️ 삭제")
        
        # 메뉴 표시 및 액션 처리
        action = menu.exec(self.char_list.mapToGlobal(position))
        if action == favorite_action:
            self.toggle_favorite_star(item)
        elif action == copy_action:
            self.copy_pages_to_clipboard(show_tooltip=True)
        elif action == cut_action:
            self.cut_pages_to_clipboard(show_tooltip=True)
        elif action == rename_action:
            self.rename_character_dialog(item)
        elif action == duplicate_action:
            self.duplicate_selected_character()
        elif action == delete_action:
            self.delete_selected_character()
        
    def set_page_emoji(self, item, emoji):
        """페이지 이모지를 변경합니다."""
        name = item.data(Qt.UserRole)
        
        # 해당 페이지 찾아서 이모지 업데이트
        for i, char in enumerate(self.state.characters):
            if char.get("name") == name:
                char["emoji"] = emoji
                
                # 리스트 위젯의 아이템 업데이트
                widget = self.char_list.itemWidget(item)
                if isinstance(widget, PageItemWidget):
                    widget.set_emoji(emoji)
                
                # 상태 저장
                if self.current_book and self.current_book in self.state.books:
                    self.state.books[self.current_book]["pages"] = self.state.characters
                    self.save_to_file()
                break

    def show_book_context_menu(self, position):
        item = self.book_list.itemAt(position)
        if not item:
            return
            
        menu = QMenu()
        # 메뉴 스타일 적용
        menu_style = self.get_menu_style()
        menu.setStyleSheet(menu_style)
        
        # 선택된 아이템들 확인
        selected_items = self.book_list.selectedItems()
        selected_count = len(selected_items)
        
        if selected_count > 1:
            # 다중 선택된 경우
            menu.addAction(f"🔢 선택된 항목: {selected_count}개").setEnabled(False)
            menu.addSeparator()
            
            delete_action = menu.addAction("🗑️ 모두 삭제")
            
            # 메뉴 실행 및 액션 처리
            action = menu.exec(self.book_list.mapToGlobal(position))
            if action == delete_action:
                self.delete_multiple_books(selected_items)
            return
        
        # 단일 선택인 경우 기존 메뉴
        name = item.data(Qt.UserRole)
        is_favorite = False
        
        # 현재 즐겨찾기 상태 확인
        if name in self.state.books:
            is_favorite = self.state.books[name].get("favorite", False)
        
        # 즐겨찾기 액션 추가
        if is_favorite:
            favorite_action = menu.addAction("🖤 즐겨찾기 해제")
        else:
            favorite_action = menu.addAction("❤️ 즐겨찾기")
        
        # 구분선 추가
        menu.addSeparator()
        
        # 클립보드 액션 추가
        paste_action = menu.addAction("📋 붙여넣기")
        # 클립보드에 페이지가 없으면 비활성화
        if not self.clipboard_pages:
            paste_action.setEnabled(False)
        else:
            # 클립보드 정보 표시
            operation_text = "복사" if self.clipboard_operation == "copy" else "잘라내기"
            page_count = len(self.clipboard_pages)
            paste_action.setText(f"📋 붙여넣기 ({operation_text}: {page_count}개)")
        
        # 구분선 추가
        menu.addSeparator()
        
        # 기본 메뉴 항목 추가
        rename_action = menu.addAction("📝 이름 변경")
        delete_action = menu.addAction("🗑️ 북 삭제")
        menu.addSeparator()
        
        # 이모지 변경 서브메뉴
        emoji_menu = QMenu("🔄 이모지 변경")
        emoji_menu.setStyleSheet("""
            QMenu {
                padding: 2px;
            }
            QMenu::item {
                padding: 4px 16px 4px 4px;
                margin: 0px;
            }
            QMenu::item:selected {
                background-color: #505050;
                color: white;
            }
            QMenu::item:hover {
                background-color: #505050;
                color: white;
            }
        """)
        menu.addMenu(emoji_menu)
        
        # 이모지 옵션 그룹화
        emoji_groups = {
            "책": ["📕", "📘", "📙", "📗", "📓", "📔", "📒", "📚", "📖", "📝"],
            "특수": ["🌟", "✨", "🔥", "🎯", "🚀", "🧩", "🎨", "💡", "❤️", "💀"],
            "동물": ["🐉", "🦄", "🐱", "👻", "🍀", "🪐", "😺"],
            "표정": ["😀", "😎", "🥳", "😈", "🤖", "👽", "👾", "🙈"],
            "사람": ["👧", "👩", "🧒", "👸", "💃", "🧝‍♀️", "🧚‍♀️", "🧞‍♀️", "👩‍🎤", "👩‍🔬"]
        }
        
        for group_name, emojis in emoji_groups.items():
            group_menu = QMenu(group_name)
            group_menu.setStyleSheet("""
                QMenu {
                    padding: 2px;
                }
                QMenu::item {
                    padding: 4px 16px 4px 4px;
                    margin: 0px;
                }
                QMenu::item:selected {
                    background-color: #505050;
                    color: white;
                }
                QMenu::item:hover {
                    background-color: #505050;
                    color: white;
                }
            """)
            emoji_menu.addMenu(group_menu)
            for emoji in emojis:
                action = group_menu.addAction(emoji)
                action.triggered.connect(lambda checked, e=emoji, i=item: self.set_book_emoji(i, e))
        
        # 메뉴 실행 및 액션 처리
        action = menu.exec(self.book_list.mapToGlobal(position))
        if action == favorite_action:
            self.toggle_book_favorite(item)
        elif action == paste_action:
            self.paste_pages_from_clipboard(item, show_tooltip=True)
        elif action == rename_action:
            self.rename_book_dialog(item)
        elif action == delete_action:
            self.delete_book(item)
        
    def set_book_emoji(self, item, emoji):
        """북 이모지를 변경합니다."""
        name = item.data(Qt.UserRole)
        
        # 해당 북의 이모지 업데이트
        if name in self.state.books:
            self.state.books[name]["emoji"] = emoji
            
            # 위젯의 이모지 업데이트
            widget = self.book_list.itemWidget(item)
            if isinstance(widget, BookItemWidget):
                widget.set_emoji(emoji)
            
            # 상태 저장
            self.save_to_file()

    def toggle_book_favorite(self, item):
        """북 즐겨찾기 토글 - 사용하지 않음 (BookItemWidget.toggle_favorite 사용)"""
        # 이 메서드는 더 이상 사용하지 않습니다.
        # BookItemWidget.toggle_favorite()에서 모든 처리를 담당합니다.
        pass

    def rename_book_dialog(self, item):
        """북 이름 변경 대화상자"""
        old_name = item.data(Qt.UserRole)
        new_name, ok = QInputDialog.getText(self, "북 이름 변경", "새 이름:", text=old_name)
        
        if ok and new_name.strip():
            new_name = new_name.strip()
            
            # 이름이 변경되지 않은 경우
            if old_name == new_name:
                return
                
            # 이미 존재하는 이름인 경우
            if new_name in self.state.books:
                QMessageBox.warning(self, "이름 변경 실패", "이미 존재하는 북 이름입니다.")
                return
                
            # 북 데이터 이동
            self.state.books[new_name] = self.state.books.pop(old_name)
            if self.current_book == old_name:
                self.current_book = new_name
            
            # 위젯 업데이트
            widget = self.book_list.itemWidget(item)
            if isinstance(widget, BookItemWidget):
                widget.set_name(new_name)
            
            item.setData(Qt.UserRole, new_name)
            self.save_to_file()

    def delete_book(self, item):
        """북 삭제"""
        # 북 이름 가져오기
        if isinstance(item, BookItemWidget):
            book_name = item.book_name
        else:
            widget = self.book_list.itemWidget(item)
            if isinstance(widget, BookItemWidget):
                book_name = widget.book_name
            else:
                return
        
        if not book_name or book_name not in self.state.books:
            return
        
        # 잠긴 페이지가 있는지 확인
        pages = self.state.books[book_name]["pages"]
        for page in pages:
            if page.get('locked', False):
                QMessageBox.warning(
                    self,
                    '북 삭제 불가',
                    f'잠긴 페이지가 있어 삭제할 수 없습니다.',
                    QMessageBox.Ok
                )
                return
        
        # 삭제 전 확인
        reply = QMessageBox.question(
            self,
            '북 삭제',
            f'"{book_name}" 북을 삭제하시겠습니까?',
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            try:
                # 현재 선택된 북이 삭제하려는 북인지 확인
                current_book = None
                if self.book_list.currentItem():
                    widget = self.book_list.itemWidget(self.book_list.currentItem())
                    if isinstance(widget, BookItemWidget):
                        current_book = widget.book_name
                
                # 북의 모든 이미지 파일들을 휴지통으로 이동
                pages = self.state.books[book_name]["pages"]
                deleted_images = []
                for page in pages:
                    image_path = page.get("image_path", "")
                    if image_path and os.path.exists(image_path):
                        try:
                            if send2trash:
                                send2trash(image_path)
                                deleted_images.append(os.path.basename(image_path))
                                print(f"[DEBUG] 이미지 파일을 휴지통으로 이동: {image_path}")
                            else:
                                # send2trash가 없으면 일반 삭제
                                os.remove(image_path)
                                deleted_images.append(os.path.basename(image_path))
                                print(f"[DEBUG] 이미지 파일 삭제: {image_path}")
                        except Exception as e:
                            print(f"[ERROR] 이미지 파일 삭제 실패 {image_path}: {e}")
                
                # 북 삭제
                del self.state.books[book_name]
                row = self.book_list.row(item)
                self.book_list.takeItem(row)
                
                # 삭제된 북이 현재 선택된 북이었다면 UI 초기화
                if current_book == book_name:
                    self.character_list.clear()
                    self.clear_page_list()
                    self.current_book = None
                    self.state.characters = []
                
                # 변경사항 저장
                self.save_to_file()
                self.refresh_book_list()
                
                # 삭제 완료 (알림창 제거)
                
            except Exception as e:
                print(f"[ERROR] 북 삭제 중 오류 발생: {str(e)}")
                QMessageBox.warning(self, '오류', f'북 삭제 중 오류가 발생했습니다.', QMessageBox.Ok)

    def update_image_buttons_state(self):
        # 이미지 불러오기 버튼: 북과 페이지가 선택되어 있을 때 활성화
        page_selected = (self.current_book is not None and 
                        self.current_index >= 0 and 
                        self.current_index < len(self.state.characters))
        self.image_load_btn.setEnabled(page_selected)
        
        # 이미지 제거 버튼: 페이지가 선택되어 있고 이미지가 있을 때만 활성화
        has_image = False
        if page_selected:
            image_path = self.state.characters[self.current_index].get("image_path", "")
            has_image = bool(image_path and os.path.exists(image_path))
        
        self.image_remove_btn.setEnabled(has_image)
        
        # EXIF 체크박스: 이미지가 있을 때만 활성화
        self.exif_checkbox.setEnabled(has_image)
        print(f"[DEBUG] EXIF 체크박스 활성화 상태: {has_image}, 이미지 경로: {image_path if page_selected else '페이지 미선택'}")

    def on_exif_checkbox_changed(self, state):
        """EXIF 체크박스 상태 변경 처리"""
        # 프로그래밍적 변경인 경우 무시
        if hasattr(self, '_exif_programmatic_change') and self._exif_programmatic_change:
            print(f"[DEBUG] EXIF 체크박스 프로그래밍적 변경 무시: {'체크됨' if state == Qt.Checked else '체크 해제'}")
            return
            
        print(f"[DEBUG] EXIF 체크박스 {'체크됨' if state == 2 else '해제됨'}")
        
        if state == 2:  # Qt.Checked 값
            # 체크되었을 때 EXIF 오버레이 표시
            print(f"[DEBUG] EXIF 오버레이 표시 시작")
            print(f"[DEBUG] 현재 인덱스: {self.current_index}, 총 페이지 수: {len(self.state.characters)}")
            
            if (self.current_index >= 0 and 
                self.current_index < len(self.state.characters)):
                image_path = self.state.characters[self.current_index].get("image_path", "")
                print(f"[DEBUG] 이미지 경로: {image_path}")
                
                if image_path and os.path.exists(image_path):
                    print(f"[DEBUG] 이미지 파일 존재 확인됨, EXIF 오버레이 표시 시작")
                    self.image_view.show_exif_overlay(image_path)
                else:
                    if not image_path:
                        print(f"[DEBUG] 이미지 경로가 비어있음")
                    else:
                        print(f"[DEBUG] 이미지 파일이 존재하지 않음: {image_path}")
            else:
                print(f"[DEBUG] 유효하지 않은 페이지 인덱스")
        else:
            # 체크 해제되었을 때 오버레이 숨기기
            print(f"[DEBUG] EXIF 오버레이 숨김")
            self.image_view.hide_exif_overlay()

    def apply_sorting(self):
        from promptbook_features import sort_characters
        self.state.characters = sort_characters(self.state.characters, self.sort_selector.currentText())
        self.refresh_character_list()

    def handle_book_sort(self):
        mode = self.book_sort_selector.currentText()
        print(f"[DEBUG] 북 정렬 모드: {mode}")

        if mode == "커스텀 정렬":
            self.book_sort_custom = True
            self.book_list.setDragDropMode(QAbstractItemView.InternalMove)
            self.book_list.setDefaultDropAction(Qt.MoveAction)
        else:
            self.book_sort_custom = False
            self.book_list.setDragDropMode(QAbstractItemView.NoDragDrop)
            
            # 북 목록 정렬
            items = []
            for i in range(self.book_list.count()):
                item = self.book_list.item(i)
                widget = self.book_list.itemWidget(item)
                if isinstance(widget, BookItemWidget):
                    name = widget.book_name
                    emoji = widget.book_label.text()
                    items.append((name, emoji, item.data(Qt.UserRole)))
            
            # 정렬 (즐겨찾기 우선, 그 다음 이름순)
            def sort_key(item):
                name = item[0]
                is_favorite = self.state.books[name].get("favorite", False)
                return (not is_favorite, name.lower())  # 즐겨찾기가 먼저 오도록
            
            items.sort(key=sort_key, reverse=(mode == "내림차순 정렬"))
            
            # 리스트 업데이트
            self.book_list.clear()
            for name, emoji, user_data in items:
                item = QListWidgetItem()
                
                # 커스텀 위젯 생성
                is_favorite = self.state.books[name].get("favorite", False)
                widget = BookItemWidget(name, is_favorite, emoji)
                item.setData(Qt.UserRole, user_data)
                
                self.book_list.addItem(item)
                self.book_list.setItemWidget(item, widget)
                item.setSizeHint(widget.sizeHint())
        
        # UI 설정 저장
        self.save_ui_settings()

    def remove_preview_image(self):
        if 0 <= self.current_index < len(self.state.characters):
            # 현재 이미지 파일 경로 가져오기
            image_path = self.state.characters[self.current_index].get("image_path", "")
            
            # 이미지 파일을 휴지통으로 이동
            if image_path and os.path.exists(image_path):
                try:
                    if send2trash:
                        send2trash(image_path)
                        print(f"[DEBUG] 이미지 파일을 휴지통으로 이동: {image_path}")
                    else:
                        # send2trash가 없으면 일반 삭제
                        os.remove(image_path)
                        print(f"[DEBUG] 이미지 파일 삭제: {image_path}")
                except Exception as e:
                    print(f"[ERROR] 이미지 파일 삭제 실패: {e}")
            
            # 데이터에서 이미지 경로 제거
            self.state.characters[self.current_index]["image_path"] = ""
            if self.current_book and self.current_book in self.state.books:
                self.state.books[self.current_book]["pages"] = self.state.characters
            self.image_scene.clear()
            self.image_view.update_drop_hint_visibility()
            
            # 버튼 상태 업데이트
            self.update_image_buttons_state()
            
            self.save_to_file()
    
    def delete_focused_item(self):
        """현재 포커스된 리스트에 따라 북 또는 페이지 삭제 (다중 선택 지원)"""
        # 현재 포커스된 위젯 확인
        focused_widget = QApplication.focusWidget()
        
        # 북 리스트에 포커스가 있는 경우
        if focused_widget == self.book_list or self.book_list.isAncestorOf(focused_widget):
            selected_items = self.book_list.selectedItems()
            if selected_items:
                self.delete_multiple_books(selected_items)
        
        # 페이지 리스트에 포커스가 있는 경우
        elif focused_widget == self.char_list or self.char_list.isAncestorOf(focused_widget):
            selected_items = self.char_list.selectedItems()
            if selected_items:
                self.delete_multiple_characters(selected_items)
        
        # 다른 위젯에 포커스가 있어도 페이지가 선택되어 있으면 페이지 삭제
        elif self.current_index >= 0:
            self.delete_selected_character()
    
    def delete_multiple_books(self, selected_items):
        """선택된 여러 북을 삭제합니다."""
        if not selected_items:
            return
            
        book_names = []
        for item in selected_items:
            name = item.data(Qt.UserRole)
            if name:
                book_names.append(name)
        
        if not book_names:
            return
        
        # 잠긴 페이지가 있는 북 검사
        books_with_locked_pages = []
        for book_name in book_names:
            if book_name in self.state.books:
                pages = self.state.books[book_name].get("pages", [])
                locked_pages = [page.get("name", "") for page in pages if page.get("locked", False)]
                if locked_pages:
                    books_with_locked_pages.append((book_name, locked_pages))
        
        # 잠긴 페이지가 있는 북이 있으면 경고
        if books_with_locked_pages:
            warning_message = "다음 북들에는 잠긴 페이지가 있어 삭제할 수 없습니다:\n\n"
            for book_name, locked_pages in books_with_locked_pages:
                warning_message += f"📕 {book_name}:\n"
                for page_name in locked_pages:
                    warning_message += f"  🔒 {page_name}\n"
            warning_message += "\n잠긴 페이지들의 잠금을 해제한 후 다시 시도해주세요."
            
            QMessageBox.warning(
                self,
                "북 삭제 불가",
                warning_message
            )
            return
        
        # 삭제 확인 대화상자
        count = len(book_names)
        if count == 1:
            message = f"'{book_names[0]}' 북을 삭제하시겠습니까?"
        else:
            message = f"선택된 {count}개의 북을 삭제하시겠습니까?"
        
        reply = QMessageBox.question(
            self, 
            "북 삭제 확인",
            f"{message}\n이 작업은 되돌릴 수 없습니다.",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.Yes  # Enter 키로 삭제 확인 가능
        )
        
        if reply == QMessageBox.Yes:
            # 현재 선택된 북이 삭제 목록에 있는지 확인
            current_book_deleted = self.current_book in book_names
            
            # 모든 북의 이미지 파일들을 휴지통으로 이동
            total_deleted_images = 0
            for name in book_names:
                if name in self.state.books:
                    pages = self.state.books[name]["pages"]
                    for page in pages:
                        image_path = page.get("image_path", "")
                        if image_path and os.path.exists(image_path):
                            try:
                                if send2trash:
                                    send2trash(image_path)
                                    total_deleted_images += 1
                                    print(f"[DEBUG] 이미지 파일을 휴지통으로 이동: {image_path}")
                                else:
                                    # send2trash가 없으면 일반 삭제
                                    os.remove(image_path)
                                    total_deleted_images += 1
                                    print(f"[DEBUG] 이미지 파일 삭제: {image_path}")
                            except Exception as e:
                                print(f"[ERROR] 이미지 파일 삭제 실패 {image_path}: {e}")
            
            # 북들 삭제
            for name in book_names:
                if name in self.state.books:
                    del self.state.books[name]
            
            # 리스트에서 아이템들 제거
            for item in selected_items:
                row = self.book_list.row(item)
                self.book_list.takeItem(row)
            
            # 현재 선택된 북이 삭제된 경우 상태 초기화
            if current_book_deleted:
                self.current_book = None
                self.state.characters = []
                self.char_list.clear()
                if hasattr(self, 'name_input'):
                    self.name_input.clear()
                if hasattr(self, 'tag_input'):
                    self.tag_input.clear()
                if hasattr(self, 'desc_input'):
                    self.desc_input.clear()
                if hasattr(self, 'prompt_input'):
                    self.prompt_input.clear()
                self.image_scene.clear()
            
            # UI 상태 업데이트
            self.update_all_buttons_state()
            self.save_to_file()
            
            # 다른 북이 있고 현재 북이 삭제되었다면 첫 번째 북 선택
            if current_book_deleted and self.book_list.count() > 0:
                self.book_list.setCurrentRow(0)
                self.on_book_selected(0)
            
            # 삭제 완료 메시지 (이미지 개수 포함)
            # 삭제 완료 (알림창 제거)
    
    def delete_multiple_characters(self, selected_items):
        """선택된 여러 페이지를 삭제합니다."""
        if not selected_items:
            return
            
        page_names = []
        locked_pages = []
        
        for item in selected_items:
            name = item.data(Qt.UserRole)
            if name:
                # 해당 페이지 찾기
                for char in self.state.characters:
                    if char.get("name") == name:
                        if char.get('locked', False):
                            locked_pages.append(name)
                        else:
                            page_names.append(name)
                        break
        
        # 잠금된 페이지가 있으면 경고
        if locked_pages:
            locked_names = ", ".join(locked_pages)
            if page_names:
                reply = QMessageBox.question(
                    self,
                    "일부 삭제 불가",
                    f"다음 페이지들은 잠금되어 있어 삭제할 수 없습니다:\n{locked_names}\n\n나머지 페이지들만 삭제하시겠습니까?",
                    QMessageBox.Yes | QMessageBox.No,
                    QMessageBox.No
                )
                if reply != QMessageBox.Yes:
                    return
            else:
                QMessageBox.warning(
                    self,
                    "삭제 불가",
                    f"선택된 모든 페이지가 잠금되어 있습니다:\n{locked_names}\n\n잠금을 해제한 후 다시 시도해주세요."
                )
                return
        
        if not page_names:
            return
        
        # 삭제 확인 대화상자
        count = len(page_names)
        if count == 1:
            message = f"'{page_names[0]}' 페이지를 삭제하시겠습니까?"
        else:
            message = f"선택된 {count}개의 페이지를 삭제하시겠습니까?"
        
        reply = QMessageBox.question(
            self, 
            "페이지 삭제 확인",
            f"{message}\n이 작업은 되돌릴 수 없습니다.",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.Yes  # Enter 키로 삭제 확인 가능
        )
        
        if reply == QMessageBox.Yes:
            # 페이지들 삭제 (역순으로 삭제하여 인덱스 문제 방지)
            pages_to_delete = []
            for i, char in enumerate(self.state.characters):
                if char.get("name") in page_names:
                    pages_to_delete.append(i)
                    
                    # 이미지 파일을 휴지통으로 이동
                    image_path = char.get("image_path")
                    if image_path and os.path.exists(image_path):
                        try:
                            if send2trash:
                                send2trash(image_path)
                                print(f"[DEBUG] 이미지 파일을 휴지통으로 이동: {image_path}")
                            else:
                                # send2trash가 없으면 일반 삭제
                                os.remove(image_path)
                                print(f"[DEBUG] 이미지 파일 삭제: {image_path}")
                        except Exception as e:
                            print(f"[ERROR] 이미지 파일 삭제 실패: {e}")
            
            # 역순으로 삭제
            for i in reversed(pages_to_delete):
                del self.state.characters[i]
            
            # 상태 업데이트
            if self.current_book and self.current_book in self.state.books:
                self.state.books[self.current_book]["pages"] = self.state.characters
            
            # 삭제 후 빈 페이지 상태로 설정
            self.current_index = -1
            self.name_input.clear()
            self.tag_input.clear()
            self.desc_input.clear()
            self.prompt_input.clear()
            self.image_scene.clear()
            self.image_view.drop_hint.setVisible(True)
            
            # UI 업데이트 (선택 해제)
            self.refresh_character_list()
            self.char_list.clearSelection()
            
            self.save_to_file()

    def duplicate_selected_character(self):
        if not self.current_book or self.current_index < 0:
            return
            
        # 현재 선택된 페이지 데이터 복사
        original_data = self.state.characters[self.current_index].copy()
        
        # 이름 중복 방지
        base_name = original_data["name"]
        existing_names = {char["name"] for char in self.state.characters}
        
        # 기존 넘버링 제거하고 베이스 이름 추출 (예: "캐릭터 (1)" -> "캐릭터")
        original_base_name = re.sub(r' \(\d+\)$', '', base_name)
        
        # 새 이름 생성 (예: "캐릭터" -> "캐릭터 (1)")
        for i in range(1, 1000):
            candidate = f"{original_base_name} ({i})"
            if candidate not in existing_names:
                base_name = candidate
                break
                    
        # 새 데이터 생성
        new_data = original_data.copy()
        new_data["name"] = base_name
        
        # 이미지가 있는 경우 복사
        if "image_path" in original_data and os.path.exists(original_data["image_path"]):
            original_path = original_data["image_path"]
            file_name, ext = os.path.splitext(os.path.basename(original_path))
            
            # 기존 넘버링 제거 (예: _0001, _0002 등)
            base_file_name = re.sub(r'_\d{4}$', '', file_name)
            
            # 새로운 파일명 생성 (_0001, _0002, _0003 형식)
            counter = 1
            while True:
                new_file_name = f"{base_file_name}_{counter:04d}{ext}"
                new_path = os.path.join(os.path.dirname(original_path), new_file_name)
                if not os.path.exists(new_path):
                    break
                counter += 1
            
            try:
                shutil.copy2(original_path, new_path)
                new_data["image_path"] = new_path
            except Exception as e:
                print(f"이미지 복사 실패: {e}")
                new_data["image_path"] = ""
        
        # 새 페이지 추가
        self.state.characters.append(new_data)
        
        # 정렬 모드가 커스텀이 아닌 경우 정렬 적용
        if not self.sort_mode_custom:
            from promptbook_features import sort_characters
            self.state.characters = sort_characters(self.state.characters, self.sort_selector.currentText())
        
        # 상태 업데이트 및 저장
        if self.current_book and self.current_book in self.state.books:
            self.state.books[self.current_book]["pages"] = self.state.characters
        self.refresh_character_list(selected_name=base_name)
        self.save_to_file()
    
    def duplicate_focused_characters(self):
        """포커스된 리스트의 선택된 페이지들을 복제합니다."""
        # 현재 포커스된 위젯 확인
        focused_widget = QApplication.focusWidget()
        
        # 페이지 리스트에 포커스가 있는 경우만 복제
        if focused_widget == self.char_list or self.char_list.isAncestorOf(focused_widget):
            selected_items = self.char_list.selectedItems()
            if selected_items:
                self.duplicate_multiple_characters(selected_items)
        else:
            # 다른 위젯에 포커스가 있으면 기존 단일 복제 방식 사용
            self.duplicate_selected_character()
    
    def duplicate_multiple_characters(self, selected_items):
        """선택된 여러 페이지를 복제합니다."""
        if not selected_items or not self.current_book:
            return
            
        page_names = []
        for item in selected_items:
            name = item.data(Qt.UserRole)
            if name:
                page_names.append(name)
        
        if not page_names:
            return
            
        # 복제할 페이지 데이터들 수집
        pages_to_duplicate = []
        for char in self.state.characters:
            if char.get("name") in page_names:
                pages_to_duplicate.append(char.copy())
        
        if not pages_to_duplicate:
            return
            
        # 기존 페이지 이름들 수집 (중복 방지용)
        existing_names = {char["name"] for char in self.state.characters}
        
        # 새로 생성될 페이지들
        new_pages = []
        
        for original_data in pages_to_duplicate:
            # 이름 중복 방지
            base_name = original_data["name"]
            
            # 기존 넘버링 제거하고 베이스 이름 추출 (예: "캐릭터 (1)" -> "캐릭터")
            original_base_name = re.sub(r' \(\d+\)$', '', base_name)
            
            # 새 이름 생성
            for i in range(1, 1000):
                candidate = f"{original_base_name} ({i})"
                if candidate not in existing_names:
                    base_name = candidate
                    existing_names.add(candidate)  # 중복 방지용 세트에 추가
                    break
                    
            # 새 데이터 생성
            new_data = original_data.copy()
            new_data["name"] = base_name
            
            # 이미지가 있는 경우 복사
            if "image_path" in original_data and os.path.exists(original_data["image_path"]):
                original_path = original_data["image_path"]
                file_name, ext = os.path.splitext(os.path.basename(original_path))
                
                # 기존 넘버링 제거 (예: _0001, _0002 등)
                base_file_name = re.sub(r'_\d{4}$', '', file_name)
                
                # 새로운 파일명 생성 (_0001, _0002, _0003 형식)
                counter = 1
                while True:
                    new_file_name = f"{base_file_name}_{counter:04d}{ext}"
                    new_path = os.path.join(os.path.dirname(original_path), new_file_name)
                    if not os.path.exists(new_path):
                        break
                    counter += 1
                
                try:
                    shutil.copy2(original_path, new_path)
                    new_data["image_path"] = new_path
                except Exception as e:
                    print(f"이미지 복사 실패: {e}")
                    new_data["image_path"] = ""
            
            new_pages.append(new_data)
        
        # 새 페이지들 추가
        self.state.characters.extend(new_pages)
        
        # 정렬 모드가 커스텀이 아닌 경우 정렬 적용
        if not self.sort_mode_custom:
            from promptbook_features import sort_characters
            self.state.characters = sort_characters(self.state.characters, self.sort_selector.currentText())
        
        # 상태 업데이트 및 저장
        if self.current_book and self.current_book in self.state.books:
            self.state.books[self.current_book]["pages"] = self.state.characters
        
        # 복제된 페이지가 하나인 경우 해당 페이지 선택, 여러 개인 경우 마지막 페이지 선택
        if new_pages:
            selected_name = new_pages[-1]["name"]  # 마지막으로 복제된 페이지 선택
            self.refresh_character_list(selected_name=selected_name)
        else:
            self.refresh_character_list()
            
        self.save_to_file()
        
        # 복제 완료 메시지
        count = len(new_pages)
        if count == 1:
            message = "1개 페이지가 복제되었습니다."
        else:
            message = f"{count}개 페이지가 복제되었습니다."
        
        if hasattr(self, 'duplicate_button'):
            QToolTip.showText(
                self.duplicate_button.mapToGlobal(self.duplicate_button.rect().center()), 
                message
            )

    def delete_selected_character(self):
        if not self.current_book or self.current_index < 0:
            return
            
        # 잠금 상태 확인
        if self.state.characters[self.current_index].get('locked', False):
            QMessageBox.warning(
                self,
                "삭제 불가",
                "잠금된 페이지는 삭제할 수 없습니다.\n잠금을 해제한 후 다시 시도해주세요."
            )
            return
            
        # 삭제 확인 대화상자
        reply = QMessageBox.question(
            self, 
            "페이지 삭제 확인",
            "현재 페이지를 삭제하시겠습니까?\n이 작업은 되돌릴 수 없습니다.",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            # 이미지 파일이 있다면 휴지통으로 이동
            if "image_path" in self.state.characters[self.current_index]:
                image_path = self.state.characters[self.current_index]["image_path"]
                if os.path.exists(image_path):
                    try:
                        if send2trash:
                            send2trash(image_path)
                            print(f"[DEBUG] 이미지 파일을 휴지통으로 이동: {image_path}")
                        else:
                            # send2trash가 없으면 일반 삭제
                            os.remove(image_path)
                            print(f"[DEBUG] 이미지 파일 삭제: {image_path}")
                    except Exception as e:
                        print(f"[ERROR] 이미지 파일 삭제 실패: {e}")
            
            # 페이지 삭제
            del self.state.characters[self.current_index]
            if self.current_book and self.current_book in self.state.books:
                self.state.books[self.current_book]["pages"] = self.state.characters
            
            # 삭제 후 빈 페이지 상태로 설정
            self.current_index = -1
            self.name_input.clear()
            self.tag_input.clear()
            self.desc_input.clear()
            self.prompt_input.clear()
            self.image_scene.clear()
            self.image_view.drop_hint.setVisible(True)
            
            # UI 업데이트 (선택 해제)
            self.refresh_character_list()
            self.char_list.clearSelection()
            
            self.save_to_file()
    
    def rename_focused_item(self):
        """현재 포커스된 리스트에 따라 북 또는 페이지 이름 변경"""
        # 현재 포커스된 위젯 확인
        focused_widget = QApplication.focusWidget()
        
        # 북 리스트에 포커스가 있는 경우
        if focused_widget == self.book_list or self.book_list.isAncestorOf(focused_widget):
            current_item = self.book_list.currentItem()
            if current_item:
                self.rename_book_dialog(current_item)
        
        # 페이지 리스트에 포커스가 있는 경우
        elif focused_widget == self.char_list or self.char_list.isAncestorOf(focused_widget):
            current_item = self.char_list.currentItem()
            if current_item:
                self.rename_character_dialog(current_item)
    
    def rename_character_dialog(self, item):
        """페이지 이름 변경 대화상자"""
        old_name = item.data(Qt.UserRole)
        if not old_name:
            return
            
        new_name, ok = QInputDialog.getText(
            self, 
            "페이지 이름 변경", 
            "새 이름을 입력하세요:", 
            text=old_name
        )
        
        if ok and new_name and new_name != old_name:
            # 중복 이름 확인
            existing_names = {char["name"] for char in self.state.characters if char["name"] != old_name}
            if new_name in existing_names:
                QMessageBox.warning(self, "이름 중복", "이미 존재하는 페이지 이름입니다.")
                return
            
            # 페이지 데이터 업데이트
            for char in self.state.characters:
                if char["name"] == old_name:
                    char["name"] = new_name
                    break
            
            # UI 업데이트
            self.refresh_character_list(selected_name=new_name)
            self.save_to_file()
    
    def handle_book_reorder(self):
        """북 순서 변경 처리"""
        print("[DEBUG] handle_book_reorder 호출됨")
        self.book_sort_custom = True
        
        # 새로운 북 순서 생성
        new_book_order = {}
        for i in range(self.book_list.count()):
            item = self.book_list.item(i)
            book_name = item.data(Qt.UserRole)
            if book_name in self.state.books:
                new_book_order[book_name] = self.state.books[book_name]
        
        # 순서 업데이트
        self.state.books = new_book_order
        print("[DEBUG] 새로운 북 순서로 저장됨")
        self.save_to_file()

    def copy_pages_to_clipboard(self, show_tooltip=False):
        """선택된 페이지들을 클립보드에 복사"""
        selected_items = self.char_list.selectedItems()
        if not selected_items:
            return
        
        # 선택된 페이지들의 데이터 수집
        self.clipboard_pages = []
        for item in selected_items:
            page_name = item.data(Qt.UserRole)
            for char in self.state.characters:
                if char.get("name") == page_name:
                    # 페이지 데이터의 복사본 생성
                    page_copy = char.copy()
                    self.clipboard_pages.append(page_copy)
                    break
        
        self.clipboard_operation = "copy"
        self.clipboard_source_book = self.current_book
        
        # 툴팁 표시 (컨텍스트 메뉴에서 호출된 경우)
        if show_tooltip:
            QToolTip.showText(
                self.char_list.mapToGlobal(self.char_list.rect().center()),
                f"📋 {len(selected_items)}개 페이지가 복사되었습니다"
            )

    def cut_pages_to_clipboard(self, show_tooltip=False):
        """선택된 페이지들을 클립보드에 잘라내기"""
        selected_items = self.char_list.selectedItems()
        if not selected_items:
            return
        
        # 잠긴 페이지가 있는지 확인
        locked_pages = []
        for item in selected_items:
            page_name = item.data(Qt.UserRole)
            for char in self.state.characters:
                if char.get("name") == page_name and char.get("locked", False):
                    locked_pages.append(page_name)
        
        # 잠긴 페이지가 있으면 경고 표시하고 중단
        if locked_pages:
            if show_tooltip:
                QToolTip.showText(
                    self.char_list.mapToGlobal(self.char_list.rect().center()),
                    f"⚠️ 잠긴 페이지는 잘라낼 수 없습니다: {', '.join(locked_pages)}"
                )
            else:
                QMessageBox.warning(self, "잘라내기 실패", f"잠긴 페이지는 잘라낼 수 없습니다:\n{', '.join(locked_pages)}")
            return
        
        # 선택된 페이지들의 데이터 수집
        self.clipboard_pages = []
        for item in selected_items:
            page_name = item.data(Qt.UserRole)
            for char in self.state.characters:
                if char.get("name") == page_name:
                    # 페이지 데이터의 복사본 생성
                    page_copy = char.copy()
                    self.clipboard_pages.append(page_copy)
                    break
        
        self.clipboard_operation = "cut"
        self.clipboard_source_book = self.current_book
        
        # 툴팁 표시 (컨텍스트 메뉴에서 호출된 경우)
        if show_tooltip:
            QToolTip.showText(
                self.char_list.mapToGlobal(self.char_list.rect().center()),
                f"✂️ {len(selected_items)}개 페이지가 잘라내기되었습니다"
            )

    def paste_pages_from_clipboard(self, book_item, show_tooltip=False):
        """클립보드의 페이지들을 지정된 북에 붙여넣기"""
        if not self.clipboard_pages:
            return
        
        # 대상 북 이름 가져오기
        target_book_name = book_item.data(Qt.UserRole)
        if not target_book_name or target_book_name not in self.state.books:
            return
        
        # 대상 북의 페이지들 가져오기
        target_pages = self.state.books[target_book_name]["pages"]
        existing_names = {page["name"] for page in target_pages}
        
        # 페이지 붙여넣기
        pasted_count = 0
        for page_data in self.clipboard_pages:
            # 중복 이름 처리
            original_name = page_data["name"]
            new_name = original_name
            counter = 1
            while new_name in existing_names:
                new_name = f"{original_name} ({counter})"
                counter += 1
            
            # 페이지 데이터 복사 및 이름 업데이트
            new_page = page_data.copy()
            new_page["name"] = new_name
            
            # 대상 북에 추가
            target_pages.append(new_page)
            existing_names.add(new_name)
            pasted_count += 1
        
        # 잘라내기인 경우 원본 페이지들 삭제
        if self.clipboard_operation == "cut" and self.clipboard_source_book:
            if self.clipboard_source_book in self.state.books:
                source_pages = self.state.books[self.clipboard_source_book]["pages"]
                clipboard_names = {page["name"] for page in self.clipboard_pages}
                
                # 역순으로 삭제 (인덱스 변화 방지)
                for i in range(len(source_pages) - 1, -1, -1):
                    if source_pages[i]["name"] in clipboard_names:
                        del source_pages[i]
                
                # 소스 북이 현재 선택된 북이면 UI 업데이트
                if self.clipboard_source_book == self.current_book:
                    self.refresh_character_list()
        
        # 대상 북이 현재 선택된 북이면 UI 업데이트
        if target_book_name == self.current_book:
            self.refresh_character_list()
        
        # 데이터 저장
        self.save_to_file()
        
        # 툴팁 표시 (컨텍스트 메뉴에서 호출된 경우)
        if show_tooltip:
            operation_text = "복사" if self.clipboard_operation == "copy" else "잘라내기"
            QToolTip.showText(
                self.book_list.mapToGlobal(self.book_list.rect().center()),
                f"📋 {operation_text}된 {pasted_count}개 페이지가 '{target_book_name}' 북에 붙여넣기되었습니다"
            )
        
        # 잘라내기인 경우 클립보드 초기화
        if self.clipboard_operation == "cut":
            self.clipboard_pages = []
            self.clipboard_operation = None
            self.clipboard_source_book = None

    def handle_copy_shortcut(self):
        """Ctrl+C 단축키 처리 - 페이지 복사"""
        # 페이지 리스트에 포커스가 있고 선택된 페이지가 있는 경우에만 실행
        if self.char_list.hasFocus() and self.char_list.selectedItems():
            selected_count = len(self.char_list.selectedItems())
            self.copy_pages_to_clipboard()
            
            # 툴팁 표시
            QToolTip.showText(
                self.char_list.mapToGlobal(self.char_list.rect().center()),
                f"📋 {selected_count}개 페이지가 복사되었습니다"
            )
            print(f"[DEBUG] Ctrl+C: {selected_count}개 페이지 복사됨")

    def handle_cut_shortcut(self):
        """Ctrl+X 단축키 처리 - 페이지 잘라내기"""
        # 페이지 리스트에 포커스가 있고 선택된 페이지가 있는 경우에만 실행
        if self.char_list.hasFocus() and self.char_list.selectedItems():
            selected_count = len(self.char_list.selectedItems())
            
            # 잠긴 페이지가 있는지 미리 확인
            locked_pages = []
            for item in self.char_list.selectedItems():
                page_name = item.data(Qt.UserRole)
                for char in self.state.characters:
                    if char.get("name") == page_name and char.get("locked", False):
                        locked_pages.append(page_name)
            
            if locked_pages:
                # 잠긴 페이지가 있으면 툴팁으로 경고 표시
                QToolTip.showText(
                    self.char_list.mapToGlobal(self.char_list.rect().center()),
                    f"⚠️ 잠긴 페이지는 잘라낼 수 없습니다: {', '.join(locked_pages)}"
                )
                return
            
            self.cut_pages_to_clipboard()
            
            # 툴팁 표시
            QToolTip.showText(
                self.char_list.mapToGlobal(self.char_list.rect().center()),
                f"✂️ {selected_count}개 페이지가 잘라내기되었습니다"
            )
            print(f"[DEBUG] Ctrl+X: {selected_count}개 페이지 잘라내기됨")

    def handle_paste_shortcut(self):
        """Ctrl+V 단축키 처리 - 페이지 붙여넣기"""
        # 북 리스트에 포커스가 있고 선택된 북이 있으며 클립보드에 페이지가 있는 경우에만 실행
        if (self.book_list.hasFocus() and 
            self.book_list.selectedItems() and 
            self.clipboard_pages):
            
            selected_book_item = self.book_list.selectedItems()[0]
            book_name = selected_book_item.data(Qt.UserRole)
            page_count = len(self.clipboard_pages)
            operation_text = "복사" if self.clipboard_operation == "copy" else "잘라내기"
            
            self.paste_pages_from_clipboard(selected_book_item)
            
            # 툴팁 표시
            QToolTip.showText(
                self.book_list.mapToGlobal(self.book_list.rect().center()),
                f"📋 {operation_text}된 {page_count}개 페이지가 '{book_name}' 북에 붙여넣기되었습니다"
            )
            print(f"[DEBUG] Ctrl+V: {page_count}개 페이지 붙여넣기됨")
        elif self.book_list.hasFocus() and self.book_list.selectedItems() and not self.clipboard_pages:
            # 클립보드가 비어있는 경우
            QToolTip.showText(
                self.book_list.mapToGlobal(self.book_list.rect().center()),
                "📋 클립보드가 비어있습니다"
            )
        elif self.book_list.hasFocus() and not self.book_list.selectedItems():
            # 북이 선택되지 않은 경우
            QToolTip.showText(
                self.book_list.mapToGlobal(self.book_list.rect().center()),
                "📚 붙여넣을 북을 선택해주세요"
            )

    def apply_theme(self, theme_name):
        """테마를 적용합니다."""
        if theme_name not in self.THEMES:
            return
        
        # 커스텀 테마에서 다른 테마로 변경할 때 처리 (current_theme 변경 전에 체크)
        print(f"[DEBUG] 현재 테마: {getattr(self, 'current_theme', 'None')}, 새 테마: {theme_name}")
        if hasattr(self, 'current_theme') and self.current_theme == "커스텀 테마" and theme_name != "커스텀 테마":
            print(f"[DEBUG] 커스텀 테마에서 일반 테마로 변경 감지됨")
            # 커스텀 테마에서 일반 테마로 변경 시 재시작 확인
            from PySide6.QtWidgets import QMessageBox
            
            msg_box = QMessageBox(self)
            msg_box.setWindowTitle("프로그램 재시작 필요")
            msg_box.setText("커스텀 테마에서 일반 테마로 변경하려면 프로그램을 재시작해야 합니다.")
            msg_box.setInformativeText("지금 재시작하시겠습니까?\n\n재시작하지 않으면 테마 변경이 취소됩니다.")
            msg_box.setIcon(QMessageBox.Question)
            
            restart_btn = msg_box.addButton("재시작", QMessageBox.AcceptRole)
            cancel_btn = msg_box.addButton("취소", QMessageBox.RejectRole)
            
            msg_box.exec()
            
            if msg_box.clickedButton() == restart_btn:
                # 새 테마 설정 저장
                self.current_theme = theme_name
                self.custom_background_image = None  # 커스텀 배경 제거
                self.save_ui_settings()
                
                # 프로그램 재시작
                import sys
                import os
                import subprocess
                
                script_path = os.path.abspath(sys.argv[0])
                subprocess.Popen([sys.executable, script_path])
                self.close()
                return
            else:
                # 취소한 경우 커스텀 테마로 되돌리기
                for action in self.theme_group.actions():
                    if "커스텀 테마" in action.text():
                        action.setChecked(True)
                        break
                return
            
        self.current_theme = theme_name
        theme = self.THEMES[theme_name]
        
        # 커스텀 테마가 아닌 경우 배경 이미지 초기화
        # 스타일시트 초기화
        style = ""
        if theme_name != "커스텀 테마":
            self.custom_background_image = None
        
            # 전체 애플리케이션 스타일시트 적용
            style = f"""
            QMainWindow {{
                background-color: {theme['background']};
                color: {theme['text']};
                border: 2px solid {theme['border']};
                border-radius: 12px;
            }}
            
            QWidget {{
                background-color: {theme['background']};
                color: {theme['text']};
            }}
            
            QLabel {{
                color: {theme['text']};
                background-color: transparent;
            }}
            
            QLineEdit, CustomLineEdit {{
                background-color: {theme['surface']};
                border: 1px solid {theme['border']};
                color: {theme['text']};
                padding: 4px;
                border-radius: 3px;
            }}
            
            QLineEdit:focus, CustomLineEdit:focus {{
                border: 2px solid {theme['primary']};
            }}
            
            QTextEdit {{
                background-color: {theme['surface']};
                border: 1px solid {theme['border']};
                color: {theme['text']};
                padding: 4px;
                border-radius: 3px;
            }}
            
            QTextEdit:focus {{
                border: 2px solid {theme['primary']};
            }}
            
            QPushButton {{
                background-color: {theme['button']};
                border: 1px solid {theme['border']};
                color: {theme['text']};
                padding: 6px 12px;
                border-radius: 3px;
                font-weight: bold;
            }}
            
            QPushButton:hover {{
                background-color: {theme['button_hover']};
                border: 1px solid {theme['primary']};
                color: {theme['primary']};
            }}
            
            QPushButton:pressed {{
                background-color: {theme['primary']};
                color: {theme['background']};
            }}
            
            QPushButton:disabled {{
                background-color: {theme['surface']};
                color: {theme['text_secondary']};
            }}
            
            QListWidget {{
                background-color: {theme['surface']};
                border: 1px solid {theme['border']};
                color: {theme['text']};
                outline: none;
                border-radius: 3px;
            }}
            
            QListWidget::item {{
                background-color: transparent;
                border: none;
                padding: 2px;
            }}
            
            QListWidget::item:selected {{
                background-color: {theme['selected']};
                color: white;
            }}
            
            QGraphicsView {{
                background-color: {theme['surface']};
                border: 1px solid {theme['border']};
                border-radius: 3px;
            }}"""
            
            # 네온 테마용 특별 효과
            if theme_name in ["블루 네온", "핑크 네온"]:
                # 네온 윈도우 테두리
                style = style.replace(
                    f"border: 2px solid {theme['border']};",
                    f"border: 3px solid {theme['primary']};"
                )
                
                # 네온 타이틀 바 스타일
                title_bar_style = f"""
                QWidget#titleBar {{
                    background-color: {theme['background']};
                    border-bottom: 3px solid {theme['primary']};
                    border-top-left-radius: 10px;
                    border-top-right-radius: 10px;
                }}
                
                QLabel#titleLabel {{
                    color: {theme['primary']};
                    background-color: transparent;
                    font-weight: bold;
                    font-size: 14px;
                }}
                """
                
                style += title_bar_style
                style += f"""
            QPushButton {{
                background-color: {theme['button']};
                border: 3px solid {theme['primary']};
                color: {theme['text']};
                padding: 6px 12px;
                border-radius: 5px;
                font-weight: bold;
            }}
            
            QPushButton:hover {{
                background-color: {theme['button_hover']};
                border: 3px solid {theme['primary']};
                color: {theme['primary']};
            }}
            
            QPushButton:pressed {{
                background-color: {theme['primary']};
                color: black;
                border: 3px solid {theme['primary']};
            }}
            
            QListWidget::item:selected {{
                background-color: {theme['selected']};
                color: black;
                border: 2px solid {theme['primary']};
                font-weight: bold;
            }}
            
            QLineEdit, QTextEdit, CustomLineEdit {{
                background-color: {theme['button']};
                border: 2px solid {theme['border']};
                color: {theme['text']};
                padding: 4px;
                border-radius: 3px;
            }}
            
            QLineEdit:focus, QTextEdit:focus, CustomLineEdit:focus {{
                border: 3px solid {theme['primary']};
                background-color: {theme['button']};
            }}
            
            QPushButton:disabled {{
                background-color: {theme['background']};
                border: 1px solid #333333;
                color: #555555;
                font-weight: normal;
            }}
            
            QSplitter::handle:horizontal {{
                width: 10px;
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {theme['background']}, 
                    stop:0.5 {theme['primary']}, 
                    stop:1 {theme['background']});
                border: 2px solid {theme['primary']};
            }}
            
            QSplitter::handle:horizontal:hover {{
                background: {theme['primary']};
                border: 2px solid {theme['primary']};
            }}
            
            QSplitter::handle:vertical {{
                height: 10px;
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                    stop:0 {theme['background']}, 
                    stop:0.5 {theme['primary']}, 
                    stop:1 {theme['background']});
                border: 2px solid {theme['primary']};
            }}
            
            QSplitter::handle:vertical:hover {{
                background: {theme['primary']};
                border: 2px solid {theme['primary']};
        }}"""
        
        style += """
        
        QListWidget::item:hover {{
            background-color: {theme['hover']};
        }}
        
        QComboBox {{
            background-color: {theme['button']};
            border: 1px solid {theme['border']};
            color: {theme['text']};
            padding: 4px 8px;
            border-radius: 3px;
        }}
        
        QComboBox:hover {{
            background-color: {theme['hover']};
        }}
        
        QComboBox::drop-down {{
            border: none;
            width: 20px;
        }}
        
        QComboBox::down-arrow {{
            image: none;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-top: 6px solid {theme['text']};
            margin-right: 6px;
        }}
        
        QComboBox QAbstractItemView {{
            background-color: {theme['surface']};
            border: 2px solid {theme['border']};
            color: {theme['text']};
            selection-background-color: {theme['hover']};
            outline: none;
        }}
        
        QComboBox QAbstractItemView::item {{
            padding: 4px 8px;
            border: none;
            background-color: {theme['surface']};
            color: {theme['text']};
        }}
        
        QComboBox QAbstractItemView::item:hover {{
            background-color: {theme['hover']};
            color: {theme['text']};
        }}
        
        QComboBox QAbstractItemView::item:selected {{
            background-color: {theme['hover']};
            color: {theme['text']};
        }}
        
        QComboBox QAbstractItemView::item:selected:hover {{
            background-color: {theme['hover']};
            color: {theme['text']};
        }}
        
        QCheckBox {{
            color: {theme['text']};
            spacing: 5px;
        }}
        
        QCheckBox::indicator {{
            width: 16px;
            height: 16px;
            border: 1px solid {theme['border']};
            border-radius: 2px;
            background-color: {theme['surface']};
        }}
        
        QCheckBox::indicator:checked {{
            background-color: {theme['primary']};
            image: none;
        }}
        
        QCheckBox::indicator:checked:after {{
            content: "✓";
            color: white;
            font-weight: bold;
        }}
        
        QScrollBar:vertical {{
            background-color: {theme['surface']};
            width: 12px;
            border: none;
            border-radius: 6px;
        }}
        
        QScrollBar::handle:vertical {{
            background-color: {theme['border']};
            border-radius: 6px;
            min-height: 20px;
        }}
        
        QScrollBar::handle:vertical:hover {{
            background-color: {theme['text_secondary']};
        }}
        
        QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {{
            height: 0px;
        }}
        
        QScrollBar:horizontal {{
            background-color: {theme['surface']};
            height: 12px;
            border: none;
            border-radius: 6px;
        }}
        
        QScrollBar::handle:horizontal {{
            background-color: {theme['border']};
            border-radius: 6px;
            min-width: 20px;
        }}
        
        QScrollBar::handle:horizontal:hover {{
            background-color: {theme['text_secondary']};
        }}
        
        QScrollBar::add-line:horizontal, QScrollBar::sub-line:horizontal {{
            width: 0px;
        }}
        
        QMenuBar {{
            background-color: {theme['surface']};
            color: {theme['text']};
            border-bottom: 1px solid {theme['border']};
        }}
        
        QMenuBar::item {{
            background-color: transparent;
            padding: 6px 12px;
            border-radius: 3px;
            margin: 2px;
        }}
        
        QMenuBar::item:selected {{
            background-color: {theme['primary']};
            color: white;
        }}
        
        QMenuBar::item:hover {{
            background-color: {theme['primary']};
            color: white;
        }}
        
        QMenuBar::item:pressed {{
            background-color: {theme['primary']};
            color: white;
        }}
        
        QMenu {{
            background-color: {theme['surface']};
            color: {theme['text']};
            border: 1px solid {theme['border']};
            border-radius: 4px;
        }}
        
        QMenu::item {{
            background-color: transparent;
            padding: 6px 20px;
            border: none;
            margin: 1px;
            border-radius: 2px;
        }}
        
        QMenu::item:selected {{
            background-color: {theme['primary']};
            color: white;
        }}
        
        QMenu::item:hover {{
            background-color: {theme['primary']};
            color: white;
        }}
        
        QMenu::separator {{
            height: 1px;
            background-color: {theme['border']};
            margin: 2px 0px;
        }}
        
        QMenu QMenu {{
            background-color: {theme['surface']};
            border: 1px solid {theme['border']};
            border-radius: 4px;
        }}
        
        QMenu QMenu::item {{
            background-color: transparent;
            padding: 6px 20px;
            border: none;
            margin: 1px;
            border-radius: 2px;
        }}
        
        QMenu QMenu::item:selected {{
            background-color: {theme['primary']};
            color: white;
        }}
        
        QMenu QMenu::item:hover {{
            background-color: {theme['primary']};
            color: white;
        }}
        
        QSplitter::handle {{
            background-color: {theme['border']};
            border: 1px solid {theme['border']};
        }}
        
        QSplitter::handle:horizontal {{
            width: 8px;
            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                stop:0 {theme['surface']}, 
                stop:0.5 {theme['border']}, 
                stop:1 {theme['surface']});
            border-left: 1px solid {theme['border']};
            border-right: 1px solid {theme['border']};
        }}
        
        QSplitter::handle:horizontal:hover {{
            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                stop:0 {theme['hover']}, 
                stop:0.5 {theme['primary']}, 
                stop:1 {theme['hover']});
        }}
        
        QSplitter::handle:vertical {{
            height: 8px;
            background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                stop:0 {theme['surface']}, 
                stop:0.5 {theme['border']}, 
                stop:1 {theme['surface']});
            border-top: 1px solid {theme['border']};
            border-bottom: 1px solid {theme['border']};
        }}
        
        QSplitter::handle:vertical:hover {{
            background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                stop:0 {theme['hover']}, 
                stop:0.5 {theme['primary']}, 
                stop:1 {theme['hover']});
        }}
        
        """
        

        
        # 커스텀 테마가 아닐 때만 QGraphicsView 스타일 추가
        if theme_name != "커스텀 테마":
            style += f"""
        QGraphicsView {{
            background-color: {theme['surface']};
            border: 1px solid {theme['border']};
            border-radius: 3px;
        }}
        """
        
        # 커스텀 타이틀 바 스타일 추가
        title_bar_style = f"""
        QWidget#titleBar {{
            background-color: {theme['surface']};
            border-bottom: 1px solid {theme['border']};
            border-top-left-radius: 10px;
            border-top-right-radius: 10px;
        }}
        
        QLabel#titleLabel {{
            color: {theme['text']};
            background-color: transparent;
            font-weight: bold;
            font-size: 14px;
        }}
        """
        
        style += title_bar_style
        
        self.setStyleSheet(style)
            
        # 커스텀 테마인 경우 배경 이미지 적용
        if theme_name == "커스텀 테마" and self.custom_background_image:
            self.apply_background_image(self.custom_background_image)
        else:
            # 다른 테마인 경우 배경 이미지 제거
            self.remove_background_image()
        
        # 타이틀 바 버튼 스타일 업데이트 (테마별 색상 적용)
        if hasattr(self, 'minimize_btn'):
            if theme_name in ["블루 네온", "핑크 네온"]:
                # 네온 테마용 타이틀 바 버튼
                button_style = f"""
                    QPushButton {{
                        background-color: transparent;
                        border: 1px solid {theme['primary']};
                        color: {theme['primary']};
                        font-size: 12px;
                        font-weight: bold;
                        padding: 5px 8px;
                        border-radius: 3px;
                        margin: 2px;
                    }}
                    QPushButton:hover {{
                        background-color: {theme['primary']};
                        color: black;
                    }}
                """
                
                close_button_style = f"""
                    QPushButton {{
                        background-color: transparent;
                        border: 1px solid #ff0040;
                        color: #ff0040;
                        font-size: 12px;
                        font-weight: bold;
                        padding: 5px 8px;
                        border-radius: 3px;
                        margin: 2px;
                    }}
                    QPushButton:hover {{
                        background-color: #ff0040;
                        color: white;
                    }}
                """
            else:
                # 일반 테마용 타이틀 바 버튼
                button_style = f"""
                    QPushButton {{
                        background-color: transparent;
                        border: none;
                        color: {theme['text']};
                        font-size: 14px;
                        font-weight: bold;
                        padding: 5px 10px;
                        border-radius: 0px;
                    }}
                    QPushButton:hover {{
                        background-color: {theme['hover']};
                    }}
                """
                
                close_button_style = button_style + """
                    QPushButton:hover {
                        background-color: #e81123;
                        color: white;
                    }
                """
            
            self.minimize_btn.setStyleSheet(button_style)
            self.maximize_btn.setStyleSheet(button_style)
            self.close_btn.setStyleSheet(close_button_style)
            
            # 메뉴 버튼도 동일한 스타일 적용
            if hasattr(self, 'menu_btn'):
                if theme_name in ["블루 네온", "핑크 네온"]:
                    menu_button_style = f"""
                        QPushButton {{
                            background-color: transparent;
                            border: 1px solid {theme['primary']};
                            color: {theme['primary']};
                            font-size: 14px;
                            font-weight: bold;
                            padding: 3px;
                            border-radius: 3px;
                            margin: 2px;
                        }}
                        QPushButton:hover {{
                            background-color: {theme['primary']};
                            color: black;
                        }}
                    """
                else:
                    menu_button_style = f"""
                        QPushButton {{
                            background-color: transparent;
                            border: none;
                            color: {theme['text']};
                            font-size: 16px;
                            font-weight: bold;
                            padding: 3px;
                            border-radius: 0px;
                        }}
                        QPushButton:hover {{
                            background-color: {theme['hover']};
                        }}
                    """
                self.menu_btn.setStyleSheet(menu_button_style)
        
        # 드롭 힌트 스타일 업데이트만 유지
        if hasattr(self, 'image_view'):
            self.image_view.update_drop_hint_style(theme)
        
        # 테마 액션 상태 업데이트 (theme_group이 있는 경우에만)
        if hasattr(self, 'theme_group') and self.theme_group:
            for action in self.theme_group.actions():
                action.setChecked(action.text() == theme_name)
        
        # 타이틀바 스타일 업데이트
        self.update_title_bar_style()
        
        # 커스텀 테마인 경우 배경 이미지와 투명도 적용 (스타일시트 적용 후에)
        if theme_name == "커스텀 테마":
            if hasattr(self, 'custom_background_image') and self.custom_background_image:
                self.apply_background_image(self.custom_background_image)
            else:
                # 배경 이미지가 없어도 투명도는 적용
                self.apply_custom_theme_transparency_new()
        
        # 스플리터 핸들 너비 업데이트
        if hasattr(self, 'main_splitter'):
            self.main_splitter.update_handle_width(theme_name)
        
        # UI 설정에 테마 저장 (지연 저장으로 성능 개선)
        if not hasattr(self, '_save_timer'):
            from PySide6.QtCore import QTimer
            self._save_timer = QTimer()
            self._save_timer.setSingleShot(True)
            self._save_timer.timeout.connect(self.save_ui_settings)
        
        # 500ms 후에 저장 (연속 테마 변경 시 마지막 것만 저장)
        self._save_timer.start(500)
        
        # 모든 버튼에 마우스 추적 활성화 (hover 효과를 위해)
        self.enable_button_mouse_tracking()
        
        # EXIF 오버레이 스타일 업데이트
        if hasattr(self, 'image_view') and hasattr(self.image_view, 'update_exif_overlay_style'):
            self.image_view.update_exif_overlay_style()
        
        # 커스텀 테마가 아닐 때 콤보박스 스타일 초기화 (커스텀 투명도 스타일 제거)
        if theme_name != "커스텀 테마":
            try:
                # 모든 QComboBox 찾아서 커스텀 투명도 스타일 제거하고 새 테마 스타일 적용
                combos = self.findChildren(QComboBox)
                for combo in combos:
                    combo.setStyleSheet("")  # 기존 스타일 완전 제거
                    
                # 새 테마의 콤보박스 스타일 적용
                combo_style = f"""
                    QComboBox {{
                        background-color: {theme['surface']};
                        border: 1px solid {theme['border']};
                        color: {theme['text']};
                        padding: 4px 8px;
                        border-radius: 3px;
                    }}
                    QComboBox:hover {{
                        background-color: {theme['hover']};
                        border: 1px solid {theme['primary']};
                    }}
                    QComboBox::drop-down {{
                        border: none;
                        background-color: transparent;
                    }}
                    QComboBox::drop-down:hover {{
                        background-color: {theme['hover']};
                    }}
                    QComboBox QAbstractItemView {{
                        background-color: {theme['surface']};
                        border: 1px solid {theme['border']};
                        selection-background-color: {theme['hover']};
                        color: {theme['text']};
                        outline: none;
                    }}
                    QComboBox QAbstractItemView::item {{
                        padding: 4px 8px;
                        border: none;
                        background-color: {theme['surface']};
                        color: {theme['text']};
                    }}
                    QComboBox QAbstractItemView::item:hover {{
                        background-color: {theme['hover']};
                        color: {theme['text']};
                    }}
                    QComboBox QAbstractItemView::item:selected {{
                        background-color: {theme['hover']};
                        color: {theme['text']};
                    }}
                    QComboBox QAbstractItemView::item:selected:hover {{
                        background-color: {theme['hover']};
                        color: {theme['text']};
                    }}
                """
                
                for combo in combos:
                    combo.setStyleSheet(combo_style)
                    combo.update()  # 강제 업데이트
                    combo.repaint()  # 강제 다시 그리기
                
                # 정렬 콤보박스에 특별히 강제 적용
                if hasattr(self, 'sort_selector'):
                    self.sort_selector.setStyleSheet(combo_style)
                    self.sort_selector.update()
                    self.sort_selector.repaint()
                    print(f"[INFO] 정렬 콤보박스에 강제 스타일 적용")
                    
                if hasattr(self, 'book_sort_selector'):
                    self.book_sort_selector.setStyleSheet(combo_style)
                    self.book_sort_selector.update()
                    self.book_sort_selector.repaint()
                    print(f"[INFO] 북 정렬 콤보박스에 강제 스타일 적용")
                
                # 북과 페이지 리스트에 강제 호버 스타일 적용
                list_style = f"""
                    QListWidget::item:hover {{
                        background-color: {theme['hover']} !important;
                        color: {theme['text']} !important;
                    }}
                    QListWidget::item:selected {{
                        background-color: {theme['selected']};
                        color: {theme['text']};
                    }}
                """
                
                if hasattr(self, 'book_list'):
                    self.book_list.setStyleSheet(list_style)
                    self.book_list.update()
                    self.book_list.repaint()
                    print(f"[INFO] 북 리스트에 강제 호버 스타일 적용")
                    
                if hasattr(self, 'char_list'):
                    self.char_list.setStyleSheet(list_style)
                    self.char_list.update()
                    self.char_list.repaint()
                    print(f"[INFO] 페이지 리스트에 강제 호버 스타일 적용")
                    
                print(f"[INFO] {len(combos)}개 콤보박스에 새 테마 스타일 적용 완료")
            except Exception as e:
                print(f"[ERROR] 콤보박스 스타일 적용 실패: {e}")
        
    def enable_button_mouse_tracking(self):
        """모든 QPushButton에 마우스 추적을 활성화하여 hover 효과가 제대로 작동하도록 합니다."""
        try:
            # 모든 QPushButton 찾기
            buttons = self.findChildren(QPushButton)
            for button in buttons:
                # 마우스 추적 활성화
                button.setMouseTracking(True)
                # 속성 업데이트 강제 실행
                button.setAttribute(Qt.WA_Hover, True)
                button.update()
            
            print(f"[INFO] {len(buttons)}개 버튼에 마우스 추적 활성화 완료")
        except Exception as e:
            print(f"[ERROR] 버튼 마우스 추적 활성화 실패: {e}")

    
    def apply_custom_theme(self):
        """커스텀 테마 적용 - 이미지 파일 선택"""
        file_dialog = QFileDialog()
        file_path, _ = file_dialog.getOpenFileName(
            self,
            "배경 이미지 선택",
            "",
            "이미지 파일 (*.png *.jpg *.jpeg *.bmp *.gif *.tiff *.tif *.webp)"
        )
        
        if file_path:
            # 강제 재시작 확인 다이얼로그
            from PySide6.QtWidgets import QMessageBox
            
            msg_box = QMessageBox(self)
            msg_box.setWindowTitle("프로그램 재시작 필요")
            msg_box.setText("커스텀 테마를 올바르게 적용하려면 프로그램을 재시작해야 합니다.")
            msg_box.setInformativeText("지금 재시작하시겠습니까?\n\n재시작하지 않으면 테마 적용이 취소됩니다.")
            msg_box.setIcon(QMessageBox.Question)
            
            restart_btn = msg_box.addButton("재시작", QMessageBox.AcceptRole)
            cancel_btn = msg_box.addButton("취소", QMessageBox.RejectRole)
            
            msg_box.exec()
            
            if msg_box.clickedButton() == restart_btn:
                # 커스텀 테마 설정 저장
                self.custom_background_image = file_path
                
                # UI 설정에 커스텀 테마 저장
                self.current_theme = "커스텀 테마"
                self.save_ui_settings()
                
                # 프로그램 재시작
                import sys
                import os
                
                # 현재 스크립트 경로
                script_path = os.path.abspath(sys.argv[0])
                
                # 새 프로세스로 프로그램 시작
                import subprocess
                subprocess.Popen([sys.executable, script_path])
                
                # 현재 프로그램 종료
                self.close()
                
            else:
                # 취소한 경우 이전 테마로 되돌리기
                for action in self.theme_group.actions():
                    if action.text().endswith(self.current_theme):
                        action.setChecked(True)
                        break
        else:
            # 이미지 선택을 취소한 경우 이전 테마로 되돌리기
            for action in self.theme_group.actions():
                if action.text().endswith(self.current_theme):
                    action.setChecked(True)
                    break
            
    def apply_background_image(self, image_path):
        """배경 이미지를 적용합니다."""
        try:
            from PySide6.QtGui import QPixmap, QImageReader
            import os
            
            # 이미지 파일 존재 여부 확인
            if not os.path.exists(image_path):
                print(f"[ERROR] 이미지 파일이 존재하지 않음: {image_path}")
                self.handle_custom_theme_image_failure(image_path)
                return
            
            # 고품질 이미지 리더 설정
            reader = QImageReader(image_path)
            reader.setAutoTransform(True)  # EXIF 정보 기반 자동 회전
            reader.setDecideFormatFromContent(True)  # 파일 내용 기반으로 포맷 결정
            reader.setQuality(100)  # 최고 품질 설정
            
            # 고품질 이미지 로딩
            image = reader.read()
            if image.isNull():
                print(f"[ERROR] 이미지 로드 실패: {image_path}")
                self.handle_custom_theme_image_failure(image_path)
                return
            
            # 이미지 품질 향상을 위한 변환 설정
            pixmap = QPixmap.fromImage(image, Qt.PreferDither | Qt.AutoColor)
            if pixmap.isNull():
                print(f"[ERROR] 픽스맵 변환 실패: {image_path}")
                self.handle_custom_theme_image_failure(image_path)
                return
            
            # 배경 이미지 저장
            self.background_pixmap = pixmap
            
            # 이미지 밝기 조절 적용
            self.apply_image_brightness()
            
            # 중앙 위젯을 투명하게 설정
            central_widget = self.centralWidget()
            if central_widget:
                central_widget.setAttribute(Qt.WA_TranslucentBackground, True)
                central_widget.setStyleSheet("background: transparent;")
            
            # 커스텀 테마용 반투명 스타일 적용
            self.apply_custom_theme_transparency_new()
            
            # 윈도우 다시 그리기 (paintEvent가 호출됨)
            self.update()
            
        except Exception as e:
            print(f"[ERROR] 배경 이미지 적용 실패: {e}")
            self.handle_custom_theme_image_failure(image_path)

    def handle_custom_theme_image_failure(self, failed_image_path):
        """커스텀 테마 이미지 로드 실패 시 처리"""
        try:
            print(f"[INFO] 커스텀 테마 이미지 로드 실패로 인해 기본 테마로 되돌립니다.")
            
            # 커스텀 테마 설정 초기화
            self.custom_background_image = None
            self.current_theme = "어두운 모드"
            
            # 배경 이미지 제거
            if hasattr(self, 'background_pixmap'):
                self.background_pixmap = None
            
            # 기본 테마 적용
            self.apply_theme("어두운 모드")
            
            # 테마 액션 상태 업데이트
            if hasattr(self, 'theme_group') and self.theme_group:
                for action in self.theme_group.actions():
                    if "어두운 모드" in action.text():
                        action.setChecked(True)
                    else:
                        action.setChecked(False)
            
            # 설정 파일에서 커스텀 테마 정보 제거
            self.save_ui_settings()
            
            # 사용자에게 알림 (선택사항)
            from PySide6.QtWidgets import QMessageBox
            QMessageBox.information(
                self,
                "커스텀 테마 오류",
                f"커스텀 테마 배경 이미지를 불러올 수 없어서\n기본 어두운 모드로 변경되었습니다.\n\n"
                f"실패한 이미지 경로:\n{failed_image_path}\n\n"
                f"새로운 커스텀 테마를 설정하려면\n메뉴에서 다시 선택해주세요."
            )
            
        except Exception as e:
            print(f"[ERROR] 커스텀 테마 실패 처리 중 오류: {e}")

    def remove_background_image(self):
        """배경 이미지를 제거합니다."""
        try:
            # 배경 이미지 제거
            if hasattr(self, 'background_pixmap'):
                self.background_pixmap = None
            
            # 투명도 스타일 제거
            self.remove_custom_theme_transparency()
            
            # 윈도우 다시 그리기
            self.update()
            
        except Exception as e:
            print(f"[ERROR] 배경 이미지 제거 실패: {e}")

    def paintEvent(self, event):
        """커스텀 페인트 이벤트 - 배경 이미지 그리기 (윈도우 전체 채우기)"""
        # 배경 이미지가 있는 경우에만 그리기
        if hasattr(self, 'background_pixmap') and self.background_pixmap:
            from PySide6.QtGui import QPainter
            
            painter = QPainter(self)
            painter.setRenderHint(QPainter.Antialiasing)
            painter.setRenderHint(QPainter.SmoothPixmapTransform)
            painter.setRenderHint(QPainter.TextAntialiasing)
            painter.setRenderHint(QPainter.LosslessImageRendering)
            
            # 윈도우 크기
            window_width = self.width()
            window_height = self.height()
            
            # 밝기 조절된 이미지가 있으면 사용, 없으면 원본 사용
            source_pixmap = getattr(self, 'adjusted_background_pixmap', self.background_pixmap)
            
            # 이미지 원본 크기
            image_width = source_pixmap.width()
            image_height = source_pixmap.height()
            
            # 윈도우를 완전히 채우면서 비율 유지 (crop 방식)
            scale_width = window_width / image_width
            scale_height = window_height / image_height
            scale = max(scale_width, scale_height)  # 큰 쪽 스케일 사용하여 완전히 채우기
            
            # 스케일된 이미지 크기 계산
            scaled_width = int(image_width * scale)
            scaled_height = int(image_height * scale)
            
            # 중앙 정렬을 위한 위치 계산 (이미지가 윈도우보다 클 수 있음)
            x = (window_width - scaled_width) // 2
            y = (window_height - scaled_height) // 2
            
            # 고품질 스케일링으로 이미지 그리기 (비율 유지)
            # 큰 축소비율일 때 단계적 스케일링으로 계단현상 방지
            if scale < 0.5:  # 50% 이하로 축소할 때
                # 단계적 스케일링: 먼저 50%로 축소 후 최종 크기로 축소
                intermediate_width = int(image_width * 0.5)
                intermediate_height = int(image_height * 0.5)
                intermediate_pixmap = source_pixmap.scaled(
                    intermediate_width, intermediate_height,
                    Qt.KeepAspectRatio,
                    Qt.SmoothTransformation
                )
                scaled_pixmap = intermediate_pixmap.scaled(
                    scaled_width, scaled_height,
                    Qt.KeepAspectRatio,
                    Qt.SmoothTransformation
                )
            else:
                # 일반 스케일링
                scaled_pixmap = source_pixmap.scaled(
                    scaled_width, scaled_height,
                    Qt.KeepAspectRatio,  # 비율 유지
                    Qt.SmoothTransformation
                )
            
            # 배경 이미지 그리기
            painter.drawPixmap(x, y, scaled_pixmap)
            painter.end()
        
        # 부모 클래스의 paintEvent 호출
        super().paintEvent(event)
    
    def disable_all_error_dialogs(self):
        """모든 에러 대화상자를 시스템 레벨에서 차단"""
        try:
            import ctypes
            from ctypes import wintypes
            import warnings
            import tempfile
            import atexit
            import shutil
            import os
            
            # 1. 모든 Python 경고 완전 무시
            warnings.filterwarnings("ignore")
            
            # 2. Windows 시스템 에러 대화상자 완전 차단
            try:
                # SetErrorMode - 모든 시스템 에러 대화상자 차단
                SEM_FAILCRITICALERRORS = 0x0001      # 중요한 에러 대화상자 차단
                SEM_NOGPFAULTERRORBOX = 0x0002       # GPF 에러 대화상자 차단  
                SEM_NOOPENFILEERRORBOX = 0x8000      # 파일 열기 에러 대화상자 차단
                SEM_NOALIGNMENTFAULTEXCEPT = 0x0004  # 정렬 오류 예외 차단
                
                error_mode = (SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX | 
                             SEM_NOOPENFILEERRORBOX | SEM_NOALIGNMENTFAULTEXCEPT)
                ctypes.windll.kernel32.SetErrorMode(error_mode)
                
                # SetThreadErrorMode - 현재 스레드의 에러 모드 설정
                try:
                    old_mode = wintypes.DWORD()
                    ctypes.windll.kernel32.SetThreadErrorMode(error_mode, ctypes.byref(old_mode))
                except:
                    pass
                
                # 추가: 프로세스 에러 모드 설정
                try:
                    ctypes.windll.kernel32.SetProcessErrorMode(error_mode)
                except:
                    pass
                    
            except Exception:
                pass
            
            # 3. 모든 파일/폴더 관련 함수 래핑
            try:
                # tempfile 정리 함수 무력화
                def dummy_cleanup(*args, **kwargs):
                    pass
                tempfile._cleanup = dummy_cleanup
                
                # shutil.rmtree 무력화
                original_rmtree = shutil.rmtree
                def silent_rmtree(*args, **kwargs):
                    try:
                        return original_rmtree(*args, **kwargs)
                    except:
                        pass
                shutil.rmtree = silent_rmtree
                
                # os.remove 래핑
                original_remove = os.remove
                def silent_remove(*args, **kwargs):
                    try:
                        return original_remove(*args, **kwargs)
                    except:
                        pass
                os.remove = silent_remove
                
                # os.rmdir 래핑
                original_rmdir = os.rmdir
                def silent_rmdir(*args, **kwargs):
                    try:
                        return original_rmdir(*args, **kwargs)
                    except:
                        pass
                os.rmdir = silent_rmdir
                
            except Exception:
                pass
            
            # 4. atexit 핸들러 완전 무력화
            try:
                atexit._clear()
                # 빈 핸들러만 등록
                atexit.register(lambda: None)
            except Exception:
                pass
            
            # 5. 환경 변수로 에러 무시 설정
            try:
                os.environ['PYTHONIOENCODING'] = 'utf-8'
                os.environ['PYTHONUNBUFFERED'] = '1'
                os.environ['PYTHONDONTWRITEBYTECODE'] = '1'
            except Exception:
                pass
                
        except Exception:
            # 모든 에러 무시
            pass











    def adjust_window_opacity(self):
        """윈도우 투명도 조절 다이얼로그"""
        try:
            from PySide6.QtWidgets import QSlider, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, QDialog
            
            dialog = QDialog(self)
            dialog.setWindowTitle("윈도우 투명도 조절")
            dialog.setFixedSize(300, 150)
            
            layout = QVBoxLayout(dialog)
            
            # 현재 투명도 표시
            current_opacity = self.windowOpacity()
            opacity_label = QLabel(f"현재 투명도: {int(current_opacity * 100)}%")
            layout.addWidget(opacity_label)
            
            # 투명도 슬라이더
            opacity_slider = QSlider(Qt.Horizontal)
            opacity_slider.setMinimum(10)  # 최소 10%
            opacity_slider.setMaximum(100)  # 최대 100%
            opacity_slider.setValue(int(current_opacity * 100))
            
            def on_opacity_changed(value):
                self.setWindowOpacity(value / 100.0)
                opacity_label.setText(f"현재 투명도: {value}%")
            
            opacity_slider.valueChanged.connect(on_opacity_changed)
            layout.addWidget(opacity_slider)
            
            # 버튼들
            button_layout = QHBoxLayout()
            
            reset_button = QPushButton("기본값 (100%)")
            reset_button.clicked.connect(lambda: opacity_slider.setValue(100))
            button_layout.addWidget(reset_button)
            
            transparent_button = QPushButton("반투명 (70%)")
            transparent_button.clicked.connect(lambda: opacity_slider.setValue(70))
            button_layout.addWidget(transparent_button)
            
            close_button = QPushButton("닫기")
            close_button.clicked.connect(dialog.accept)
            button_layout.addWidget(close_button)
            
            layout.addLayout(button_layout)
            
            dialog.exec()
            
        except Exception as e:
            print(f"[ERROR] 윈도우 투명도 조절 실패: {e}")
            QMessageBox.critical(self, "오류", f"윈도우 투명도 조절 실패: {e}")

    def adjust_custom_theme_transparency(self):
        """커스텀 테마 투명도 및 이미지 밝기 조절 다이얼로그"""
        try:
            from PySide6.QtWidgets import QSlider, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, QDialog
            from PySide6.QtCore import QEvent, QObject
            
            dialog = QDialog(self)
            dialog.setWindowTitle("커스텀 테마 설정")
            dialog.setFixedSize(400, 300)
            
            # 투명도 조절창은 커스텀 테마 영향을 받지 않도록 고정 스타일 적용
            dialog.setAttribute(Qt.WA_TranslucentBackground, False)
            
            # 현재 테마 적용
            current_theme = getattr(self, 'current_theme', '어두운 모드')
            theme = self.THEMES.get(current_theme, self.THEMES['어두운 모드'])
            
            # 대화상자 고정 스타일 (투명도 영향 없음)
            dialog.setStyleSheet(f"""
                QDialog {{
                    background-color: {theme['background']};
                    color: {theme['text']};
                    border: 2px solid {theme['border']};
                    border-radius: 10px;
                }}
                QLabel {{
                    color: {theme['text']};
                    background-color: {theme['background']};
                    font-weight: bold;
                }}
                QSlider::groove:horizontal {{
                    border: 1px solid {theme['border']};
                    height: 8px;
                    background: {theme['surface']};
                    border-radius: 4px;
                }}
                QSlider::handle:horizontal {{
                    background: {theme['primary']};
                    border: 1px solid {theme['border']};
                    width: 18px;
                    margin: -5px 0;
                    border-radius: 9px;
                }}
                QPushButton {{
                    background-color: {theme['button']} !important;
                    border: 2px solid {theme['border']} !important;
                    color: {theme['text']} !important;
                    padding: 6px 12px;
                    border-radius: 4px;
                    font-weight: bold;
                    font-size: 8pt;
                    min-width: 50px;
                    min-height: 18px;
                }}
                QPushButton:hover {{
                    background-color: {theme['button_hover']} !important;
                    border: 2px solid {theme['primary']} !important;
                    color: {theme['primary']} !important;
                }}
                QPushButton:pressed {{
                    background-color: {theme['primary']} !important;
                    border: 2px solid {theme['primary']} !important;
                    color: {theme['background']} !important;
                }}
            """)
            
            layout = QVBoxLayout(dialog)
            layout.setSpacing(15)
            layout.setContentsMargins(20, 20, 20, 20)
            
            # 설명 라벨
            desc_label = QLabel("커스텀 테마의 UI 투명도와 배경 이미지 밝기를 조절합니다\n(밝기는 브라이트니스 방식으로 적용됩니다)")
            desc_label.setAlignment(Qt.AlignCenter)
            desc_label.setStyleSheet("font-size: 12px; margin-bottom: 10px;")
            layout.addWidget(desc_label)
            
            # === UI 투명도 섹션 ===
            transparency_section = QVBoxLayout()
            
            # 현재 투명도 표시
            current_transparency = self.custom_transparency_level
            transparency_label = QLabel(f"UI 투명도: {int(current_transparency * 100)}%")
            transparency_label.setAlignment(Qt.AlignCenter)
            transparency_section.addWidget(transparency_label)
            
            # 투명도 슬라이더
            transparency_slider = QSlider(Qt.Horizontal)
            transparency_slider.setMinimum(5)   # 최소 5% (완전 투명하면 안 보임)
            transparency_slider.setMaximum(95)  # 최대 95% (완전 불투명하면 배경 이미지가 안 보임)
            transparency_slider.setValue(int(current_transparency * 100))
            transparency_section.addWidget(transparency_slider)
            
            layout.addLayout(transparency_section)
            
            # === 이미지 밝기 섹션 ===
            brightness_section = QVBoxLayout()
            
            # 현재 밝기 표시 (기본값 50)
            current_brightness = getattr(self, 'custom_image_brightness', 50)
            brightness_label = QLabel(f"이미지 밝기: {current_brightness} (50=원본)")
            brightness_label.setAlignment(Qt.AlignCenter)
            brightness_section.addWidget(brightness_label)
            
            # 밝기 슬라이더
            brightness_slider = QSlider(Qt.Horizontal)
            brightness_slider.setMinimum(0)    # 0 = 매우 어둡게 (30% 밝기)
            brightness_slider.setMaximum(100)  # 100 = 매우 밝게 (170% 밝기)
            brightness_slider.setValue(current_brightness)
            brightness_section.addWidget(brightness_slider)
            
            layout.addLayout(brightness_section)
            
            # 슬라이더 이벤트 핸들러
            def on_transparency_changed(value):
                self.custom_transparency_level = value / 100.0
                transparency_label.setText(f"UI 투명도: {value}%")
                # 실시간으로 투명도 적용
                if self.current_theme == "커스텀 테마":
                    self.apply_custom_theme_transparency_new()
            
            def on_brightness_changed(value):
                self.custom_image_brightness = value
                brightness_label.setText(f"이미지 밝기: {value} (50=원본)")
                # 실시간으로 밝기 적용
                if self.current_theme == "커스텀 테마":
                    self.apply_image_brightness()
            
            transparency_slider.valueChanged.connect(on_transparency_changed)
            brightness_slider.valueChanged.connect(on_brightness_changed)
            
            # 버튼 생성 함수 (스타일은 대화상자에서 일괄 적용)
            def create_hover_button(text):
                button = QPushButton(text)
                # 마우스 추적 활성화
                button.setMouseTracking(True)
                return button
            
            # 프리셋 버튼들
            preset_layout = QHBoxLayout()
            
            low_button = create_hover_button("낮음")
            low_button.clicked.connect(lambda: (transparency_slider.setValue(20), brightness_slider.setValue(30)))
            preset_layout.addWidget(low_button)
            
            medium_button = create_hover_button("중간")
            medium_button.clicked.connect(lambda: (transparency_slider.setValue(50), brightness_slider.setValue(50)))
            preset_layout.addWidget(medium_button)
            
            high_button = create_hover_button("높음")
            high_button.clicked.connect(lambda: (transparency_slider.setValue(80), brightness_slider.setValue(70)))
            preset_layout.addWidget(high_button)
            
            layout.addLayout(preset_layout)
            
            # 버튼들
            button_layout = QHBoxLayout()
            
            reset_button = create_hover_button("기본값")
            reset_button.clicked.connect(lambda: (transparency_slider.setValue(50), brightness_slider.setValue(50)))
            button_layout.addWidget(reset_button)
            
            close_button = create_hover_button("닫기")
            close_button.clicked.connect(dialog.accept)
            button_layout.addWidget(close_button)
            
            layout.addLayout(button_layout)
            
            dialog.exec()
            
            # 설정 저장
            self.save_ui_settings()
            
        except Exception as e:
            print(f"[ERROR] 커스텀 테마 설정 조절 실패: {e}")
            QMessageBox.critical(self, "오류", f"커스텀 테마 설정 조절 실패: {e}")

    def apply_image_brightness(self):
        """이미지 밝기 조절 적용 - 브라이트니스 방식"""
        try:
            if not hasattr(self, 'background_pixmap') or not self.background_pixmap:
                return
                
            # 밝기 값 가져오기 (0-100, 50이 원본)
            brightness = getattr(self, 'custom_image_brightness', 50)
            
            # 원본 이미지 복사
            adjusted_pixmap = self.background_pixmap.copy()
            
            if brightness != 50:  # 원본이 아닌 경우에만 조절
                # 밝기 조절 팩터 계산 (0.3 ~ 1.7 범위)
                # 0 = 0.3 (어둡게), 50 = 1.0 (원본), 100 = 1.7 (밝게)
                if brightness <= 50:
                    brightness_factor = 0.3 + (brightness / 50.0) * 0.7
                else:
                    brightness_factor = 1.0 + ((brightness - 50) / 50.0) * 0.7
                
                # QPainter를 사용하여 브라이트니스 효과 적용
                painter = QPainter(adjusted_pixmap)
                
                # 브라이트니스 조절을 위한 컴포지션 모드 설정
                if brightness < 50:
                    # 어둡게: Multiply 모드 사용
                    painter.setCompositionMode(QPainter.CompositionMode_Multiply)
                    # 어두운 회색으로 곱하기 (밝기 감소)
                    gray_value = int(255 * brightness_factor)
                    painter.fillRect(adjusted_pixmap.rect(), QColor(gray_value, gray_value, gray_value))
                else:
                    # 밝게: Screen 모드 사용
                    painter.setCompositionMode(QPainter.CompositionMode_Screen)
                    # 밝은 회색으로 스크린 블렌딩 (밝기 증가)
                    screen_value = int(255 * (brightness_factor - 1.0))
                    painter.fillRect(adjusted_pixmap.rect(), QColor(screen_value, screen_value, screen_value))
                
                painter.end()
            
            # 조절된 이미지를 배경으로 설정
            self.adjusted_background_pixmap = adjusted_pixmap
            
            # 윈도우 다시 그리기
            self.update()
            
        except Exception as e:
            print(f"[ERROR] 이미지 밝기 조절 실패: {e}")

    def reset_viewport_transparency(self):
        """뷰포트 투명도만 초기화 (배경 이미지는 유지)"""
        try:
    
            
            # 이미지 뷰 관련 초기화만 수행
            if hasattr(self, 'image_view'):
                # 뷰포트 스타일 완전 제거
                self.image_view.setStyleSheet("")
                self.image_view.viewport().setStyleSheet("")
                
                # 씬 배경 초기화
                if hasattr(self.image_view, 'scene') and self.image_view.scene():
                    # 씬 배경을 완전 투명으로 설정
                    self.image_view.scene().setBackgroundBrush(QBrush(QColor(0, 0, 0, 0)))
                
                # 뷰포트 속성 초기화
                self.image_view.viewport().setAttribute(Qt.WA_TranslucentBackground, False)
                self.image_view.setAttribute(Qt.WA_TranslucentBackground, False)
                
                # 강제로 이미지 뷰 업데이트
                self.image_view.update()
                self.image_view.viewport().update()
                

            
        except Exception as e:
            print(f"[ERROR] 뷰포트 투명도 초기화 실패: {e}")

    def apply_custom_theme_transparency_new(self):
        """커스텀 테마용 부분별 투명도 스타일 적용 - 위젯별 직접 적용"""
        try:
            # 먼저 뷰포트 투명도를 완전히 초기화
            self.reset_viewport_transparency()
            
            # 현재 테마 색상 가져오기
            theme = self.THEMES.get(self.current_theme, self.THEMES['어두운 모드'])
            
            # 사용자 설정 투명도 레벨 사용
            transparency = self.custom_transparency_level
            
            # 검색창들 - 사용자 설정 투명도 + 5% 추가 (더 잘 보이도록)
            search_transparency = min(transparency + 0.05, 0.95)
            search_style = f"""
                background-color: rgba({self.hex_to_rgba(theme['surface'])}, {search_transparency});
                border: 1px solid {theme['border']};
                color: {theme['text']};
                padding: 4px;
                border-radius: 3px;
            """
            
            # 북 검색창
            if hasattr(self, 'book_search_input'):
                self.book_search_input.setStyleSheet(search_style)
            
            # 페이지 검색창
            if hasattr(self, 'search_input'):
                self.search_input.setStyleSheet(search_style)
            
            # 이름 입력란
            if hasattr(self, 'name_input'):
                self.name_input.setStyleSheet(search_style)
            
            # 태그 입력란
            if hasattr(self, 'tag_input'):
                self.tag_input.setStyleSheet(search_style)
            
            # 북 리스트 - 사용자 설정 투명도
            list_style = f"""
                QListWidget {{
                    background-color: rgba({self.hex_to_rgba(theme['surface'])}, {transparency});
                    border: 1px solid {theme['border']};
                    color: {theme['text']};
                    outline: none;
                    border-radius: 3px;
                }}
                QListWidget::item {{
                    background-color: transparent;
                    border: none;
                    padding: 2px;
                }}
                QListWidget::item:selected {{
                    background-color: rgba({self.hex_to_rgba(theme['selected'])}, {transparency});
                    color: white;
                }}
                QListWidget::item:hover {{
                    background-color: rgba({self.hex_to_rgba(theme['hover'])}, {transparency});
                }}
            """
            
            if hasattr(self, 'book_list'):
                self.book_list.setStyleSheet(list_style)
            
            if hasattr(self, 'char_list'):
                self.char_list.setStyleSheet(list_style)
            
            # 텍스트 입력 - 사용자 설정 투명도 - 5% (약간 더 투명하게)
            text_transparency = max(transparency - 0.05, 0.05)
            text_style = f"""
                background-color: rgba({self.hex_to_rgba(theme['surface'])}, {text_transparency});
                border: 1px solid {theme['border']};
                color: {theme['text']};
                padding: 4px;
                border-radius: 3px;
            """
            
            if hasattr(self, 'prompt_input'):
                self.prompt_input.setStyleSheet(text_style)
            
            # 모든 QTextEdit 찾아서 적용
            text_edits = self.findChildren(QTextEdit)
            for text_edit in text_edits:
                text_edit.setStyleSheet(text_style)
            
            # CustomLineEdit도 찾아서 적용
            custom_line_edits = self.findChildren(CustomLineEdit)
            for custom_edit in custom_line_edits:
                custom_edit.setStyleSheet(text_style)
            
            # QPlainTextEdit도 찾아서 적용
            plain_text_edits = self.findChildren(QPlainTextEdit)
            for plain_edit in plain_text_edits:
                plain_edit.setStyleSheet(text_style)
            
            # 버튼들 - 사용자 설정 투명도 - 10% (더 투명하게)
            button_transparency = max(transparency - 0.10, 0.05)
            button_hover_transparency = min(button_transparency + 0.15, 0.95)  # hover 시 더 진하게
            button_style = f"""
                QPushButton {{
                    background-color: rgba({self.hex_to_rgba(theme['button'])}, {button_transparency});
                    border: 1px solid {theme['border']};
                    color: {theme['text']};
                    padding: 6px 12px;
                    border-radius: 3px;
                    font-weight: bold;
                }}
                QPushButton:hover {{
                    background-color: rgba({self.hex_to_rgba(theme['button_hover'])}, {button_hover_transparency});
                    border: 1px solid {theme['primary']};
                    color: {theme['primary']};
                }}
                QPushButton:pressed {{
                    background-color: rgba({self.hex_to_rgba(theme['primary'])}, {button_hover_transparency});
                    color: {theme['background']};
                }}
            """
            
            # 모든 QPushButton 찾아서 적용
            buttons = self.findChildren(QPushButton)
            for button in buttons:
                # 타이틀바 버튼들은 제외
                if button not in [getattr(self, 'menu_btn', None), 
                                getattr(self, 'minimize_btn', None), 
                                getattr(self, 'maximize_btn', None), 
                                getattr(self, 'close_btn', None)]:
                    button.setStyleSheet(button_style)
            
            # 드롭다운 메뉴 - 사용자 설정 투명도
            combo_style = f"""
                QComboBox {{
                    background-color: rgba({self.hex_to_rgba(theme['button'])}, {transparency});
                    border: 1px solid {theme['border']};
                    color: {theme['text']};
                    padding: 4px 8px;
                    border-radius: 3px;
                }}
                QComboBox:hover {{
                    background-color: rgba({self.hex_to_rgba(theme['button_hover'])}, {button_hover_transparency});
                    border: 1px solid {theme['primary']};
                }}
            """
            
            # 모든 QComboBox 찾아서 적용
            combos = self.findChildren(QComboBox)
            for combo in combos:
                combo.setStyleSheet(combo_style)
            
            # 이미지 뷰포트 - 초기화 후 새로운 투명도 적용
            image_transparency = transparency  # 사용자 설정 그대로
            image_style = f"""
                QGraphicsView {{
                    background-color: rgba({self.hex_to_rgba(theme['surface'])}, {image_transparency});
                    border: 1px solid {theme['border']};
                    border-radius: 3px;
                }}
            """
            
            if hasattr(self, 'image_view'):
                # 이미지 뷰에 새로운 스타일 적용
                self.image_view.setStyleSheet(image_style)
                
                # 뷰포트는 완전 투명하게 유지 (중첩 방지)
                self.image_view.viewport().setStyleSheet("background-color: transparent;")
                
                # 씬도 완전 투명하게 유지 (중첩 방지)
                if hasattr(self.image_view, 'scene') and self.image_view.scene():
                    self.image_view.scene().setBackgroundBrush(QBrush(QColor(0, 0, 0, 0)))  # 완전 투명
            
            # 스플리터 핸들 - 사용자 설정의 30% 수준
            splitter_style = f"""
                QSplitter::handle {{
                    background: transparent;
                    border: none;
                    width: 0px;
                    height: 0px;
                }}
                QSplitter::handle:horizontal {{
                    background: transparent;
                    border: none;
                    width: 0px;
                }}
                QSplitter::handle:vertical {{
                    background: transparent;
                    border: none;
                    height: 0px;
                }}
                QSplitter::handle:hover {{
                    background: transparent;
                    border: none;
                }}
            """
            
            # 모든 QSplitter 찾아서 적용
            splitters = self.findChildren(QSplitter)
            for splitter in splitters:
                if self.current_theme == "커스텀 테마":
                    # 커스텀 테마: 스플리터 완전히 숨기되 기능은 유지
                    invisible_splitter_style = f"""
                        QSplitter::handle {{
                            background: transparent;
                            border: none;
                            width: 0px;
                            height: 0px;
                            margin: 0px;
                            padding: 0px;
                        }}
                        QSplitter::handle:horizontal {{
                            background: transparent;
                            border: none;
                            width: 0px;
                            margin: 0px;
                            padding: 0px;
                        }}
                        QSplitter::handle:vertical {{
                            background: transparent;
                            border: none;
                            height: 0px;
                            margin: 0px;
                            padding: 0px;
                        }}
                        QSplitter::handle:hover {{
                            background: transparent;
                            border: none;
                        }}
                    """
                    splitter.setStyleSheet(invisible_splitter_style)
                    if hasattr(splitter, 'setHandleWidth'):
                        splitter.setHandleWidth(0)  # 완전히 0으로 설정
                else:
                    # 다른 테마: 원래 스타일 적용
                    splitter.setStyleSheet(splitter_style)
                    if hasattr(splitter, 'setHandleWidth'):
                        splitter.setHandleWidth(10)
            
        except Exception as e:
            print(f"[ERROR] 투명도 적용 실패: {e}")

    def remove_custom_theme_transparency(self):
        """커스텀 테마 투명도 스타일 제거"""
        try:
            # 중앙 위젯 투명도 제거
            central_widget = self.centralWidget()
            if central_widget:
                central_widget.setAttribute(Qt.WA_TranslucentBackground, False)
                central_widget.setStyleSheet("")
            
            # 이미지 뷰 배경 복원
            if hasattr(self, 'image_view') and hasattr(self, 'current_theme'):
                theme = self.THEMES.get(self.current_theme, self.THEMES['어두운 모드'])
                # 이미지 뷰에 테마 색상 적용
                background_color = QColor(theme['surface'])
                self.image_view.setBackgroundBrush(QBrush(background_color))
                self.image_view.setStyleSheet("")
                self.image_view.viewport().setStyleSheet("")
                
                # 씬 배경색도 복원
                if hasattr(self.image_view, 'scene') and self.image_view.scene():
                    self.image_view.scene().setBackgroundBrush(QBrush(background_color))
            
            # 무한 재귀 방지: apply_theme 호출하지 않음
            # 대신 필요한 스타일만 직접 복원
            
        except Exception as e:
            print(f"[ERROR] 투명도 제거 실패: {e}")

    def hex_to_rgba(self, hex_color):
        """HEX 색상을 RGB 값으로 변환"""
        try:
            hex_color = hex_color.lstrip('#')
            r = int(hex_color[0:2], 16)
            g = int(hex_color[2:4], 16)
            b = int(hex_color[4:6], 16)
            return f"{r}, {g}, {b}"
        except:
            return "128, 128, 128"  # 기본값

    def set_central_widget_background(self, image_path):
        """중앙 위젯에 배경 이미지 설정 (이미지 뷰어처럼 자동 크기 조절)"""
        try:
            central_widget = self.centralWidget()
            if central_widget and os.path.exists(image_path):
                # 경로 수정 (Qt 호환성)
                image_path_fixed = image_path.replace('\\', '/')
                
                # 이미지 크기 정보 가져오기
                from PySide6.QtGui import QPixmap
                pixmap = QPixmap(image_path)
                if not pixmap.isNull():
                    # 창 크기 가져오기
                    window_size = self.size()
                    window_width = window_size.width()
                    window_height = window_size.height()
                    
                    # 이미지 원본 크기
                    image_width = pixmap.width()
                    image_height = pixmap.height()
                    
                    # 이미지 뷰어와 동일한 비율 계산 로직
                    scale_width = window_width / image_width
                    scale_height = window_height / image_height
                    scale = min(scale_width, scale_height)
                    
                    # 스케일된 이미지 크기 계산
                    scaled_width = int(image_width * scale)
                    scaled_height = int(image_height * scale)
                    
                    # 중앙 위젯에 배경 이미지 스타일 적용 (크기 조절 포함)
                    background_style = f"""
                    QWidget {{
                        background-image: url({image_path_fixed});
                        background-repeat: no-repeat;
                        background-position: center center;
                        background-size: {scaled_width}px {scaled_height}px;
                        background-attachment: fixed;
                    }}
                    """
                else:
                    # 이미지 로드 실패 시 기본 설정 (contain 사용)
                    background_style = f"""
                    QWidget {{
                        background-image: url({image_path_fixed});
                        background-repeat: no-repeat;
                        background-position: center center;
                        background-size: contain;
                        background-attachment: fixed;
                    }}
                    """
                
                central_widget.setStyleSheet(background_style)
                
        except Exception as e:
            print(f"[ERROR] 중앙 위젯 배경 설정 실패: {e}")

    def update_title_bar_style(self):
        """현재 테마에 맞게 타이틀바 스타일 업데이트"""
        if not hasattr(self, 'title_bar'):
            return
            
        current_theme = getattr(self, 'current_theme', '어두운 모드')
        theme = self.THEMES.get(current_theme, self.THEMES['어두운 모드'])
        
        # 메뉴 버튼 스타일
        menu_button_style = f"""
            QPushButton {{
                background-color: transparent;
                border: none;
                color: {theme['text']};
                font-size: 16px;
                padding: 5px;
            }}
            QPushButton:hover {{
                background-color: {theme['hover']};
            }}
        """
        
        # 타이틀 라벨 스타일
        title_label_style = f"""
            QLabel {{
                color: {theme['text']};
                font-weight: bold;
                font-size: 14px;
                padding: 0 10px;
            }}
        """
        
        # 일반 버튼 스타일 (Donate, 최소화, 최대화)
        button_style = f"""
            QPushButton {{
                background-color: transparent;
                border: none;
                color: {theme['text']};
                font-size: 14px;
                padding: 5px 10px;
            }}
            QPushButton:hover {{
                background-color: {theme['hover']};
            }}
        """
        
        # 닫기 버튼 스타일 (빨간색 호버)
        close_button_style = f"""
            QPushButton {{
                background-color: transparent;
                border: none;
                color: {theme['text']};
                font-size: 14px;
                padding: 5px 10px;
            }}
            QPushButton:hover {{
                background-color: #e81123;
                color: white;
            }}
        """
        
        # 스타일 적용
        if hasattr(self, 'menu_btn'):
            self.menu_btn.setStyleSheet(menu_button_style)
        if hasattr(self, 'title_label'):
            self.title_label.setStyleSheet(title_label_style)

        if hasattr(self, 'minimize_btn'):
            self.minimize_btn.setStyleSheet(button_style)
        if hasattr(self, 'maximize_btn'):
            self.maximize_btn.setStyleSheet(button_style)
        if hasattr(self, 'close_btn'):
            self.close_btn.setStyleSheet(close_button_style)

    def get_menu_style(self):
        """현재 테마에 맞는 메뉴 스타일 반환"""
        current_theme = getattr(self, 'current_theme', '어두운 모드')
        theme = self.THEMES.get(current_theme, self.THEMES['어두운 모드'])
        
        return f"""
            QMenu {{
                background-color: {theme['surface']};
                color: {theme['text']};
                border: 1px solid {theme['border']};
                border-radius: 4px;
                padding: 4px;
            }}
            QMenu::item {{
                background-color: transparent;
                padding: 8px 20px;
                border: none;
                margin: 1px;
                border-radius: 3px;
            }}
            QMenu::item:hover {{
                background-color: {theme['primary']};
                color: white;
            }}
            QMenu::item:selected {{
                background-color: {theme['primary']};
                color: white;
            }}
            QMenu::separator {{
                height: 1px;
                background-color: {theme['border']};
                margin: 4px 0px;
            }}
        """

    def setup_shortcuts(self):
        """단축키를 설정합니다."""
        # Ctrl+S: 현재 페이지 저장
        self.save_shortcut = QShortcut(QKeySequence("Ctrl+S"), self)
        self.save_shortcut.activated.connect(lambda: (
            self.save_current_character(), 
            QToolTip.showText(
                self.save_button.mapToGlobal(self.save_button.rect().center()), 
                "페이지가 저장되었습니다."
            ) if hasattr(self, 'save_button') else None
        ))
        
        # Ctrl+N: 새 페이지 추가
        self.new_page_shortcut = QShortcut(QKeySequence("Ctrl+N"), self)
        self.new_page_shortcut.activated.connect(self.add_character)
        
        # Ctrl+D: 페이지 복제 (다중 선택 지원)
        self.duplicate_shortcut = QShortcut(QKeySequence("Ctrl+D"), self)
        self.duplicate_shortcut.activated.connect(self.duplicate_focused_characters)
        
        # Delete: 포커스된 리스트에 따라 북 또는 페이지 삭제 (다중 선택 지원)
        self.delete_shortcut = QShortcut(QKeySequence("Delete"), self)
        self.delete_shortcut.activated.connect(self.delete_focused_item)
        
        # F2: 포커스된 리스트에 따라 북 또는 페이지 이름 변경
        self.rename_shortcut = QShortcut(QKeySequence("F2"), self)
        self.rename_shortcut.activated.connect(self.rename_focused_item)
        
        # Ctrl+C: 페이지 복사
        self.copy_shortcut = QShortcut(QKeySequence("Ctrl+C"), self)
        self.copy_shortcut.activated.connect(self.handle_copy_shortcut)
        
        # Ctrl+X: 페이지 잘라내기
        self.cut_shortcut = QShortcut(QKeySequence("Ctrl+X"), self)
        self.cut_shortcut.activated.connect(self.handle_cut_shortcut)
        
        # Ctrl+V: 페이지 붙여넣기
        self.paste_shortcut = QShortcut(QKeySequence("Ctrl+V"), self)
        self.paste_shortcut.activated.connect(self.handle_paste_shortcut)
        
        print("[DEBUG] 단축키 설정 완료")
    
    def eventFilter(self, obj, event):
        """이벤트 필터 - 키보드 이벤트 처리"""
        if event.type() == QEvent.KeyPress:
            # F2 키 처리
            if event.key() == Qt.Key_F2:
                self.rename_focused_item()
                return True
            
            # Delete 키 처리
            elif event.key() == Qt.Key_Delete:
                self.delete_focused_item()
                return True
            
            # Ctrl+D 키 처리
            elif event.key() == Qt.Key_D and event.modifiers() == Qt.ControlModifier:
                self.duplicate_focused_characters()
                return True
            
            # Ctrl+C 키 처리
            elif event.key() == Qt.Key_C and event.modifiers() == Qt.ControlModifier:
                self.handle_copy_shortcut()
                return True
            
            # Ctrl+X 키 처리
            elif event.key() == Qt.Key_X and event.modifiers() == Qt.ControlModifier:
                self.handle_cut_shortcut()
                return True
            
            # Ctrl+V 키 처리
            elif event.key() == Qt.Key_V and event.modifiers() == Qt.ControlModifier:
                self.handle_paste_shortcut()
                return True
        
        return super().eventFilter(obj, event)
    
    def setup_resize_handles(self):
        """투명한 리사이즈 핸들들 설정"""
        handle_size = 8  # 핸들 두께
        corner_size = 15  # 모서리 핸들 크기
        
        # 8개 방향의 핸들 생성
        directions = [
            ('top', 0, 0, 0, handle_size),
            ('bottom', 0, 0, 0, handle_size),
            ('left', 0, 0, handle_size, 0),
            ('right', 0, 0, handle_size, 0),
            ('top-left', 0, 0, corner_size, corner_size),
            ('top-right', 0, 0, corner_size, corner_size),
            ('bottom-left', 0, 0, corner_size, corner_size),
            ('bottom-right', 0, 0, corner_size, corner_size)
        ]
        
        for direction, _, _, width, height in directions:
            handle = ResizeHandle(direction, self)
            if width > 0:
                handle.setFixedWidth(width)
            if height > 0:
                handle.setFixedHeight(height)
            self.resize_handles[direction] = handle
            handle.show()
        
        # 초기 위치 설정
        self.update_resize_handles()
    
    def update_resize_handles(self):
        """리사이즈 핸들들의 위치 업데이트"""
        if not hasattr(self, 'resize_handles'):
            return
            
        rect = self.rect()
        handle_size = 8
        corner_size = 15
        
        # 최대화된 상태에서는 핸들 숨기기
        visible = not self.isMaximized()
        
        for direction, handle in self.resize_handles.items():
            handle.setVisible(visible)
            if not visible:
                continue
                
            if direction == 'top':
                handle.setGeometry(corner_size, 0, rect.width() - 2 * corner_size, handle_size)
            elif direction == 'bottom':
                handle.setGeometry(corner_size, rect.height() - handle_size, 
                                 rect.width() - 2 * corner_size, handle_size)
            elif direction == 'left':
                handle.setGeometry(0, corner_size, handle_size, rect.height() - 2 * corner_size)
            elif direction == 'right':
                handle.setGeometry(rect.width() - handle_size, corner_size, 
                                 handle_size, rect.height() - 2 * corner_size)
            elif direction == 'top-left':
                handle.setGeometry(0, 0, corner_size, corner_size)
            elif direction == 'top-right':
                handle.setGeometry(rect.width() - corner_size, 0, corner_size, corner_size)
            elif direction == 'bottom-left':
                handle.setGeometry(0, rect.height() - corner_size, corner_size, corner_size)
            elif direction == 'bottom-right':
                handle.setGeometry(rect.width() - corner_size, rect.height() - corner_size, 
                                 corner_size, corner_size)

    def setup_theme_actions(self):
        """테마 액션들을 미리 설정"""
        # 테마별 이모지 매핑
        theme_emojis = {
            "어두운 모드": "🌙",
            "밝은 모드": "☀️",
            "파란 바다": "🌊",
            "숲속": "🌲",
            "보라 우주": "🌌",
            "황혼": "🌅",
            "벚꽃": "🌸",
            "민트": "🍃",
            "블루 네온": "⚡",
            "핑크 네온": "💖",
            "커스텀 테마": "🖼️"
        }
        
        for theme_name in self.THEMES.keys():
            emoji = theme_emojis.get(theme_name, "🎨")
            display_name = f"{emoji} {theme_name}"
            
            theme_action = QAction(display_name, self)
            theme_action.setCheckable(True)
            if theme_name == "커스텀 테마":
                theme_action.triggered.connect(lambda checked, name=theme_name: self.apply_custom_theme())
            else:
                theme_action.triggered.connect(lambda checked, name=theme_name: self.apply_theme(name))
            self.theme_group.addAction(theme_action)
            
            # 현재 테마 설정 (current_theme이 초기화된 경우에만)
            if hasattr(self, 'current_theme') and theme_name == self.current_theme:
                theme_action.setChecked(True)

    def setup_custom_title_bar(self, main_layout):
        """커스텀 타이틀 바를 설정합니다."""
        # 타이틀 바 위젯
        self.title_bar = QWidget()
        self.title_bar.setFixedHeight(35)
        self.title_bar.setObjectName("titleBar")
        
        title_layout = QHBoxLayout(self.title_bar)
        title_layout.setContentsMargins(0, 0, 5, 0)  # 왼쪽 여백을 0으로 설정
        title_layout.setSpacing(5)
        
        # 메뉴 버튼 (햄버거 메뉴)
        self.menu_btn = QPushButton("☰")
        self.menu_btn.setFixedSize(35, 35)  # 버튼 크기를 타이틀바 높이에 맞춤
        self.menu_btn.setObjectName("menuButton")
        self.menu_btn.setToolTip("메뉴")
        self.menu_btn.clicked.connect(self.show_main_menu)
        # 스타일은 update_title_bar_style()에서 설정됨
        
        # 타이틀 라벨
        title_text = f"프롬프트 북 {self.VERSION}"  # 버전 정보 추가
        self.title_label = QLabel(title_text)
        self.title_label.setObjectName("titleLabel")
        self.title_label.setAlignment(Qt.AlignCenter)  # 중앙 정렬 설정
        self.title_label.setMinimumWidth(200)  # 최소 너비 설정
        # 스타일은 update_title_bar_style()에서 설정됨


        
        # 윈도우 컨트롤 버튼들
        self.minimize_btn = QPushButton("－")
        self.minimize_btn.clicked.connect(self.showMinimized)
        self.minimize_btn.setToolTip("최소화")
        
        self.maximize_btn = QPushButton("□")
        self.maximize_btn.clicked.connect(self.toggle_maximize)
        self.maximize_btn.setToolTip("최대화")
        
        self.close_btn = QPushButton("✕")
        self.close_btn.clicked.connect(self.close)
        self.close_btn.setToolTip("닫기")
        
        # 스타일은 update_title_bar_style()에서 설정됨
        
        # 레이아웃에 위젯 추가
        title_layout.addWidget(self.menu_btn)
        title_layout.addStretch()  # 왼쪽 여백
        title_layout.addWidget(self.title_label)
        title_layout.addStretch()  # 오른쪽 여백
        title_layout.addWidget(self.minimize_btn)
        title_layout.addWidget(self.maximize_btn)
        title_layout.addWidget(self.close_btn)
        
        main_layout.addWidget(self.title_bar)
    
    def toggle_maximize(self):
        """윈도우 최대화/복원 토글"""
        if self.isMaximized():
            self.showNormal()
            self.maximize_btn.setText("□")
        else:
            self.showMaximized()
            self.maximize_btn.setText("❐")
        
        # 핸들 상태 업데이트
        self.update_resize_handles()
    
    def mousePressEvent(self, event):
        """마우스 프레스 이벤트 - 타이틀바에서만 드래그 허용"""
        if event.button() == Qt.LeftButton:
            pos = event.position().toPoint()
            
            # 타이틀바 영역에서만 드래그 시작 허용
            if hasattr(self, 'title_bar') and self.title_bar:
                title_bar_global_pos = self.title_bar.mapFromGlobal(event.globalPosition().toPoint())
                if self.title_bar.rect().contains(title_bar_global_pos):
                    self.drag_position = event.globalPosition().toPoint() - self.frameGeometry().topLeft()
                    event.accept()
                    return
            
            # 리사이즈는 투명 핸들에서만 처리하도록 함
            # 기존 마우스 이벤트 기반 리사이즈는 비활성화
            event.ignore()
    
    def mouseMoveEvent(self, event):
        """마우스 무브 이벤트 - 타이틀바 드래그만 처리"""
        # 타이틀바 드래그 중인 경우만 처리
        if event.buttons() == Qt.LeftButton and self.drag_position is not None:
            self.move(event.globalPosition().toPoint() - self.drag_position)
            event.accept()
            return
        
        # 리사이즈와 커서 변경은 투명 핸들에서 처리하므로 여기서는 제거
    
    def mouseReleaseEvent(self, event):
        """마우스 릴리즈 이벤트 - 드래그 종료"""
        self.drag_position = None
        
    def leaveEvent(self, event):
        """마우스가 윈도우를 벗어날 때"""
        super().leaveEvent(event)
    

    

    
    def mouseDoubleClickEvent(self, event):
        """더블클릭으로 최대화/복원"""
        if event.button() == Qt.LeftButton and self.title_bar.rect().contains(
            self.title_bar.mapFromGlobal(event.globalPosition().toPoint())
        ):
            self.toggle_maximize()
            event.accept()
    
    def resizeEvent(self, event):
        """리사이즈 이벤트 - 둥근 모서리 마스크 적용 및 핸들 위치 업데이트"""
        super().resizeEvent(event)
        self.apply_rounded_corners()
        self.update_resize_handles()
        
        # 커스텀 테마이고 배경 이미지가 있는 경우 다시 그리기
        if (self.current_theme == "커스텀 테마" and 
            hasattr(self, 'background_pixmap') and 
            self.background_pixmap):
            self.update()
    
    def showEvent(self, event):
        """쇼 이벤트 - 초기 둥근 모서리 적용"""
        super().showEvent(event)
        self.apply_rounded_corners()
    
    def changeEvent(self, event):
        """윈도우 상태 변경 이벤트 - 핸들 상태 업데이트"""
        super().changeEvent(event)
        if event.type() == QEvent.WindowStateChange:
            # 핸들 상태 업데이트
            self.update_resize_handles()

    def toggle_always_on_top(self):
        """창 맨 위에 고정 토글"""
        self.always_on_top = not self.always_on_top
    
        # 현재 창 플래그 가져오기
        current_flags = self.windowFlags()
    
        if self.always_on_top:
            # 맨 위에 고정 플래그 추가
            new_flags = current_flags | Qt.WindowStaysOnTopHint
        else:
            # 맨 위에 고정 플래그 제거
            new_flags = current_flags & ~Qt.WindowStaysOnTopHint
    
        # 창 플래그 업데이트
        self.setWindowFlags(new_flags)
    
        # 창을 다시 표시 (플래그 변경 후 필요)
        self.show()
    
        # 설정 저장
        self.save_ui_settings()
    
        # 상태 메시지 표시
        status_text = "활성화" if self.always_on_top else "비활성화"
        print(f"[DEBUG] 창 맨 위에 고정: {status_text}")

    def setup_system_tray(self):
        """시스템 트레이 설정"""
        # 시스템 트레이 지원 확인
        if not QSystemTrayIcon.isSystemTrayAvailable():
            print("[DEBUG] 시스템 트레이를 사용할 수 없습니다.")
            return
        
        # 트레이 아이콘 생성
        self.tray_icon = QSystemTrayIcon(self)
        
        # 아이콘 설정
        try:
            if getattr(sys, 'frozen', False):
                # PyInstaller로 빌드된 exe에서는 임시 폴더의 아이콘 사용
                icon_path = os.path.join(sys._MEIPASS, "icon.ico")
                if os.path.exists(icon_path):
                    self.tray_icon.setIcon(QIcon(icon_path))
                else:
                    # 기본 아이콘 사용
                    self.tray_icon.setIcon(self.style().standardIcon(QStyle.SP_ComputerIcon))
            else:
                # 개발 환경에서는 로컬 아이콘 파일 사용
                if os.path.exists("icon.ico"):
                    self.tray_icon.setIcon(QIcon("icon.ico"))
                elif os.path.exists("icon.png"):
                    self.tray_icon.setIcon(QIcon("icon.png"))
                else:
                    # 기본 아이콘 사용
                    self.tray_icon.setIcon(self.style().standardIcon(QStyle.SP_ComputerIcon))
        except Exception as e:
            print(f"[DEBUG] 트레이 아이콘 설정 실패: {e}")
            # 기본 아이콘 사용
            self.tray_icon.setIcon(self.style().standardIcon(QStyle.SP_ComputerIcon))
        
        # 트레이 아이콘 툴팁 설정
        self.tray_icon.setToolTip(f"프롬프트 북 {self.VERSION}")
        
        # 트레이 메뉴 생성
        tray_menu = QMenu()
        
        # 창 표시/숨기기
        show_action = QAction("창 표시", self)
        show_action.triggered.connect(self.show_window)
        tray_menu.addAction(show_action)
        
        tray_menu.addSeparator()
        
        # 종료
        quit_action = QAction("종료", self)
        quit_action.triggered.connect(self.quit_application)
        tray_menu.addAction(quit_action)
        
        # 트레이 아이콘에 메뉴 설정
        self.tray_icon.setContextMenu(tray_menu)
        
        # 트레이 아이콘 더블클릭 시 창 표시
        self.tray_icon.activated.connect(self.on_tray_icon_activated)
        
        # 트레이 아이콘 표시
        self.tray_icon.show()

    def toggle_system_tray(self):
        """시스템 트레이 상주 토글"""
        self.stay_in_tray = not self.stay_in_tray
        
        # 설정 저장
        self.save_ui_settings()
        
        # 상태 메시지 표시
        status_text = "활성화" if self.stay_in_tray else "비활성화"
        print(f"[DEBUG] 프롬프트북 - 시스템 트레이 상주: {status_text}")
    
    def toggle_ui_flip(self):
        """UI 좌우반전 토글"""
        print(f"\n[DEBUG] ===== UI 좌우반전 시작 =====")
        
        current_sizes = self.main_splitter.sizes()
        print(f"[DEBUG] 현재 스플리터 크기: {current_sizes}")
        
        # 위젯들을 임시로 제거
        print(f"[DEBUG] 위젯 개수: {self.main_splitter.count()}")
        left_widget = self.main_splitter.widget(0)
        middle_widget = self.main_splitter.widget(1)
        right_widget = self.main_splitter.widget(2)
        print(f"[DEBUG] 위젯 정보 - 왼쪽: {type(left_widget).__name__}, 중간: {type(middle_widget).__name__}, 오른쪽: {type(right_widget).__name__}")
        
        # 스플리터에서 모든 위젯 제거
        print(f"[DEBUG] 모든 위젯 제거 중...")
        for i in range(self.main_splitter.count()):
            widget = self.main_splitter.widget(0)
            widget.setParent(None)
        print(f"[DEBUG] 위젯 제거 완료, 남은 위젯 개수: {self.main_splitter.count()}")
        
        # 상태 토글
        self.ui_flipped = not getattr(self, 'ui_flipped', False)
        print(f"[DEBUG] UI 반전 상태 토글: {self.ui_flipped}")
        
        # 위젯 순서 변경 (항상 좌우 교체)
        print(f"[DEBUG] 🔄 위젯 순서 교체 중...")
        self.main_splitter.addWidget(right_widget)   # 오른쪽 → 왼쪽
        self.main_splitter.addWidget(middle_widget)  # 중간 유지
        self.main_splitter.addWidget(left_widget)    # 왼쪽 → 오른쪽
        print(f"[DEBUG] 위젯 순서 교체 완료")
        
        # Qt 이벤트 처리 강제 실행
        from PySide6.QtWidgets import QApplication
        QApplication.processEvents()
        
        # 스플리터 레이아웃 강제 업데이트
        self.main_splitter.update()
        self.main_splitter.repaint()
        QApplication.processEvents()
        
        # 크기도 좌우 교체 (항상 첫 번째와 세 번째 교체)
        desired_sizes = [current_sizes[2], current_sizes[1], current_sizes[0]]
        print(f"[DEBUG] 원하는 크기: {current_sizes} → {desired_sizes}")
        
        # Qt 버그 대응: 반대로 설정
        reversed_sizes = [desired_sizes[2], desired_sizes[1], desired_sizes[0]]
        print(f"[DEBUG] Qt 버그 대응: 반대로 설정 {reversed_sizes}")
        
        # 여러 번 시도해서 크기 설정
        for attempt in range(3):
            self.main_splitter.setSizes(reversed_sizes)
            QApplication.processEvents()
            actual_sizes = self.main_splitter.sizes()
            print(f"[DEBUG] 시도 {attempt + 1}: 설정 {reversed_sizes} → 실제 {actual_sizes}")
            if actual_sizes == desired_sizes:
                print(f"[DEBUG] 🎉 성공! 원하는 크기 달성: {actual_sizes}")
                break
        
        print(f"[DEBUG] ✅ UI 좌우반전 완료 - 최종 적용된 크기: {actual_sizes}")
        
        # 설정 저장
        print(f"[DEBUG] 설정 저장 중...")
        self.save_ui_settings()
        print(f"[DEBUG] ===== UI 좌우반전 완료 =====\n")

    def on_tray_icon_activated(self, reason):
        """트레이 아이콘 클릭 이벤트 처리"""
        if reason == QSystemTrayIcon.DoubleClick:
            self.show_window()

    def show_window(self):
        """창 표시"""
        self.show()
        self.raise_()
        self.activateWindow()

    def quit_application(self):
        """애플리케이션 완전 종료"""
        self.save_ui_settings()
        if hasattr(self, 'tray_icon'):
            self.tray_icon.hide()
        QApplication.quit()

    def apply_rounded_corners(self):
        """윈도우에 둥근 모서리 마스크 적용 (정확한 크기 매칭)"""
        # 윈도우 크기 가져오기
        rect = self.rect()
        
        # 크기가 너무 작으면 둥근 모서리 적용하지 않음
        if rect.width() < 20 or rect.height() < 20:
            return
        
        # 정확한 윈도우 크기로 픽스맵 생성
        pixmap = QPixmap(rect.size())
        pixmap.fill(Qt.transparent)  # 투명으로 초기화
        
        # 고품질 페인터로 둥근 사각형 그리기
        painter = QPainter(pixmap)
        painter.setRenderHint(QPainter.Antialiasing, True)
        painter.setBrush(QBrush(Qt.black))  # 불투명 영역
        painter.setPen(Qt.NoPen)
        
        # 정확한 크기의 둥근 사각형 그리기 (1픽셀 여백 제거)
        draw_rect = QRectF(0, 0, rect.width(), rect.height())
        painter.drawRoundedRect(draw_rect, self.border_radius, self.border_radius)
        painter.end()
        
        # 픽스맵을 마스크로 변환
        mask = pixmap.createMaskFromColor(Qt.transparent, Qt.MaskInColor)
        
        # 윈도우 마스크 설정
        self.setMask(mask)
    
    def show_main_menu(self):
        """메인 메뉴 표시"""
        menu = QMenu(self)
        
        # 메뉴 스타일 적용
        menu_style = self.get_menu_style()
        menu.setStyleSheet(menu_style)
        
        # 파일 메뉴
        file_menu = menu.addMenu("📁 파일")
        file_menu.setStyleSheet(menu_style)  # 서브메뉴에도 적용
        
        # 선택된 북 저장하기
        save_book_action = QAction("💾 선택된 북 저장하기", self)
        save_book_action.triggered.connect(self.save_selected_book)
        file_menu.addAction(save_book_action)

        # 저장된 북 불러오기
        load_book_action = QAction("📂 저장된 북 불러오기", self)
        load_book_action.triggered.connect(self.load_saved_book)
        file_menu.addAction(load_book_action)
        
        # 구분선 추가
        file_menu.addSeparator()
        
        # 백업 서브메뉴
        backup_menu = file_menu.addMenu("💾 백업")
        backup_menu.setStyleSheet(menu_style)  # 서브메뉴에도 적용
        
        # 현재 북 리스트 백업
        backup_action = QAction("📦 현재 북 리스트 백업", self)
        backup_action.triggered.connect(self.backup_book_list)
        backup_menu.addAction(backup_action)
        
        # 백업된 북 리스트로 복구
        restore_action = QAction("📥 백업된 북 리스트로 복구", self)
        restore_action.triggered.connect(self.restore_book_list)
        backup_menu.addAction(restore_action)
        
        # 테마 메뉴
        theme_menu = menu.addMenu("🎨 테마")
        theme_menu.setStyleSheet(menu_style)  # 서브메뉴에도 적용
        
        # 미리 생성된 테마 액션들을 메뉴에 추가
        for action in self.theme_group.actions():
            theme_menu.addAction(action)
            # 현재 테마 체크 상태 업데이트 (current_theme이 초기화된 경우에만)
            if hasattr(self, 'current_theme') and action.text() == self.current_theme:
                action.setChecked(True)
        else:
                action.setChecked(False)
        
        # 옵션 메뉴
        options_menu = menu.addMenu("⚙️ 옵션")
        options_menu.setStyleSheet(menu_style)
        
        # 창 맨 위에 고정
        always_on_top_action = QAction("📌 창 맨 위에 고정", self)
        always_on_top_action.setCheckable(True)
        always_on_top_action.setChecked(getattr(self, 'always_on_top', False))
        always_on_top_action.triggered.connect(self.toggle_always_on_top)
        options_menu.addAction(always_on_top_action)
        
        # 윈도우 투명도 조절
        window_opacity_action = QAction("🌫️ 윈도우 투명도 조절", self)
        window_opacity_action.triggered.connect(self.adjust_window_opacity)
        options_menu.addAction(window_opacity_action)
        
        # 커스텀 테마 투명도 조절 (커스텀 테마일 때만 표시)
        if hasattr(self, 'current_theme') and self.current_theme == "커스텀 테마":
            custom_transparency_action = QAction("🎨 커스텀 테마 투명도 조절", self)
            custom_transparency_action.triggered.connect(self.adjust_custom_theme_transparency)
            options_menu.addAction(custom_transparency_action)
        
        # UI 좌우반전
        ui_flip_action = QAction("🔄 UI 좌우반전", self)
        ui_flip_action.triggered.connect(self.toggle_ui_flip)
        ui_flip_action.setStatusTip("UI 레이아웃을 좌우로 반전시킵니다 (이미지 | 내용 | 리스트)")
        options_menu.addAction(ui_flip_action)
        
        # 시스템 트레이에 상주
        tray_action = QAction("🔽 시스템 트레이에 상주 (X로 닫아도 종료되지 않음)", self)
        tray_action.setCheckable(True)
        tray_action.setChecked(getattr(self, 'stay_in_tray', False))
        tray_action.triggered.connect(self.toggle_system_tray)
        tray_action.setStatusTip("체크하면 X로 닫아도 프로그램이 종료되지 않고 시스템 트레이에 남아있습니다")
        options_menu.addAction(tray_action)
        
        # 단축키 안내
        shortcuts_action = QAction("⌨️ 단축키 안내", self)
        shortcuts_action.triggered.connect(self.show_shortcuts_help)
        menu.addAction(shortcuts_action)
        
        # 사용자 매뉴얼
        manual_action = QAction("📖 사용자 매뉴얼", self)
        manual_action.triggered.connect(self.show_user_manual)
        menu.addAction(manual_action)
        
        # 후원 메뉴
        donate_action = QAction("💖 Donate", self)
        donate_action.triggered.connect(self.show_kakao_info)
        menu.addAction(donate_action)
        
        # AI 기능 테스터 (숨김)
        # if AITesterDialog is not None:
        #     ai_tester_action = QAction("🤖 AI 기능 테스터", self)
        #     ai_tester_action.triggered.connect(self.show_ai_tester)
        #     menu.addAction(ai_tester_action)
        
        # 메뉴 표시 위치 계산 (메뉴 버튼 아래쪽)
        button_pos = self.menu_btn.mapToGlobal(self.menu_btn.rect().bottomLeft())
        menu.exec(button_pos)

    def show_donate_options(self):
        """후원 옵션 메뉴 표시"""
        menu = QMenu(self)
        
        # 메뉴 스타일 적용
        menu_style = self.get_menu_style()
        menu.setStyleSheet(menu_style)
        
        # 후원 옵션들
        paypal_action = QAction("💳 PayPal", self)
        paypal_action.triggered.connect(lambda: self.open_url("https://paypal.me/qohqohqoh"))
        menu.addAction(paypal_action)
        
        menu.addSeparator()
        
        # 국내 후원 옵션
        kakao_action = QAction("💛 카카오페이", self)
        kakao_action.triggered.connect(self.show_kakao_info)
        menu.addAction(kakao_action)
        
        # 메뉴 표시 위치 계산 (메뉴 버튼 아래쪽)
        button_pos = self.menu_btn.mapToGlobal(self.menu_btn.rect().bottomLeft())
        menu.exec(button_pos)
    
    def open_url(self, url):
        """URL을 기본 브라우저에서 열기"""
        import webbrowser
        webbrowser.open(url)
    
    def show_kakao_info(self):
        """카카오페이 QR코드 팝업창 표시"""
        import os
        import base64
        from io import BytesIO
        
        # base64에서 이미지 데이터 생성
        try:
            image_data = base64.b64decode(KAKAO_PAY_IMAGE_BASE64)
            image_buffer = BytesIO(image_data)
        except Exception as e:
            QMessageBox.warning(
                self, 
                "카카오페이 QR코드", 
                f"QR코드 이미지를 불러올 수 없습니다.\n오류: {str(e)}\n\n관리자에게 문의해주세요! 💛"
            )
            return
        
        # 커스텀 팝업 다이얼로그 생성
        dialog = QDialog(self)
        dialog.setWindowTitle("💛 카카오페이 후원")
        dialog.setModal(True)
        dialog.setFixedSize(400, 550)
        
        # 윈도우 플래그 설정으로 떨림 방지
        dialog.setWindowFlags(Qt.Dialog | Qt.MSWindowsFixedSizeDialogHint)
        
        # 렌더링 최적화 속성 설정
        dialog.setAttribute(Qt.WA_OpaquePaintEvent, True)
        dialog.setAttribute(Qt.WA_NoSystemBackground, False)
        dialog.setAttribute(Qt.WA_StaticContents, True)
        
        # 현재 테마 적용
        current_theme = getattr(self, 'current_theme', '어두운 모드')
        theme = self.THEMES.get(current_theme, self.THEMES['어두운 모드'])
        
        dialog.setStyleSheet(f"""
            QDialog {{
                background-color: {theme['background']};
                color: {theme['text']};
                border: 2px solid {theme['border']};
                border-radius: 10px;
            }}
            QLabel {{
                color: {theme['text']};
                background-color: transparent;
            }}
            QPushButton {{
                background-color: {theme['button']};
                border: 1px solid {theme['border']};
                color: {theme['text']};
                padding: 8px 16px;
                border-radius: 5px;
                font-weight: bold;
            }}
            QPushButton:hover {{
                background-color: {theme['button_hover']};
            }}
        """)
        
        layout = QVBoxLayout(dialog)
        layout.setSpacing(15)
        layout.setContentsMargins(20, 20, 20, 20)
        
        # 메시지 라벨
        message_label = QLabel()
        message_label.setText(
            "주기적인 카페인 주입이 필요합니다.☕"
        )
        message_label.setAlignment(Qt.AlignCenter)
        message_label.setWordWrap(True)
        message_label.setStyleSheet("font-size: 14px; padding: 10px;")
        layout.addWidget(message_label)
        
        # QR코드 이미지 표시
        try:
            # base64 데이터에서 직접 QPixmap 생성
            image_data = base64.b64decode(KAKAO_PAY_IMAGE_BASE64)
            pixmap = QPixmap()
            pixmap.loadFromData(image_data)
            
            if not pixmap.isNull():
                # 이미지 크기 조정 (최대 300x300, 고품질 스케일링)
                scaled_pixmap = pixmap.scaled(300, 300, Qt.KeepAspectRatio, Qt.SmoothTransformation)
                
                image_label = QLabel()
                image_label.setPixmap(scaled_pixmap)
                image_label.setAlignment(Qt.AlignCenter)
                image_label.setMinimumSize(310, 310)  # 고정 크기로 레이아웃 안정화
                image_label.setMaximumSize(310, 310)
                image_label.setScaledContents(False)  # 자동 스케일링 비활성화
                
                # 이미지 캐싱 및 렌더링 최적화
                image_label.setAttribute(Qt.WA_OpaquePaintEvent, True)
                image_label.setAttribute(Qt.WA_NoSystemBackground, False)
                
                image_label.setStyleSheet("""
                    QLabel {
                        border: 2px solid #cccccc; 
                        border-radius: 5px; 
                        padding: 5px; 
                        background-color: white;
                        qproperty-alignment: AlignCenter;
                    }
                """)
                
                # 이미지를 중앙정렬하여 레이아웃에 추가
                image_layout = QHBoxLayout()
                image_layout.addStretch()
                image_layout.addWidget(image_label)
                image_layout.addStretch()
                layout.addLayout(image_layout)
            else:
                error_label = QLabel("QR코드 이미지를 불러올 수 없습니다.")
                error_label.setAlignment(Qt.AlignCenter)
                layout.addWidget(error_label)
        except Exception as e:
            error_label = QLabel(f"이미지 로드 오류: {str(e)}")
            error_label.setAlignment(Qt.AlignCenter)
            layout.addWidget(error_label)
        
        # 감사 메시지
        thanks_label = QLabel("💖 후원해주셔서 정말 감사합니다! 💖")
        thanks_label.setAlignment(Qt.AlignCenter)
        thanks_label.setStyleSheet(f"font-weight: bold; font-size: 12px; color: {theme['primary']};")
        layout.addWidget(thanks_label)
        
        # 닫기 버튼
        close_button = QPushButton("닫기")
        close_button.clicked.connect(dialog.accept)
        layout.addWidget(close_button)
        
        # 다이얼로그 표시
        dialog.exec()
    
    def cleanup_unused_images(self):
        """사용되지 않는 이미지를 휴지통으로 이동합니다."""
        if send2trash is None:
            QMessageBox.warning(self, "오류", "send2trash 모듈이 설치되지 않았습니다.\npip install send2trash로 설치해 주세요.")
            return
            
        # images 폴더가 존재하지 않으면 아무것도 안 함
        images_dir = get_images_directory()
        if not os.path.exists(images_dir):
            return
        
        # 현재 사용 중인 이미지 경로들 수집
        used_images = set()
        for book_name, book_data in self.state.books.items():
            pages = book_data.get("pages", [])
            for page in pages:
                image_path = page.get("image_path", "")
                if image_path and os.path.exists(image_path):
                    # 절대 경로로 변환하여 비교
                    used_images.add(os.path.abspath(image_path))
        
        # images 폴더의 모든 이미지 파일 찾기
        image_extensions = {'.png', '.jpg', '.jpeg', '.bmp', '.gif', '.tiff', '.tif', '.webp'}
        all_images = []
        
        for root, dirs, files in os.walk(images_dir):
            for file in files:
                file_path = os.path.join(root, file)
                if os.path.splitext(file)[1].lower() in image_extensions:
                    all_images.append(os.path.abspath(file_path))
        
        # 사용되지 않는 이미지 찾기
        unused_images = []
        for image_path in all_images:
            if image_path not in used_images:
                unused_images.append(image_path)
        
        if not unused_images:
            QMessageBox.information(self, "정리 완료", "사용되지 않는 이미지가 없습니다.")
            return
        
        # 사용자에게 확인
        count = len(unused_images)
        file_list = "\n".join([os.path.basename(path) for path in unused_images[:10]])
        if count > 10:
            file_list += f"\n... 및 {count - 10}개 더"
            
        reply = QMessageBox.question(
            self,
            "이미지 정리 확인",
            f"사용되지 않는 이미지 {count}개를 휴지통으로 이동하시겠습니까?\n\n"
            f"이동될 파일들:\n{file_list}",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            success_count = 0
            failed_files = []
            
            for image_path in unused_images:
                try:
                    send2trash(image_path)
                    success_count += 1
                    print(f"[DEBUG] 휴지통으로 이동: {image_path}")
                except Exception as e:
                    failed_files.append(os.path.basename(image_path))
                    print(f"[ERROR] 휴지통 이동 실패: {image_path} - {e}")
            
            # 결과 보고
            if failed_files:
                QMessageBox.warning(
                    self,
                    "정리 부분 완료",
                    f"{success_count}개의 이미지가 휴지통으로 이동되었습니다.\n"
                    f"실패한 파일 {len(failed_files)}개:\n" + 
                    "\n".join(failed_files[:5]) + 
                    (f"\n... 및 {len(failed_files) - 5}개 더" if len(failed_files) > 5 else "")
                )
            else:
                QMessageBox.information(
                    self,
                    "정리 완료",
                    f"{success_count}개의 사용되지 않는 이미지가 휴지통으로 이동되었습니다."
                )

    def cleanup_unused_images_silent(self):
        """조용히 사용되지 않는 이미지를 휴지통으로 이동 (확인 대화상자 없음)"""
        if send2trash is None:
            return
            
        try:
            # images 폴더가 존재하지 않으면 아무것도 안 함
            images_dir = get_images_directory()
            if not os.path.exists(images_dir):
                return
            
            # 현재 사용 중인 이미지 경로들 수집
            used_images = set()
            for book_name, book_data in self.state.books.items():
                pages = book_data.get("pages", [])
                for page in pages:
                    image_path = page.get("image_path", "")
                    if image_path and os.path.exists(image_path):
                        # 절대 경로로 변환하여 비교
                        used_images.add(os.path.abspath(image_path))
            
            # images 폴더의 모든 이미지 파일 찾기
            image_extensions = {'.png', '.jpg', '.jpeg', '.bmp', '.gif', '.tiff', '.tif', '.webp'}
            unused_images = []
            
            for root, dirs, files in os.walk(images_dir):
                for file in files:
                    file_path = os.path.join(root, file)
                    if os.path.splitext(file)[1].lower() in image_extensions:
                        abs_path = os.path.abspath(file_path)
                        if abs_path not in used_images:
                            unused_images.append(abs_path)
            
            # 사용되지 않는 이미지를 휴지통으로 이동
            for image_path in unused_images:
                try:
                    send2trash(image_path)
                    print(f"[DEBUG] 자동 정리: 휴지통으로 이동 - {os.path.basename(image_path)}")
                except Exception as e:
                    print(f"[ERROR] 자동 정리 실패: {image_path} - {e}")
                    
        except Exception as e:
            print(f"[ERROR] 자동 이미지 정리 중 오류: {e}")
    
    def show_shortcuts_help(self):
        """단축키 안내 다이얼로그 표시"""
        dialog = QDialog(self)
        dialog.setWindowTitle("⌨️ 단축키 안내")
        dialog.setModal(True)
        dialog.setFixedSize(600, 500)
        
        # 윈도우 플래그 설정
        dialog.setWindowFlags(Qt.Dialog | Qt.MSWindowsFixedSizeDialogHint)
        
        # 현재 테마 적용
        current_theme = getattr(self, 'current_theme', '어두운 모드')
        theme = self.THEMES.get(current_theme, self.THEMES['어두운 모드'])
        
        dialog.setStyleSheet(f"""
            QDialog {{
                background-color: {theme['background']};
                color: {theme['text']};
                border: 2px solid {theme['border']};
                border-radius: 10px;
            }}
            QLabel {{
                color: {theme['text']};
                background-color: transparent;
            }}
            QPushButton {{
                background-color: {theme['button']};
                border: 1px solid {theme['border']};
                color: {theme['text']};
                padding: 8px 16px;
                border-radius: 5px;
                font-weight: bold;
            }}
            QPushButton:hover {{
                background-color: {theme['button_hover']};
            }}
            QScrollArea {{
                background-color: {theme['surface']};
                border: 1px solid {theme['border']};
                border-radius: 5px;
            }}
            QWidget#scrollContent {{
                background-color: {theme['surface']};
            }}
        """)
        
        layout = QVBoxLayout(dialog)
        layout.setSpacing(15)
        layout.setContentsMargins(20, 20, 20, 20)
        
        # 제목
        title_label = QLabel("⌨️ 프롬프트북 단축키 안내")
        title_label.setAlignment(Qt.AlignCenter)
        title_label.setStyleSheet("font-size: 18px; font-weight: bold; padding: 10px;")
        layout.addWidget(title_label)
        
        # 스크롤 영역
        scroll_area = QScrollArea()
        scroll_widget = QWidget()
        scroll_widget.setObjectName("scrollContent")
        scroll_layout = QVBoxLayout(scroll_widget)
        
        # 단축키 데이터 (메인 메뉴 순서와 일치)
        shortcuts_data = [
            {
                "category": "📁 파일 관리",
                "shortcuts": [
                    ("💾 저장 버튼", "선택된 북을 Zip으로 저장"),
                    ("📂 불러오기 버튼", "저장된 북 Zip 파일 불러오기"),
                    ("📋 복사 버튼", "프롬프트 내용 클립보드 복사"),
                ]
            },
            {
                "category": "📚 북 관리",
                "shortcuts": [
                    ("➕ 북 추가 버튼", "새 북 추가"),
                    ("우클릭", "북 컨텍스트 메뉴 (추가/삭제/이름변경/이모지변경)"),
                    ("더블클릭", "북 이름 변경"),
                    ("F2", "북 이름 변경 (북 포커스 시)"),
                    ("Delete", "북 삭제 (다중 선택 지원)"),
                    ("❤️ 클릭", "북 즐겨찾기 토글"),
                ]
            },
            {
                "category": "📝 페이지 관리",
                "shortcuts": [
                    ("Ctrl + N", "새 페이지 추가"),
                    ("Ctrl + S", "현재 페이지 저장"),
                    ("Ctrl + C", "페이지 복사 (다중 선택 지원)"),
                    ("Ctrl + X", "페이지 잘라내기 (다중 선택 지원)"),
                    ("Ctrl + V", "페이지 붙여넣기 (북 선택 후)"),
                    ("Ctrl + D", "페이지 복제 (다중 선택 지원)"),
                    ("Delete", "페이지 삭제 (다중 선택 지원)"),
                    ("F2", "페이지 이름 변경 (페이지 포커스 시)"),
                    ("더블클릭", "페이지 이름 변경"),
                    ("❤️ 클릭", "페이지 즐겨찾기 토글"),
                    ("우클릭", "페이지 컨텍스트 메뉴 (잠금/이모지변경/이름변경)"),
                ]
            },
            {
                "category": "🖼️ 이미지 관리",
                "shortcuts": [
                    ("이미지 드래그", "페이지에 이미지 추가"),
                    ("🖼️ 이미지 버튼", "이미지 파일 선택하여 추가"),
                    ("🗑️ 제거 버튼", "페이지의 이미지 제거"),
                    ("마우스 휠", "이미지 확대/축소"),
                    ("이미지 드래그", "이미지 뷰어에서 이미지 이동"),
                ]
            },
            {
                "category": "🔢 다중 선택 및 정렬",
                "shortcuts": [
                    ("Ctrl + 클릭", "개별 항목을 하나씩 선택/해제"),
                    ("Shift + 클릭", "첫 선택부터 클릭 위치까지 범위 선택"),
                    ("Ctrl + A", "모든 항목 선택 (리스트 포커스 시)"),
                    ("드래그", "선택된 여러 항목 동시 이동 (커스텀 정렬 모드)"),
                    ("정렬 선택기", "오름차순/내림차순/커스텀 정렬 변경"),
                ]
            }
        ]
        
        # 각 카테고리별로 단축키 표시
        for category_data in shortcuts_data:
            # 카테고리 제목
            category_label = QLabel(category_data["category"])
            category_label.setStyleSheet(f"""
                font-size: 16px; 
                font-weight: bold; 
                color: {theme['primary']}; 
                padding: 10px 0px 5px 0px;
            """)
            scroll_layout.addWidget(category_label)
            
            # 단축키 목록
            for shortcut, description in category_data["shortcuts"]:
                shortcut_layout = QHBoxLayout()
                
                # 단축키 라벨
                shortcut_label = QLabel(shortcut)
                shortcut_label.setStyleSheet(f"""
                    background-color: {theme['button']};
                    border: 1px solid {theme['border']};
                    padding: 4px 8px;
                    border-radius: 3px;
                    font-family: 'Consolas', 'Monaco', monospace;
                    font-weight: bold;
                    min-width: 120px;
                """)
                shortcut_label.setAlignment(Qt.AlignCenter)
                shortcut_label.setFixedWidth(140)
                
                # 설명 라벨
                desc_label = QLabel(description)
                desc_label.setStyleSheet("padding: 4px 8px;")
                
                shortcut_layout.addWidget(shortcut_label)
                shortcut_layout.addWidget(desc_label)
                shortcut_layout.addStretch()
                
                scroll_layout.addLayout(shortcut_layout)
            
            # 카테고리 간 간격
            scroll_layout.addSpacing(10)
        
        scroll_layout.addStretch()
        scroll_area.setWidget(scroll_widget)
        scroll_area.setWidgetResizable(True)
        layout.addWidget(scroll_area)
        
        # 닫기 버튼
        close_button = QPushButton("닫기")
        close_button.clicked.connect(dialog.accept)
        layout.addWidget(close_button)
        
        # 다이얼로그 표시
        dialog.exec()

    def show_user_manual(self):
        """사용자 매뉴얼 다이얼로그 표시"""
        dialog = QDialog(self)
        dialog.setWindowTitle("📖 프롬프트북 사용자 매뉴얼")
        dialog.setModal(True)
        dialog.setFixedSize(900, 700)
        
        # 윈도우 플래그 설정
        dialog.setWindowFlags(Qt.Dialog | Qt.MSWindowsFixedSizeDialogHint)
        
        # 현재 테마 적용
        current_theme = getattr(self, 'current_theme', '어두운 모드')
        theme = self.THEMES.get(current_theme, self.THEMES['어두운 모드'])
        
        dialog.setStyleSheet(f"""
            QDialog {{
                background-color: {theme['background']};
                color: {theme['text']};
                border: 2px solid {theme['border']};
                border-radius: 10px;
            }}
            QLabel {{
                color: {theme['text']};
                background-color: transparent;
            }}
            QPushButton {{
                background-color: {theme['button']};
                border: 1px solid {theme['border']};
                color: {theme['text']};
                padding: 8px 16px;
                border-radius: 5px;
                font-weight: bold;
            }}
            QPushButton:hover {{
                background-color: {theme['button_hover']};
            }}
            QScrollArea {{
                background-color: {theme['surface']};
                border: 1px solid {theme['border']};
                border-radius: 5px;
            }}
            QWidget#scrollContent {{
                background-color: {theme['surface']};
            }}
            QTreeWidget {{
                background-color: {theme['surface']};
                border: 1px solid {theme['border']};
                border-radius: 5px;
                color: {theme['text']};
                selection-background-color: {theme['selected']};
                outline: none;
            }}
            QTreeWidget::item {{
                padding: 8px;
                border-bottom: 1px solid {theme['border']};
            }}
            QTreeWidget::item:hover {{
                background-color: {theme['hover']};
            }}
            QTreeWidget::item:selected {{
                background-color: {theme['selected']};
                color: {theme['text']};
            }}
            QTreeWidget::branch:has-children:!has-siblings:closed,
            QTreeWidget::branch:closed:has-children:has-siblings {{
                border-image: none;
                image: url(none);
            }}
            QTreeWidget::branch:open:has-children:!has-siblings,
            QTreeWidget::branch:open:has-children:has-siblings {{
                border-image: none;
                image: url(none);
            }}
            QTextEdit {{
                background-color: {theme['surface']};
                border: 1px solid {theme['border']};
                border-radius: 5px;
                color: {theme['text']};
                padding: 10px;
                font-size: 13px;
                line-height: 1.5;
            }}
        """)
        
        layout = QHBoxLayout(dialog)
        layout.setSpacing(15)
        layout.setContentsMargins(20, 20, 20, 20)
        
        # 왼쪽: 목차 트리
        tree_widget = QTreeWidget()
        tree_widget.setHeaderLabel("📚 목차")
        tree_widget.setFixedWidth(250)
        tree_widget.setRootIsDecorated(True)
        
        # 오른쪽: 내용 표시 영역
        content_area = QTextEdit()
        content_area.setReadOnly(True)
        
        # 매뉴얼 데이터 구조
        manual_data = {
            "🚀 시작하기": {
                "content": """
<h2>🚀 시작하기</h2>

<h3>첫 실행</h3>
<p>프롬프트북을 처음 실행하면 깔끔한 어두운 테마의 인터페이스가 나타납니다.</p>

<p><strong>초기 상태:</strong></p>
<ul>
<li>왼쪽: 빈 북 리스트</li>
<li>가운데: 빈 페이지 리스트</li>
<li>오른쪽: 페이지 편집 영역</li>
</ul>

<h3>첫 번째 북 만들기</h3>
<ol>
<li>왼쪽 북 리스트 영역에서 <strong>우클릭</strong></li>
<li>컨텍스트 메뉴에서 <strong>"북 추가"</strong> 선택</li>
<li>북 이름 입력 (예: "캐릭터 설정")</li>
<li><strong>Enter</strong> 키로 확인</li>
</ol>

<h3>첫 번째 페이지 만들기</h3>
<ol>
<li>북을 선택한 상태에서 가운데 페이지 리스트에서 <strong>우클릭</strong></li>
<li><strong>"페이지 추가"</strong> 선택 또는 <strong>Ctrl+N</strong> 단축키 사용</li>
<li>페이지 이름 입력 (예: "주인공")</li>
<li>오른쪽 편집 영역에서 내용 작성</li>
</ol>
                """,
                "children": {}
            },
            "🖥️ 인터페이스": {
                "content": """
<h2>🖥️ 인터페이스 개요</h2>

<h3>전체 레이아웃</h3>
<p>프롬프트북은 3개의 주요 패널로 구성되어 있습니다:</p>

<h4>상단 타이틀 바</h4>
<ul>
<li><strong>☰ 햄버거 메뉴:</strong> 모든 주요 기능 접근</li>
<li><strong>윈도우 컨트롤:</strong> 최소화, 최대화, 닫기</li>
</ul>

<h4>햄버거 메뉴 구조</h4>
<ul>
<li><strong>📁 파일:</strong> 선택된 북 저장하기, 저장된 북 불러오기</li>
<li><strong>🎨 테마:</strong> 모든 테마 선택 (어두운 모드, 밝은 모드, 컬러 테마, 네온 테마, 커스텀 테마)</li>
<li><strong>⚙️ 옵션:</strong> 윈도우 투명도 조절, 커스텀 테마 투명도 조절</li>
<li><strong>💖 Donate:</strong> 카카오페이 후원 QR코드</li>
<li><strong>⌨️ 단축키 안내:</strong> 모든 단축키 목록과 사용법</li>
<li><strong>📖 사용자 매뉴얼:</strong> 상세한 사용법 가이드</li>
</ul>

<p><strong>💡 참고:</strong> "사용되지 않는 이미지 정리" 기능은 파일 메뉴에서 사용할 수 있습니다.</p>

<h4>왼쪽 패널 - 북 관리</h4>
<ul>
<li><strong>북 검색창:</strong> 북 이름으로 실시간 검색</li>
<li><strong>북 리스트:</strong> 생성된 모든 북 표시</li>
<li><strong>북 정렬 선택기:</strong> 이름순/즐겨찾기순/생성일순</li>
</ul>

<h4>가운데 패널 - 페이지 관리</h4>
<ul>
<li><strong>페이지 검색창:</strong> 페이지 이름과 태그로 검색</li>
<li><strong>페이지 리스트:</strong> 선택된 북의 모든 페이지</li>
<li><strong>페이지 정렬 선택기:</strong> 다양한 정렬 옵션</li>
</ul>

<h4>오른쪽 패널 - 페이지 편집</h4>
<ul>
<li><strong>페이지 정보:</strong> 이름, 태그, 설명</li>
<li><strong>프롬프트 내용:</strong> 메인 텍스트 편집 영역</li>
<li><strong>이미지 뷰어:</strong> 첨부된 이미지 표시</li>
<li><strong>이미지 버튼들:</strong> 이미지 불러오기, 이미지 제거</li>
<li><strong>액션 버튼들:</strong> 저장, 복사, 복제 등</li>
</ul>
                """,
                "children": {}
            },
            "📚 북 관리": {
                "content": """
<h2>📚 북 관리</h2>

<h3>북 추가하기</h3>
<p><strong>방법 1: 우클릭 메뉴</strong></p>
<ol>
<li>왼쪽 북 리스트에서 <strong>우클릭</strong></li>
<li><strong>"북 추가"</strong> 선택</li>
<li>북 이름 입력</li>
<li><strong>Enter</strong>로 확인</li>
</ol>

<p><strong>방법 2: 북 추가 버튼</strong></p>
<ol>
<li>왼쪽 북 리스트 하단의 <strong>"➕ 북 추가"</strong> 버튼 클릭</li>
<li>북 이름 입력 후 Enter</li>
</ol>

<h3>북 이름 변경</h3>
<ul>
<li><strong>더블클릭:</strong> 변경할 북을 더블클릭</li>
<li><strong>우클릭 메뉴:</strong> 북에서 우클릭 → "이름 변경"</li>
<li><strong>F2 단축키:</strong> 북 선택 후 F2 키</li>
</ul>

<h3>북 이모지 변경</h3>
<ol>
<li>북에서 <strong>우클릭</strong></li>
<li><strong>"이모지 변경"</strong> 선택</li>
<li>원하는 이모지 클릭</li>
<li>자동으로 적용됨</li>
</ol>

<h3>북 즐겨찾기</h3>
<ol>
<li>북 항목의 <strong>🖤</strong> (또는 <strong>❤️</strong>) 클릭</li>
<li>즐겨찾기 토글됨</li>
<li>즐겨찾기된 북은 <strong>❤️</strong>로 표시</li>
<li>즐겨찾기 순 정렬 시 상단에 표시</li>
</ol>

<p><strong>⚠️ 주의사항:</strong> 북 즐겨찾기 토글 시 북 선택이 해제되고 페이지 리스트가 사라집니다.</p>
                """,
                "children": {}
            },
            "📄 페이지 관리": {
                "content": """
<h2>📄 페이지 관리</h2>

<h3>페이지 추가하기</h3>
<p><strong>전제조건:</strong> 북이 선택되어 있어야 함</p>

<ul>
<li><strong>Ctrl+N:</strong> 가장 빠른 방법</li>
<li><strong>우클릭 메뉴:</strong> 페이지 리스트에서 우클릭 → "페이지 추가"</li>
<li><strong>버튼:</strong> 오른쪽 하단 "추가" 버튼 클릭</li>
</ul>

<h3>페이지 편집하기</h3>
<p><strong>기본 정보 입력:</strong></p>
<ul>
<li><strong>페이지 이름:</strong> 페이지 식별용 제목</li>
<li><strong>태그:</strong> 검색용 키워드 (쉼표로 구분)</li>
<li><strong>설명:</strong> 페이지에 대한 간단한 설명</li>
<li><strong>프롬프트:</strong> 메인 내용 (AI 프롬프트 등)</li>
</ul>

<p><strong>💡 편집 팁:</strong></p>
<ul>
<li>모든 필드는 실시간으로 자동 저장됨</li>
<li><strong>Ctrl+S</strong>로 수동 저장 가능</li>
<li>태그는 검색에 활용됨</li>
</ul>

<h3>페이지 즐겨찾기</h3>
<ol>
<li>페이지 항목의 <strong>🖤</strong> (또는 <strong>❤️</strong>) 클릭</li>
<li>즐겨찾기 토글됨</li>
<li>즐겨찾기된 페이지는 <strong>❤️</strong>로 표시</li>
</ol>

<p><strong>⚠️ 주의사항:</strong> 페이지 즐겨찾기 토글 시 페이지 선택만 해제되고 페이지 리스트는 유지됩니다.</p>

<h3>페이지 잠금</h3>
<ol>
<li>페이지에서 <strong>우클릭</strong></li>
<li><strong>"잠금"</strong> 또는 <strong>"잠금 해제"</strong> 선택</li>
<li>잠긴 페이지는 <strong>🔒</strong> 아이콘 표시</li>
<li>잠긴 페이지는 삭제 불가</li>
</ol>
                """,
                "children": {}
            },
            "🖼️ 이미지 관리": {
                "content": """
<h2>🖼️ 이미지 관리</h2>

<h3>이미지 추가하기</h3>
<p><strong>방법 1: 드래그 앤 드롭</strong></p>
<ol>
<li>파일 탐색기에서 이미지 파일 선택</li>
<li>오른쪽 이미지 영역으로 <strong>드래그</strong></li>
<li>자동으로 이미지가 추가됨</li>
</ol>

<p><strong>방법 2: 버튼 사용</strong></p>
<ol>
<li>오른쪽 하단 <strong>"이미지"</strong> 버튼 클릭</li>
<li>파일 선택 대화상자에서 이미지 선택</li>
<li><strong>"열기"</strong> 클릭</li>
</ol>

<p><strong>지원 형식:</strong> PNG, JPG, JPEG, BMP, GIF, TIFF, TIF, WEBP</p>

<h3>이미지 보기</h3>
<ul>
<li>이미지가 추가되면 오른쪽 영역에 자동 표시</li>
<li>마우스 휠로 <strong>확대/축소</strong> 가능</li>
<li>드래그로 <strong>이미지 이동</strong> 가능</li>
<li>이미지 크기에 맞게 자동 조절</li>
</ul>

<h3>이미지 제거</h3>
<ol>
<li>이미지가 있는 페이지 선택</li>
<li>오른쪽 하단 <strong>"제거"</strong> 버튼 클릭</li>
<li>이미지가 즉시 제거됨</li>
</ol>


                """,
                "children": {}
            },
            "🔍 검색 및 정렬": {
                "content": """
<h2>🔍 검색 및 정렬</h2>

<h3>북 검색</h3>
<ol>
<li>왼쪽 상단 <strong>"북 검색"</strong> 입력창 클릭</li>
<li>검색어 입력 (북 이름 기준)</li>
<li>실시간으로 결과 필터링</li>
<li>검색어 지우면 전체 목록 복원</li>
</ol>

<h3>페이지 검색</h3>
<ol>
<li>가운데 상단 <strong>"페이지 검색"</strong> 입력창 클릭</li>
<li>검색어 입력 (페이지 이름 + 태그 기준)</li>
<li>실시간으로 결과 필터링</li>
<li>검색어 지우면 전체 목록 복원</li>
</ol>

<p><strong>💡 검색 팁:</strong></p>
<ul>
<li>부분 검색 지원 (예: "주인" 입력 시 "주인공" 검색됨)</li>
<li>대소문자 구분 안함</li>
<li>태그도 검색 대상에 포함</li>
</ul>

<h3>정렬 옵션</h3>
<ul>
<li><strong>오름차순 정렬:</strong> A-Z, ㄱ-ㅎ 순</li>
<li><strong>내림차순 정렬:</strong> Z-A, ㅎ-ㄱ 순</li>
<li><strong>즐겨찾기순:</strong> ❤️ 항목이 먼저</li>
<li><strong>생성일순 (최신순):</strong> 최근 생성 순</li>
<li><strong>생성일순 (오래된순):</strong> 오래된 순</li>
<li><strong>커스텀 정렬:</strong> 드래그로 수동 정렬</li>
</ul>

<h3>커스텀 정렬 사용법</h3>
<ol>
<li>정렬 선택기에서 <strong>"커스텀 정렬"</strong> 선택</li>
<li>항목을 <strong>드래그</strong>하여 원하는 위치로 이동</li>
<li>순서가 자동으로 저장됨</li>
<li>다른 정렬 방식 선택 시 커스텀 순서 해제</li>
</ol>
                """,
                "children": {}
            },
            "🔢 다중 선택": {
                "content": """
<h2>🔢 다중 선택 및 일괄 작업</h2>

<h3>다중 선택 방법</h3>
<ul>
<li><strong>Ctrl+클릭:</strong> 원하는 항목들을 하나씩 선택/해제</li>
<li><strong>Shift+클릭:</strong> 첫 선택부터 클릭 위치까지 범위 선택</li>
<li><strong>Ctrl+A:</strong> 현재 포커스된 리스트의 모든 항목 선택</li>
</ul>

<h3>다중 선택 시각적 표시</h3>
<ul>
<li>선택된 항목들은 <strong>하이라이트</strong>로 표시</li>
<li>선택 개수가 상태바에 표시 (예: "3개 선택됨")</li>
</ul>

<h3>다중 북 작업</h3>
<p><strong>다중 북 삭제:</strong></p>
<ol>
<li><strong>Ctrl+클릭</strong>으로 여러 북 선택</li>
<li><strong>Delete</strong> 키</li>
<li>확인 대화상자에서 일괄 삭제 확인</li>
</ol>

<p><strong>다중 북 선택 시 제한사항:</strong></p>
<ul>
<li>페이지 리스트가 숨겨짐</li>
<li>편집 영역이 비활성화됨</li>
<li>북별 개별 작업 불가</li>
</ul>

<h3>다중 페이지 작업</h3>
<p><strong>다중 페이지 복제:</strong></p>
<ol>
<li><strong>Ctrl+클릭</strong>으로 여러 페이지 선택</li>
<li><strong>Ctrl+D</strong></li>
<li>선택된 모든 페이지가 복제됨</li>
<li>마지막 복제된 페이지가 자동 선택됨</li>
</ol>

<p><strong>다중 페이지 삭제:</strong></p>
<ol>
<li><strong>Ctrl+클릭</strong>으로 여러 페이지 선택</li>
<li><strong>Delete</strong> 키</li>
<li>확인 대화상자에서 일괄 삭제 확인</li>
</ol>

<p><strong>다중 페이지 드래그:</strong></p>
<ol>
<li>여러 페이지 선택</li>
<li>선택된 항목 중 하나를 <strong>드래그</strong></li>
<li>선택된 모든 페이지가 함께 이동</li>
</ol>
                """,
                "children": {}
            },
            "⌨️ 단축키": {
                "content": """
<h2>⌨️ 단축키</h2>

<h3>페이지 관리 단축키</h3>
<table border="1" style="border-collapse: collapse; width: 100%;">
<tr style="background-color: rgba(255,255,255,0.1);">
<th style="padding: 8px;">단축키</th>
<th style="padding: 8px;">기능</th>
<th style="padding: 8px;">설명</th>
</tr>
<tr><td style="padding: 8px;"><strong>Ctrl+N</strong></td><td style="padding: 8px;">새 페이지 추가</td><td style="padding: 8px;">현재 선택된 북에 새 페이지 생성</td></tr>
<tr><td style="padding: 8px;"><strong>Ctrl+S</strong></td><td style="padding: 8px;">현재 페이지 저장</td><td style="padding: 8px;">편집 중인 페이지 내용 저장</td></tr>
<tr><td style="padding: 8px;"><strong>Ctrl+D</strong></td><td style="padding: 8px;">페이지 복제</td><td style="padding: 8px;">선택된 페이지(들) 복제</td></tr>
<tr><td style="padding: 8px;"><strong>Delete</strong></td><td style="padding: 8px;">삭제</td><td style="padding: 8px;">선택된 페이지/북 삭제</td></tr>
<tr><td style="padding: 8px;"><strong>F2</strong></td><td style="padding: 8px;">이름 변경</td><td style="padding: 8px;">선택된 항목의 이름 변경</td></tr>
</table>

<h3>다중 선택 단축키</h3>
<table border="1" style="border-collapse: collapse; width: 100%;">
<tr style="background-color: rgba(255,255,255,0.1);">
<th style="padding: 8px;">단축키</th>
<th style="padding: 8px;">기능</th>
<th style="padding: 8px;">설명</th>
</tr>
<tr><td style="padding: 8px;"><strong>Ctrl+클릭</strong></td><td style="padding: 8px;">개별 선택/해제</td><td style="padding: 8px;">원하는 항목들을 하나씩 선택</td></tr>
<tr><td style="padding: 8px;"><strong>Shift+클릭</strong></td><td style="padding: 8px;">범위 선택</td><td style="padding: 8px;">첫 선택부터 클릭 위치까지 선택</td></tr>
<tr><td style="padding: 8px;"><strong>Ctrl+A</strong></td><td style="padding: 8px;">전체 선택</td><td style="padding: 8px;">현재 리스트의 모든 항목 선택</td></tr>
</table>

<h3>마우스 조작</h3>
<table border="1" style="border-collapse: collapse; width: 100%;">
<tr style="background-color: rgba(255,255,255,0.1);">
<th style="padding: 8px;">조작</th>
<th style="padding: 8px;">기능</th>
<th style="padding: 8px;">설명</th>
</tr>
<tr><td style="padding: 8px;"><strong>더블클릭</strong></td><td style="padding: 8px;">이름 변경</td><td style="padding: 8px;">페이지/북 이름 변경 모드</td></tr>
<tr><td style="padding: 8px;"><strong>우클릭</strong></td><td style="padding: 8px;">컨텍스트 메뉴</td><td style="padding: 8px;">상황별 메뉴 표시</td></tr>
<tr><td style="padding: 8px;"><strong>드래그</strong></td><td style="padding: 8px;">순서 변경</td><td style="padding: 8px;">커스텀 정렬 모드에서 순서 변경</td></tr>
<tr><td style="padding: 8px;"><strong>다중 드래그</strong></td><td style="padding: 8px;">일괄 이동</td><td style="padding: 8px;">선택된 여러 항목 동시 이동</td></tr>
</table>

<h3>단축키 사용 팁</h3>
<ul>
<li>단축키는 해당 영역에 포커스가 있을 때 작동</li>
<li><strong>Ctrl+S</strong> 사용 시 저장 완료 툴팁 표시</li>
<li><strong>Delete</strong> 키는 현재 포커스된 리스트에 따라 북/페이지 삭제</li>
<li><strong>F2</strong> 키도 포커스된 리스트에 따라 동작</li>
</ul>
                """,
                "children": {}
            },
            "🎨 테마": {
                "content": """
<h2>🎨 테마 및 커스터마이징</h2>

<h3>테마 변경하기</h3>
<ol>
<li>상단 <strong>☰ 메뉴</strong> 클릭</li>
<li><strong>"테마"</strong> 하위 메뉴 선택</li>
<li>원하는 테마 클릭</li>
<li>즉시 적용됨</li>
</ol>

<h3>사용 가능한 테마</h3>
<p><strong>기본 테마:</strong></p>
<ul>
<li>🌙 <strong>어두운 모드:</strong> 기본 다크 테마</li>
<li>☀️ <strong>밝은 모드:</strong> 화이트 테마</li>
</ul>

<p><strong>컬러 테마:</strong></p>
<ul>
<li>🌊 <strong>파란 바다:</strong> 블루 계열</li>
<li>🌲 <strong>숲속:</strong> 그린 계열</li>
<li>🌌 <strong>보라 우주:</strong> 퍼플 계열</li>
<li>🌅 <strong>황혼:</strong> 오렌지 계열</li>
<li>🌸 <strong>벚꽃:</strong> 핑크 계열</li>
<li>🍃 <strong>민트:</strong> 민트 계열</li>
</ul>

<p><strong>네온 테마:</strong></p>
<ul>
<li>⚡ <strong>블루 네온:</strong> 사이버펑크 블루</li>
<li>💖 <strong>핑크 네온:</strong> 사이버펑크 핑크</li>
</ul>

<h3>커스텀 테마</h3>
<p><strong>커스텀 테마 설정:</strong></p>
<ol>
<li>☰ 메뉴 → <strong>"테마"</strong> → <strong>"커스텀 테마"</strong> 선택</li>
<li>배경 이미지 파일 선택 (PNG, JPG, JPEG, BMP, GIF, TIFF, WEBP)</li>
<li>프로그램 재시작 확인 대화상자에서 <strong>"재시작"</strong> 선택</li>
<li>재시작 후 배경 이미지가 적용된 커스텀 테마 사용</li>
</ol>

<p><strong>커스텀 테마 특징:</strong></p>
<ul>
<li><strong>배경 이미지:</strong> 선택한 이미지가 창 전체 배경으로 적용</li>
<li><strong>투명도 조절:</strong> UI 요소들의 투명도를 개별 조절 가능</li>
<li><strong>자동 크기 조절:</strong> 이미지가 창 크기에 맞게 자동 조절</li>
<li><strong>고품질 렌더링:</strong> 부드러운 이미지 변환으로 고품질 표시</li>
</ul>

<p><strong>⚠️ 주의사항:</strong></p>
<ul>
<li>커스텀 테마 적용 시 프로그램 재시작 필요</li>
<li>너무 밝거나 복잡한 이미지는 텍스트 가독성 저하</li>
<li>어두운 톤의 이미지 권장</li>
<li>고해상도 이미지 사용 시 성능 고려</li>
</ul>

<h3>테마 특징</h3>
<ul>
<li>모든 테마는 눈의 피로를 최소화하도록 설계</li>
<li>텍스트 가독성 최우선 고려</li>
<li>다크/라이트 모드 모두 지원</li>
<li>테마 설정은 자동 저장됨</li>
<li>커스텀 테마로 개인화 가능</li>
</ul>

<h3>UI 커스터마이징</h3>
<p><strong>창 크기 조절:</strong></p>
<ul>
<li>창 가장자리를 드래그하여 크기 조절</li>
<li>모서리 드래그로 대각선 크기 조절</li>
<li>최대화/복원 버튼 사용</li>
</ul>

<p><strong>패널 크기 조절:</strong></p>
<ul>
<li>패널 사이의 구분선을 드래그</li>
<li>북 리스트, 페이지 리스트, 편집 영역 비율 조절</li>
<li>설정이 자동 저장됨</li>
</ul>

<p><strong>창 이동:</strong></p>
<ul>
<li>타이틀 바를 드래그하여 창 이동</li>
<li>더블클릭으로 최대화/복원</li>
</ul>
                """,
                "children": {}
            },
            "⚙️ 옵션": {
                "content": """
<h2>⚙️ 옵션 및 고급 설정</h2>

<h3>투명도 설정</h3>
<p><strong>창 투명도 조절:</strong></p>
<ol>
<li>☰ 메뉴 → <strong>"옵션"</strong> → <strong>"윈도우 투명도 조절"</strong></li>
<li>슬라이더로 투명도 조절 (10% ~ 100%)</li>
<li>실시간으로 변경 사항 확인</li>
<li><strong>"적용"</strong> 버튼으로 설정 저장</li>
</ol>

<p><strong>커스텀 테마 투명도:</strong></p>
<ol>
<li>먼저 <strong>커스텀 테마</strong>를 선택해야 함</li>
<li>☰ 메뉴 → <strong>"옵션"</strong> → <strong>"커스텀 테마 투명도 조절"</strong></li>
<li>배경과 UI 요소의 투명도 개별 조절</li>
<li>더욱 세밀한 투명도 제어 가능</li>
<li>실시간 미리보기 지원</li>
</ol>

<h3>UI 좌우반전</h3>
<p><strong>레이아웃 변경:</strong></p>
<ol>
<li>☰ 메뉴 → <strong>"옵션"</strong> → <strong>"🔄 UI 좌우반전"</strong></li>
<li>패널 순서가 좌우로 반전됨</li>
<li><strong>기본:</strong> 북 리스트 | 페이지 리스트 | 편집 영역</li>
<li><strong>반전:</strong> 편집 영역 | 페이지 리스트 | 북 리스트</li>
</ol>

<p><strong>사용 시나리오:</strong></p>
<ul>
<li><strong>왼손잡이 사용자:</strong> 마우스 동선 최적화</li>
<li><strong>멀티 모니터:</strong> 모니터 배치에 맞는 레이아웃</li>
<li><strong>개인 선호:</strong> 편집 영역을 왼쪽에 배치</li>
<li><strong>작업 효율:</strong> 자주 사용하는 영역을 가까이</li>
</ul>

<h3>시스템 트레이 상주</h3>
<p><strong>트레이 상주 설정:</strong></p>
<ol>
<li>☰ 메뉴 → <strong>"옵션"</strong> → <strong>"🔽 시스템 트레이에 상주"</strong></li>
<li>체크 표시로 활성화/비활성화</li>
<li>활성화 시 X 버튼으로 닫아도 프로그램 종료되지 않음</li>
<li>시스템 트레이에 프롬프트북 아이콘 표시</li>
</ol>

<p><strong>트레이 아이콘 사용법:</strong></p>
<ul>
<li><strong>좌클릭:</strong> 창 표시/숨김 토글</li>
<li><strong>우클릭:</strong> 컨텍스트 메뉴 (창 표시, 완전 종료)</li>
<li><strong>더블클릭:</strong> 창 복원 및 포커스</li>
</ul>

<p><strong>활용 시나리오:</strong></p>
<ul>
<li><strong>백그라운드 작업:</strong> 다른 작업 중 빠른 메모</li>
<li><strong>메모리 절약:</strong> 창 숨김으로 화면 공간 확보</li>
<li><strong>빠른 접근:</strong> 트레이에서 즉시 접근</li>
<li><strong>멀티태스킹:</strong> 여러 프로그램과 함께 사용</li>
</ul>

<h3>창 맨 위에 고정</h3>
<p><strong>항상 위 표시:</strong></p>
<ol>
<li>☰ 메뉴 → <strong>"옵션"</strong> → <strong>"📌 창 맨 위에 고정"</strong></li>
<li>체크 시 다른 창 위에 항상 표시</li>
<li>다른 프로그램 사용 중에도 프롬프트북이 보임</li>
</ol>

<p><strong>💡 투명도 사용 팁:</strong></p>
<ul>
<li>다른 프로그램과 함께 사용할 때 유용</li>
<li>배경 화면을 보면서 작업할 때</li>
<li>미니멀한 UI 선호 시</li>
<li>멀티 모니터 환경에서 효과적</li>
</ul>

<h3>성능 최적화 팁</h3>
<p><strong>투명도 관련:</strong></p>
<ul>
<li>너무 많은 투명도 사용 시 성능 저하 가능</li>
<li>Windows 10 이상에서 최적화됨</li>
<li>그래픽 드라이버 최신 버전 권장</li>
</ul>

<p><strong>이미지 관리:</strong></p>
<ul>
<li>너무 큰 이미지 파일은 성능에 영향</li>
<li>적절한 해상도 사용 권장</li>
</ul>
                """,
                "children": {}
            },
                         "💾 개별 북 저장": {
                 "content": """
 <h2>💾 개별 북 저장 및 불러오기</h2>
 
 <h3>북 저장하기</h3>
 <p><strong>개별 북 백업:</strong></p>
 <ol>
 <li>저장할 북 선택</li>
 <li>상단 <strong>☰ 메뉴</strong> → <strong>"파일"</strong> → <strong>"💾 선택된 북 저장하기"</strong></li>
 <li>저장 위치와 파일명 지정</li>
 <li><strong>".zip"</strong> 파일로 저장됨</li>
 </ol>
 
 <p><strong>저장 내용:</strong></p>
 <ul>
 <li>선택된 북의 모든 페이지 데이터</li>
 <li>첨부된 모든 이미지 파일</li>
 <li>북 설정 (이모지, 즐겨찾기 등)</li>
 <li>페이지 순서 정보</li>
 </ul>
 
 <h3>북 불러오기</h3>
 <p><strong>저장된 북 복원:</strong></p>
 <ol>
 <li>상단 <strong>☰ 메뉴</strong> → <strong>"파일"</strong> → <strong>"📂 저장된 북 불러오기"</strong></li>
 <li>저장된 <strong>".zip"</strong> 파일 선택</li>
 <li><strong>"열기"</strong> 클릭</li>
 <li>자동으로 북과 페이지들이 추가됨</li>
 </ol>
 
 <p><strong>불러오기 특징:</strong></p>
 <ul>
 <li>기존 북과 이름이 같으면 자동으로 번호 추가</li>
 <li>모든 이미지 파일도 함께 복원</li>
 <li>페이지 순서와 설정 모두 유지</li>
 <li>기존 데이터에 추가되는 방식</li>
 </ul>
 
 <h3>활용 시나리오</h3>
 <p><strong>북 공유:</strong></p>
 <ul>
 <li>완성된 프로젝트를 다른 사용자와 공유</li>
 <li>팀 작업 시 개별 북 교환</li>
 <li>템플릿 북 배포</li>
 </ul>
 
 <p><strong>백업 및 이동:</strong></p>
 <ul>
 <li>중요한 북만 선별적으로 백업</li>
 <li>다른 컴퓨터로 특정 북 이동</li>
 <li>프로젝트별 아카이브 생성</li>
 </ul>
 
 <h3>자동 저장 기능</h3>
 <p><strong>실시간 저장:</strong></p>
 <ul>
 <li>페이지 내용 편집 시 자동으로 저장됨</li>
 <li>프로그램 종료 시에도 자동 저장</li>
 <li><strong>Ctrl+S</strong>로 수동 저장 가능</li>
 </ul>
 
 <h3>데이터 파일 위치</h3>
 <ul>
 <li><strong>메인 데이터:</strong> character_data.json</li>
 <li><strong>UI 설정:</strong> ui_settings.json</li>
 <li><strong>이미지 파일:</strong> images/ 폴더</li>
 <li>이 파일들을 직접 백업해도 됨</li>
 </ul>
                 """,
                 "children": {}
             },
            "🖼️ EXIF/프롬프트 뷰어": {
                "content": """
<h2>🖼️ EXIF/프롬프트 뷰어</h2>

<h3>EXIF 정보 보기</h3>
<p><strong>사용 방법:</strong></p>
<ol>
<li>페이지에 이미지를 추가</li>
<li>이미지 위에 <strong>마우스 호버</strong></li>
<li>EXIF 정보가 오버레이로 표시됨</li>
</ol>

<p><strong>표시되는 정보:</strong></p>
<ul>
<li><strong>파일 정보:</strong> 파일명, 크기, 해상도</li>
<li><strong>카메라 정보:</strong> 카메라 모델, 렌즈 정보</li>
<li><strong>촬영 설정:</strong> ISO, 셔터 속도, 조리개</li>
<li><strong>AI 프롬프트:</strong> 이미지에 포함된 AI 생성 정보</li>
</ul>

<h3>AI 프롬프트 추출</h3>
<p><strong>지원하는 AI 도구:</strong></p>
<ul>
<li><strong>NovelAI:</strong> 프롬프트와 네거티브 프롬프트 추출</li>
<li><strong>Stable Diffusion:</strong> 생성 파라미터 추출</li>
<li><strong>기타 AI 도구:</strong> 메타데이터에서 프롬프트 정보 추출</li>
</ul>

<p><strong>프롬프트 활용:</strong></p>
<ol>
<li>EXIF 오버레이에서 프롬프트 텍스트 확인</li>
<li>원하는 텍스트를 <strong>드래그하여 선택</strong></li>
<li><strong>우클릭</strong> → <strong>"선택된 텍스트 복사"</strong></li>
<li>또는 <strong>"프롬프트를 입력창에 붙여넣기"</strong> 선택</li>
<li>페이지 편집 영역에 자동으로 붙여넣어짐</li>
</ol>

<h3>EXIF 뷰어 설정</h3>
<p><strong>표시/숨김 토글:</strong></p>
<ul>
<li>이미지 하단의 <strong>"EXIF 정보 표시"</strong> 체크박스</li>
<li>체크 해제 시 마우스 호버해도 EXIF 정보 표시 안 됨</li>
<li>설정은 자동으로 저장됨</li>
</ul>

<p><strong>💡 활용 팁:</strong></p>
<ul>
<li>AI 생성 이미지의 프롬프트를 쉽게 재사용 가능</li>
<li>이미지 품질 분석에 유용한 EXIF 정보 확인</li>
<li>프롬프트 연구 및 학습에 활용</li>
</ul>
                """,
                "children": {}
            },
                         "📋 복사/붙여넣기": {
                "content": """
<h2>📋 복사/붙여넣기 - 북 간 페이지 이동</h2>

<p><strong>🎯 핵심 기능:</strong> 페이지를 다른 북으로 복사하거나 이동할 수 있습니다!</p>

<h3>페이지 복사하기</h3>
<p><strong>단일 페이지 복사:</strong></p>
<ol>
<li>복사할 페이지 선택</li>
<li><strong>Ctrl+C</strong> 또는 우클릭 → <strong>"복사"</strong></li>
<li>페이지가 클립보드에 복사됨</li>
</ol>

<p><strong>다중 페이지 복사:</strong></p>
<ol>
<li><strong>Ctrl+클릭</strong>으로 여러 페이지 선택</li>
<li><strong>Ctrl+C</strong></li>
<li>선택된 모든 페이지가 클립보드에 복사됨</li>
</ol>

<h3>페이지 잘라내기 (이동)</h3>
<p><strong>사용 방법:</strong></p>
<ol>
<li>이동할 페이지 선택</li>
<li><strong>Ctrl+X</strong> 또는 우클릭 → <strong>"잘라내기"</strong></li>
<li>페이지가 클립보드로 이동 (원본에서 제거됨)</li>
</ol>

<h3>🔥 북 간 페이지 붙여넣기 (핵심!)</h3>
<p><strong>⚠️ 중요:</strong> 붙여넣기는 반드시 <strong>북을 선택한 상태</strong>에서 해야 합니다!</p>

<p><strong>올바른 방법:</strong></p>
<ol>
<li>원본 북에서 페이지 복사/잘라내기 (<strong>Ctrl+C</strong> 또는 <strong>Ctrl+X</strong>)</li>
<li><strong>왼쪽 북 리스트에서 대상 북 클릭</strong> (북 선택)</li>
<li>북이 선택되면 가운데 페이지 리스트가 나타남</li>
<li>페이지 리스트 영역에서 <strong>Ctrl+V</strong> 또는 우클릭 → <strong>"붙여넣기"</strong></li>
<li>페이지가 대상 북으로 이동/복사됨</li>
</ol>

<p><strong>❌ 작동하지 않는 경우:</strong></p>
<ul>
<li>북을 선택하지 않은 상태에서 붙여넣기</li>
<li>페이지 리스트가 비어있는 상태에서 붙여넣기</li>
<li>다른 영역(편집 영역 등)에서 붙여넣기</li>
</ul>

<h3>같은 북 내 복제</h3>
<p><strong>같은 북에서 페이지 복제:</strong></p>
<ol>
<li>복사할 페이지 선택</li>
<li><strong>Ctrl+C</strong></li>
<li>같은 북에서 <strong>Ctrl+V</strong></li>
<li>페이지가 복제되어 추가됨</li>
</ol>

<h3>복사 vs 이동</h3>
<p><strong>복사 (Ctrl+C):</strong></p>
<ul>
<li>원본 페이지 유지</li>
<li>대상 북에 복제본 생성</li>
<li>백업이나 공유 목적에 적합</li>
</ul>

<p><strong>이동 (Ctrl+X):</strong></p>
<ul>
<li>원본 페이지 제거</li>
<li>대상 북으로 완전 이동</li>
<li>페이지 정리나 재구성에 적합</li>
</ul>

<h3>이미지 파일 자동 처리</h3>
<ul>
<li>페이지에 첨부된 이미지도 함께 복사/이동됨</li>
<li>이미지 파일명 중복 시 자동으로 번호 추가</li>
<li>원본 이미지 파일은 안전하게 보존됨</li>
</ul>

<h3>활용 시나리오</h3>
<p><strong>프로젝트 간 자료 이동:</strong></p>
<ul>
<li><strong>캐릭터 설정</strong>을 "임시" 북에서 "메인 프로젝트" 북으로 이동</li>
<li><strong>공통 설정</strong>을 여러 프로젝트 북에 복사</li>
<li><strong>완성된 페이지</strong>를 "작업중" 북에서 "완료" 북으로 이동</li>
</ul>

<p><strong>작업 효율성:</strong></p>
<ul>
<li>템플릿 페이지를 여러 북에서 재사용</li>
<li>실험적 수정을 위한 임시 복사</li>
<li>프로젝트 단계별 페이지 이동</li>
</ul>

<p><strong>💡 핵심 팁:</strong></p>
<ul>
<li><strong>반드시 북을 먼저 선택!</strong> 페이지 리스트가 보여야 붙여넣기 가능</li>
<li>대량 페이지 이동 시 잘라내기(Ctrl+X) 사용</li>
<li>백업 목적으로는 복사(Ctrl+C) 사용</li>
<li>다중 선택으로 여러 페이지 한 번에 이동 가능</li>
</ul>
                """,
                "children": {}
            },
            "💾 백업 및 복원": {
                "content": """
<h2>💾 백업 및 복원</h2>

<h3>전체 북 리스트 백업</h3>
<p><strong>백업 방법:</strong></p>
<ol>
<li>상단 <strong>☰ 메뉴</strong> → <strong>"파일"</strong> → <strong>"💾 백업"</strong></li>
<li><strong>"📦 현재 북 리스트 백업"</strong> 선택</li>
<li>저장 위치와 파일명 지정</li>
<li><strong>".backup"</strong> 파일로 저장됨</li>
</ol>

<p><strong>백업 내용:</strong></p>
<ul>
<li><strong>모든 북과 페이지:</strong> 전체 데이터베이스</li>
<li><strong>이미지 파일:</strong> 첨부된 모든 이미지</li>
<li><strong>설정 정보:</strong> 북/페이지 순서, 즐겨찾기, 잠금 상태</li>
<li><strong>UI 설정:</strong> 테마, 창 크기, 패널 비율</li>
</ul>

<h3>백업에서 복원</h3>
<p><strong>복원 방법:</strong></p>
<ol>
<li>상단 <strong>☰ 메뉴</strong> → <strong>"파일"</strong> → <strong>"💾 백업"</strong></li>
<li><strong>"📥 백업된 북 리스트로 복구"</strong> 선택</li>
<li>백업 파일 목록에서 원하는 파일 선택</li>
<li><strong>"복구"</strong> 버튼 클릭</li>
<li>확인 대화상자에서 <strong>"예"</strong> 선택</li>
</ol>

<p><strong>복원 특징:</strong></p>
<ul>
<li><strong>완전 복원:</strong> 현재 데이터를 백업 시점으로 완전 교체</li>
<li><strong>이미지 복원:</strong> 모든 이미지 파일도 함께 복원</li>
<li><strong>설정 복원:</strong> UI 설정과 사용자 환경도 복원</li>
<li><strong>자동 재시작:</strong> 복원 후 프로그램 자동 재시작</li>
</ul>

<h3>백업 파일 관리</h3>
<p><strong>백업 파일 위치:</strong></p>
<ul>
<li>프로그램 폴더 내 <strong>"backups"</strong> 폴더</li>
<li>파일명에 날짜와 시간 자동 포함</li>
<li>예: <strong>"backup_2024-01-15_14-30-25.backup"</strong></li>
</ul>

<p><strong>백업 파일 삭제:</strong></p>
<ol>
<li>복원 대화상자에서 삭제할 파일 선택</li>
<li><strong>"삭제"</strong> 버튼 클릭</li>
<li>확인 후 백업 파일 영구 삭제</li>
</ol>

<h3>백업 전략 권장사항</h3>
<p><strong>정기 백업:</strong></p>
<ul>
<li>중요한 작업 완료 후 즉시 백업</li>
<li>주간/월간 정기 백업 스케줄 설정</li>
<li>대규모 수정 작업 전 사전 백업</li>
</ul>

<p><strong>백업 파일 보관:</strong></p>
<ul>
<li>클라우드 저장소에 백업 파일 업로드</li>
<li>외부 저장장치에 추가 백업</li>
<li>여러 시점의 백업 파일 보관</li>
</ul>

<p><strong>⚠️ 주의사항:</strong></p>
<ul>
<li>복원 시 현재 데이터가 완전히 교체됨</li>
<li>복원 전 현재 상태 백업 권장</li>
<li>백업 파일 손상 시 복원 불가</li>
<li>정기적인 백업 파일 무결성 확인 필요</li>
</ul>

<h3>개별 북 백업과의 차이점</h3>
<p><strong>전체 백업 vs 개별 북 저장:</strong></p>
<ul>
<li><strong>전체 백업:</strong> 모든 북 + UI 설정 + 전체 환경</li>
<li><strong>개별 북 저장:</strong> 선택된 북만 .zip 파일로 저장</li>
<li><strong>용도:</strong> 전체 백업은 시스템 복원, 개별 저장은 공유/이동</li>
</ul>
                """,
                "children": {}
            },
            "🔧 고급 기능": {
                "content": """
<h2>🔧 고급 기능</h2>



<h3>검색 고급 팁</h3>
<p><strong>태그 활용:</strong></p>
<ul>
<li>페이지에 관련 태그 입력 (예: "주인공, 남성, 20대")</li>
<li>검색 시 태그로도 검색 가능</li>
<li>쉼표로 여러 태그 구분</li>
</ul>

<p><strong>검색 조합:</strong></p>
<ul>
<li>여러 단어 조합 검색 가능</li>
<li>부분 검색 지원</li>
<li>실시간 필터링으로 즉시 결과 확인</li>
</ul>

<h3>정렬 전략</h3>
<p><strong>즐겨찾기 활용:</strong></p>
<ul>
<li>자주 사용하는 북/페이지를 즐겨찾기로 설정</li>
<li>즐겨찾기순 정렬로 빠른 접근</li>
<li>프로젝트별로 즐겨찾기 그룹화</li>
</ul>

<p><strong>커스텀 정렬:</strong></p>
<ul>
<li>작업 순서에 맞게 수동 정렬</li>
<li>중요도 순으로 배치</li>
<li>스토리 흐름에 맞는 순서 설정</li>
</ul>

<h3>효율적인 작업 흐름</h3>
<p><strong>프로젝트 구성:</strong></p>
<ol>
<li>프로젝트별로 북 생성</li>
<li>캐릭터/설정별로 페이지 분류</li>
<li>태그로 세부 분류</li>
<li>즐겨찾기로 중요 항목 표시</li>
</ol>

<p><strong>빠른 작업:</strong></p>
<ul>
<li>단축키 적극 활용</li>
<li>다중 선택으로 일괄 작업</li>
<li>검색으로 빠른 항목 찾기</li>
<li>복제 기능으로 유사 항목 생성</li>
</ul>

<h3>페이지 잠금 활용</h3>
<p><strong>사용 시나리오:</strong></p>
<ul>
<li>완성된 캐릭터 설정 보호</li>
<li>실수로 삭제 방지</li>
<li>중요한 레퍼런스 자료 보호</li>
</ul>

<p><strong>잠금 관리:</strong></p>
<ul>
<li>작업 완료 후 잠금 설정</li>
<li>수정 필요 시 잠금 해제</li>
<li>🔒 아이콘으로 잠금 상태 확인</li>
</ul>
                """,
                "children": {}
            },

        }
        
        # 트리 아이템 생성 및 내용 매핑
        self.manual_content_map = {}
        
        for title, data in manual_data.items():
            item = QTreeWidgetItem([title])
            tree_widget.addTopLevelItem(item)
            self.manual_content_map[item] = data["content"]
            
            # 자식 항목이 있다면 추가 (현재는 없음)
            for child_title, child_data in data["children"].items():
                child_item = QTreeWidgetItem([child_title])
                item.addChild(child_item)
                self.manual_content_map[child_item] = child_data["content"]
        
        # 트리 아이템 클릭 이벤트 연결
        def on_item_clicked(item, column):
            if item in self.manual_content_map:
                content_area.setHtml(self.manual_content_map[item])
        
        tree_widget.itemClicked.connect(on_item_clicked)
        
        # 첫 번째 항목 기본 선택
        if tree_widget.topLevelItemCount() > 0:
            first_item = tree_widget.topLevelItem(0)
            tree_widget.setCurrentItem(first_item)
            content_area.setHtml(self.manual_content_map[first_item])
        
        # 레이아웃에 위젯 추가
        layout.addWidget(tree_widget)
        layout.addWidget(content_area)
        
        # 하단 버튼 영역
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        
        close_button = QPushButton("닫기")
        close_button.clicked.connect(dialog.accept)
        button_layout.addWidget(close_button)
        
        main_layout = QVBoxLayout()
        main_layout.addLayout(layout)
        main_layout.addLayout(button_layout)
        
        dialog.setLayout(main_layout)
        
        # 다이얼로그 표시
        dialog.exec()



    def backup_book_list(self):
        """현재 북 리스트를 암호화하여 백업"""
        try:
            # 백업할 데이터가 있는지 확인
            print(f"[DEBUG] books 속성 존재: {hasattr(self, 'books')}")
            if hasattr(self, 'books'):
                print(f"[DEBUG] books 내용: {self.books}")
                print(f"[DEBUG] books 길이: {len(self.books) if self.books else 0}")
            
            # UI에서 북 리스트 개수 확인
            book_count = self.book_list.count()
            print(f"[DEBUG] UI 북 리스트 개수: {book_count}")
            
            # state.books를 사용하도록 수정 (실제 데이터 구조와 일치)
            if hasattr(self, 'state') and hasattr(self.state, 'books'):
                books_data = self.state.books
                print(f"[DEBUG] state.books 사용: {books_data}")
            else:
                # state가 없다면 빈 딕셔너리로 초기화
                books_data = {}
                print("[DEBUG] state.books가 없어서 빈 딕셔너리 사용")
            
            print(f"[DEBUG] 백업할 북 데이터: {books_data}")
            print(f"[DEBUG] 백업 진행 - 북 개수: {len(books_data)}")

            # 백업 디렉토리 생성
            backup_dir = get_backup_directory()
            
            # 현재 시간으로 백업 파일명 생성
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_filename = f"booklist_backup_{timestamp}.pbk"
            backup_path = os.path.join(backup_dir, backup_filename)
            
            # 이미지 개수 미리 계산
            images_dir = get_images_directory()
            image_count = 0
            if os.path.exists(images_dir):
                for filename in os.listdir(images_dir):
                    if filename.lower().endswith(('.png', '.jpg', '.jpeg', '.bmp', '.gif')):
                        image_count += 1
            
            # 백업 확인 대화상자
            reply = QMessageBox.question(
                self,
                "백업 확인",
                f"현재 북 리스트를 백업하시겠습니까?\n\n"
                f"📚 북 개수: {len(books_data)}개\n"
                f"🖼️ 이미지 개수: {image_count}개\n\n"
                f"백업 파일은 ./backup/ 폴더에 저장됩니다.",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.Yes
            )
            
            if reply != QMessageBox.Yes:
                return
            
            # 진행 상황 대화상자
            progress = QProgressDialog("북 리스트 백업 중...", "취소", 0, 100, self)
            progress.setWindowModality(Qt.WindowModal)
            progress.show()
            QApplication.processEvents()
            
            # 백업할 데이터 준비
            backup_data = {
                "version": self.VERSION,
                "timestamp": timestamp,
                "books": books_data,
                "images": {}
            }
            
            progress.setValue(20)
            QApplication.processEvents()
            
            # 이미지 파일들을 base64로 인코딩하여 포함
            images_dir = get_images_directory()
            if os.path.exists(images_dir):
                for filename in os.listdir(images_dir):
                    if filename.lower().endswith(('.png', '.jpg', '.jpeg', '.bmp', '.gif')):
                        image_path = os.path.join(images_dir, filename)
                        try:
                            with open(image_path, 'rb') as f:
                                image_data = base64.b64encode(f.read()).decode('utf-8')
                                backup_data["images"][filename] = image_data
                        except Exception as e:
                            print(f"이미지 백업 실패 {filename}: {e}")
            
            progress.setValue(60)
            QApplication.processEvents()
            
            # JSON으로 직렬화
            json_data = json.dumps(backup_data, ensure_ascii=False, indent=2)
            
            progress.setValue(80)
            QApplication.processEvents()
            
            # ZIP 파일로 압축 (암호화 없이)
            with zipfile.ZipFile(backup_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
                zipf.writestr("backup.json", json_data)
                # 메타데이터 추가
                metadata = {
                    "created": timestamp,
                    "version": self.VERSION,
                    "book_count": len(books_data),
                    "image_count": len(backup_data["images"])
                }
                zipf.writestr("metadata.json", json.dumps(metadata, ensure_ascii=False, indent=2))
            
            progress.setValue(100)
            QApplication.processEvents()
            progress.close()
            
            # 성공 메시지
            QMessageBox.information(
                self,
                "백업 완료",
                f"북 리스트가 성공적으로 백업되었습니다.\n\n"
                f"백업 파일: {backup_filename}\n"
                f"백업 시간: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
                f"북 개수: {len(books_data)}개\n"
                f"이미지 개수: {len(backup_data['images'])}개\n\n"
                f"📁 백업 위치: ./backup/ 폴더"
            )
            
        except Exception as e:
            QMessageBox.critical(
                self,
                "백업 실패",
                f"백업 중 오류가 발생했습니다:\n{str(e)}"
            )

    def restore_book_list(self):
        """백업된 북 리스트로 복구"""
        try:
            backup_dir = get_backup_directory()
            
            # 백업 파일 목록 가져오기
            backup_files = []
            if os.path.exists(backup_dir):
                for filename in os.listdir(backup_dir):
                    if filename.endswith('.pbk'):
                        backup_path = os.path.join(backup_dir, filename)
                        try:
                            # 메타데이터 읽기
                            with zipfile.ZipFile(backup_path, 'r') as zipf:
                                if 'metadata.json' in zipf.namelist():
                                    metadata_str = zipf.read('metadata.json').decode('utf-8')
                                    metadata = json.loads(metadata_str)
                                    backup_files.append({
                                        'filename': filename,
                                        'path': backup_path,
                                        'metadata': metadata
                                    })
                        except Exception as e:
                            print(f"백업 파일 메타데이터 읽기 실패 {filename}: {e}")
            
            if not backup_files:
                QMessageBox.warning(self, "복구 실패", "백업 파일을 찾을 수 없습니다.")
                return
            
            # 백업 파일 선택 대화상자
            dialog = QDialog(self)
            dialog.setWindowTitle("백업 파일 선택")
            dialog.setFixedSize(500, 400)
            
            layout = QVBoxLayout(dialog)
            
            # 안내 메시지
            info_label = QLabel("복구할 백업 파일을 선택하세요:")
            info_label.setStyleSheet("font-weight: bold; margin-bottom: 10px;")
            layout.addWidget(info_label)
            
            # 백업 파일 목록
            file_list = QListWidget()
            for backup_info in backup_files:
                metadata = backup_info['metadata']
                created_time = datetime.datetime.strptime(metadata['created'], "%Y%m%d_%H%M%S")
                display_text = (
                    f"📅 {created_time.strftime('%Y-%m-%d %H:%M:%S')}\n"
                    f"📚 북 {metadata['book_count']}개, 🖼️ 이미지 {metadata['image_count']}개\n"
                    f"📁 {backup_info['filename']}"
                )
                
                item = QListWidgetItem(display_text)
                item.setData(Qt.UserRole, backup_info)
                file_list.addItem(item)
            
            layout.addWidget(file_list)
            
            # 경고 메시지
            warning_label = QLabel(
                "⚠️ 경고: 현재 북 리스트를 모두 삭제하고 백업된 시점으로 되돌립니다.\n"
                "이 작업은 되돌릴 수 없습니다!"
            )
            warning_label.setStyleSheet("color: red; font-weight: bold; margin: 10px 0;")
            warning_label.setWordWrap(True)
            layout.addWidget(warning_label)
            
            # 버튼
            button_layout = QHBoxLayout()
            
            # 삭제 버튼 추가
            delete_btn = QPushButton("🗑️ 삭제")
            delete_btn.setEnabled(False)
            delete_btn.clicked.connect(lambda: self.delete_backup_file(file_list, backup_files))
            button_layout.addWidget(delete_btn)
            
            button_layout.addStretch()
            
            cancel_btn = QPushButton("취소")
            cancel_btn.clicked.connect(dialog.reject)
            button_layout.addWidget(cancel_btn)
            
            restore_btn = QPushButton("복구")
            restore_btn.clicked.connect(dialog.accept)
            restore_btn.setEnabled(False)
            button_layout.addWidget(restore_btn)
            
            layout.addLayout(button_layout)
            
            # 선택 변경 시 버튼 활성화
            def on_selection_changed():
                has_selection = len(file_list.selectedItems()) > 0
                restore_btn.setEnabled(has_selection)
                delete_btn.setEnabled(has_selection)
            
            file_list.itemSelectionChanged.connect(on_selection_changed)
            
            # 대화상자 실행
            if dialog.exec() != QDialog.Accepted:
                return
            
            selected_items = file_list.selectedItems()
            if not selected_items:
                return
            
            backup_info = selected_items[0].data(Qt.UserRole)
            
            # 최종 확인
            metadata = backup_info['metadata']
            created_time = datetime.datetime.strptime(metadata['created'], "%Y%m%d_%H%M%S")
            
            reply = QMessageBox.question(
                self,
                "복구 확인",
                f"다음 백업으로 복구하시겠습니까?\n\n"
                f"📅 백업 시간: {created_time.strftime('%Y-%m-%d %H:%M:%S')}\n"
                f"📚 북 개수: {metadata['book_count']}개\n"
                f"🖼️ 이미지 개수: {metadata['image_count']}개\n\n"
                f"⚠️ 현재 모든 북이 삭제되고 백업 시점으로 되돌아갑니다!",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.No
            )
            
            if reply != QMessageBox.Yes:
                return
            
            # 복구 진행
            
            # 진행 상황 대화상자
            progress = QProgressDialog("북 리스트 복구 중...", "취소", 0, 100, self)
            progress.setWindowModality(Qt.WindowModal)
            progress.show()
            QApplication.processEvents()
            
            # 백업 파일 읽기
            with zipfile.ZipFile(backup_info['path'], 'r') as zipf:
                json_data = zipf.read('backup.json').decode('utf-8')
            
            progress.setValue(20)
            QApplication.processEvents()
            
            # JSON 파싱
            try:
                backup_data = json.loads(json_data)
            except Exception as e:
                progress.close()
                QMessageBox.critical(
                    self,
                    "복구 실패",
                    f"백업 파일이 손상되었습니다:\n{str(e)}"
                )
                return
            
            progress.setValue(40)
            QApplication.processEvents()
            
            # 현재 데이터 백업 (안전장치)
            current_backup = {
                "books": self.books if hasattr(self, 'books') else {},
                "timestamp": datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            }
            
            # 이미지 복원
            images_dir = get_images_directory()
            if backup_data.get("images"):
                for filename, image_data in backup_data["images"].items():
                    try:
                        image_path = os.path.join(images_dir, filename)
                        with open(image_path, 'wb') as f:
                            f.write(base64.b64decode(image_data))
                    except Exception as e:
                        print(f"이미지 복원 실패 {filename}: {e}")
            
            progress.setValue(70)
            QApplication.processEvents()
            
            # 북 데이터 복원 (호환성 검사 포함)
            books_data = backup_data.get("books", {})
            
            # 백업 데이터 호환성 검사
            if isinstance(books_data, dict):
                # 새로운 형식인지 확인
                if all(isinstance(v, dict) and 'pages' in v for v in books_data.values() if isinstance(v, dict)):
                    # 새로운 형식
                    restored_books = books_data
                else:
                    # 이전 형식일 가능성 - 기본 북으로 변환
                    if isinstance(books_data, list):
                        # 리스트 형태
                        restored_books = {
                            "기본 북": {
                                "pages": books_data,
                                "emoji": "📕",
                                "is_favorite": False
                            }
                        }
                    else:
                        # 딕셔너리지만 구조가 다른 경우
                        restored_books = books_data if books_data else {}
            else:
                restored_books = {}
            
            if hasattr(self, 'state'):
                self.state.books = restored_books
            else:
                # state가 없다면 생성
                from promptbook_state import PromptBookState
                self.state = PromptBookState()
                self.state.books = restored_books
            
            # UI 새로고침
            self.refresh_book_list()
            self.clear_page_list()
            
            # 데이터 저장
            self.save_to_file()
            
            progress.setValue(100)
            QApplication.processEvents()
            progress.close()
            
            # 성공 메시지
            QMessageBox.information(
                self,
                "복구 완료",
                f"북 리스트가 성공적으로 복구되었습니다.\n\n"
                f"📅 백업 시간: {created_time.strftime('%Y-%m-%d %H:%M:%S')}\n"
                f"📚 복구된 북: {len(restored_books)}개\n"
                f"🖼️ 복구된 이미지: {len(backup_data.get('images', {}))}개"
            )
            
        except Exception as e:
            QMessageBox.critical(
                self,
                "복구 실패",
                f"복구 중 오류가 발생했습니다:\n{str(e)}"
            )

    def delete_backup_file(self, file_list, backup_files):
        """선택된 백업 파일 삭제"""
        try:
            selected_items = file_list.selectedItems()
            if not selected_items:
                return
            
            backup_info = selected_items[0].data(Qt.UserRole)
            metadata = backup_info['metadata']
            created_time = datetime.datetime.strptime(metadata['created'], "%Y%m%d_%H%M%S")
            
            # 삭제 확인
            reply = QMessageBox.question(
                self,
                "백업 파일 삭제",
                f"다음 백업 파일을 삭제하시겠습니까?\n\n"
                f"📅 백업 시간: {created_time.strftime('%Y-%m-%d %H:%M:%S')}\n"
                f"📚 북 개수: {metadata['book_count']}개\n"
                f"🖼️ 이미지 개수: {metadata['image_count']}개\n"
                f"📁 파일명: {backup_info['filename']}\n\n"
                f"⚠️ 이 작업은 되돌릴 수 없습니다!",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.No
            )
            
            if reply != QMessageBox.Yes:
                return
            
            # 파일 삭제
            os.remove(backup_info['path'])
            
            # 리스트에서 제거
            current_row = file_list.row(selected_items[0])
            file_list.takeItem(current_row)
            
            # backup_files 리스트에서도 제거
            backup_files[:] = [bf for bf in backup_files if bf['path'] != backup_info['path']]
            
            QMessageBox.information(
                self,
                "삭제 완료",
                f"백업 파일이 성공적으로 삭제되었습니다.\n\n"
                f"📁 {backup_info['filename']}"
            )
            
        except Exception as e:
            QMessageBox.critical(
                self,
                "삭제 실패",
                f"백업 파일 삭제 중 오류가 발생했습니다:\n{str(e)}"
            )

    # def show_ai_tester(self):
#             """AI 기능 테스터 대화상자 표시"""
#             if AITesterDialog is None:
#                 QMessageBox.warning(
#                     self,
#                     "AI 테스터 오류",
#                     "AI 테스터 모듈을 불러올 수 없습니다.\n"
#                     "ai_tester.py 파일이 있는지 확인해주세요."
#                 )
#                 return
#             
#             try:
#                 dialog = AITesterDialog(self, self)
#                 dialog.exec()
#             except Exception as e:
#                 QMessageBox.critical(
#                     self,
#                     "AI 테스터 오류",
#                     f"AI 테스터를 실행하는 중 오류가 발생했습니다:\n{str(e)}"
#                 )

class LogDialog(QDialog):
    """로그 표시용 팝업 대화상자"""
    
    def __init__(self, title, message, details=None, parent=None):
        super().__init__(parent)
        self.setWindowTitle(title)
        self.setFixedSize(500, 400)
        
        # 레이아웃
        layout = QVBoxLayout(self)
        
        # 메인 메시지
        message_label = QLabel(message)
        message_label.setWordWrap(True)
        message_label.setStyleSheet("font-weight: bold; font-size: 12px; margin-bottom: 10px;")
        layout.addWidget(message_label)
        
        # 상세 정보 (있는 경우)
        if details:
            details_text = QTextEdit()
            details_text.setPlainText(details)
            details_text.setReadOnly(True)
            details_text.setStyleSheet("font-family: 'Consolas', 'Monaco', monospace; font-size: 10px;")
            layout.addWidget(details_text)
        
        # 버튼
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        
        close_button = QPushButton("닫기")
        close_button.clicked.connect(self.accept)
        close_button.setMinimumWidth(80)
        button_layout.addWidget(close_button)
        
        layout.addLayout(button_layout)

def show_error_popup(title, message, details=None):
    """오류 팝업창 표시"""
    try:
        app = QApplication.instance()
        if app is not None:
            dialog = LogDialog(title, message, details)
            dialog.exec()
        else:
            # GUI가 없는 경우 콘솔에 출력
            print(f"{title}: {message}")
            if details:
                print(f"상세 정보:\n{details}")
    except Exception as e:
        # 팝업 표시 실패 시 콘솔에 출력
        print(f"{title}: {message}")
        if details:
            print(f"상세 정보:\n{details}")
        print(f"팝업 표시 실패: {e}")

if __name__ == "__main__":
    try:
        app = QApplication(sys.argv)
        
        # 애플리케이션 아이콘 설정 (작업표시줄, 시스템 트레이 등에 표시)
        icon_path = "promptbook_icon.ico"
        if os.path.exists(icon_path):
            app.setWindowIcon(QIcon(icon_path))
        elif os.path.exists("icon.ico"):
            app.setWindowIcon(QIcon("icon.ico"))
        elif os.path.exists("icon.png"):
            app.setWindowIcon(QIcon("icon.png"))
        window = PromptBook()
        window.show()
        sys.exit(app.exec())
        
    except Exception as e:
        # 메인 실행 중 오류 발생 시 팝업으로 표시
        import traceback
        error_details = traceback.format_exc()
        show_error_popup(
            "프롬프트북 시작 오류",
            f"프로그램 시작 중 오류가 발생했습니다:\n{str(e)}",
            error_details
        )
        sys.exit(1)
    

    

